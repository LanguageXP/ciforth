@section Introduction
You may wonder why an optimizer for a computer language would be considered an
AI application.
This optimizer is not so much for a particular language as well
related to a Computer Intelligence that has insight in her own code.

Different types of optimisations interfere and finding ones way through this
certainly requires some heuristics. The bottom line is that an optimiser
qualifies as an AI application.

@subsection Properties

A Forth system is a database of small programs. It is worthwhile to
investigate what properties these small programs (words) might have.
The flag field of a word allow to add this information to the header.
A certain combination of flags allow a particular optimisation.

@subsection Definitions
An annihilator is a word that only deletes an item from the stack.
Examples are DROP 2DROP NIP RDROP.

A juggler reorders the stack without adding or removing items.
Examples are SWAP 2SWAP ROT.

A duplicator copies an item from the stack.
Examples are DUP OVER 2DUP.

@subsection Optimisations
Optimisations are manipulations on a program source or intermediate code
to improve the speed of the resulting program.
In other respect the result is inferior. Symbolic debugging --
one of Forth's strong points -- goes through the drain.
(The name "optimisation" is a misnomer.)

forthitemize
forthitem({folding})
Constant folding is a well known technique in optimisation.
It means that if an operator works on constants the result may be replaced
by a constant that is calculated at compile time.
In Forth we generalise this to folding.
Folding refers to all words that can be replaced by simpler words in case
they receive constant data on the stack.

forthitem({reordering})
Reordering is not so much an optimisation per se, but it allows other optimisations
to kick in. As a rule of thumb constants are moved to the top of the stack, where
they fall prey to folding.
Reordering might also eliminate a juggler.

forthitem({Annihilation})
In Forth sometimes the result of a calculation is dropped.
Depending on the properties of the calculation,
this calculation can sometimes be removed.
Annihilation is always related to an annihilator.

forthitem({Inlining})
Inlining means replacing a Forth word with its constituents.
This technique is extremely important in Forth, more so than
in other languages, due to the small size of Forth words.
Inlining is always a winner in speed, and mostly even also a
winner with regard to space.
forthenditemize

Even more important is the fact that inlining allows folding to be applied
across constituent words. This applies to high level and low level code
alike.

Inlining high level code is trivial.
A further inlining stage replaces a high level definition that only calls code
words, by a code definition which concatenates the code words.

@subsection Data collecting
While disassembling a code word, the registers used can be marked.
This allows to add register usage information to the header.

Also information about whether memory or I/O ports are
accessed for read or write
can be collected.

Finally the stack effect can be deduced from the number of POP's and
PUSH'es. And the use of the return stack can be marked, which means that
the code word has to be treated by hand.

After all code words have been analysed, and
the information has been completed manually where needed,
the stack effects and register usage can be concluded for all high level words.
The stack effect of a high level words is the concatenation of the stack effect
of its constituents. The register usage of a high level word is the logical or
of the register usage of the constituents.

@subsection Purpose
A \ci in general will use optimisation to generate a temporary definition
that is much faster, and retain all the valuable partial information about
words.

In normal non-AI applications, words are recursively replaced by faster words,
and those eventually by code definitions. Meanwhile words that are no longer directly
used in the final application are eliminated.
For space conservation headers may be removed as well provided in the application
no dictionary lookup is needed.

@section Implementation
The information about a word, optimisation opportunities and stack effect,
sits in the flag field.
Whenever nothing is filled in in the flag field, it means unknown.
This applies equally to the stack effect as to the optimisation flags.

@subsection Stack effects
The information about
the stack effects sits in the 3th byte of the flag field.
The highest nibble of this third byte applies to input.
It is the number of stack items popped plus one.
The lowest nibble thusly indicates the number of pushed items.
0 means an unknown (not yet analysed) stack effect.
0FH indicates a variable number of items.

The stack effect is added in three steps.
For all low level words the stack effect is found by counting
pops and pushes.
Irregular stack effects are corrected as well as filled in for high level words.
All high level stack effects are derived from the stack effect of their
constituents.

Code words are analysed by disassembling the code that is pointed to by the
code field to the first next code encountered. For each instruction
the opcode, which is the first part of its disassembly, is looked up in
a set of possible pop and push instructions.

Irregularities are just tabulated in the source code of the analyser.

High level words are recognized by their code field.
This takes care of any CREATE .. (;CODE) words.
For a linear chain of calls the stack effect is calculated as follows:

*Start with a zero -- zero stack effect.
*For each constituent
    subtract the pops from the left (output) nibble.
    if the output nibble is negative, subtract it from the inputs, and make it zero
    add the pushes to the left (output) nibble
(Correction by 11H is not yet done).

The following exceptions to a linear chain have special treatment:
* LIT BRANCH'es and SKIP are followed by inline data that must be taken care off
* a BRANCH or 0BRANCH forward is always taken, analysing just one path through a definition
* If the stack effect of a constituent is unknown, an unknown result overrules
  any other outcome
* For a CREATE .. DOES> word the linear chain pointed to by the DOES> pointer is
analysed. However the stack effect is initialised to ( 0 -- 1) to reflect the
passing of the data pointer to the  DOES> part.
* '<SOME-WORD> EXECUTE has the stack effect of <SOME-WORD> .
Other occurrences of EXECUTE lead to a variable stack effect.
* '<SOME-WORD> CATCH has the stack effect of <SOME-WORD> plus an extra output.
Other occurrences of CATCH lead to a variable stack effect.

A high level word is recognised by its code field address containing DOCOL , i.e. the
nesting routine for the interpreter. A CREATE .. DOES> word is detected by
is code field address containing DODOES , i.e. the common code that starts up words defined
by compiler extension.
All other words are treated as code.

The whole of Forth is treated as follows:
* Fill in the exception
* Sweep repeatedly through the dictionary, from early to latest:
    For each unknown stack effect, try to find it by discriminating between
    DODOES DOCOL and other words,
* Stop if no progress is made any more.

Hopefully everything is known now, but maybe we must add to the exceptions.

The notion of a simple sequence is one that doesn't reach to the stack outside
what is defined within the sequence.

@subsection Optimisation class
As has been pointed out, the optimisation class of a word is indicated by a bit
set
in the flags field. Each bit set opens up a particular opportunity for optimisation.
In general a sequence has a certain class if each constituent has that class.
For example, if one of the words called does a store, the sequence is found to
do a store and the optimisations that would be allowed by no stores are blocked.
forthsub subsection({The no store bit.})
The "no store" bit would better be named "no output side effect" bit.
It indicates that the outside world doesn't change by executing this word.
Again not that the stacks and internal registers are inside.


The following optimisation are opened up:
* In combination with an anihilator. If the output of a "no store" sequence is annihilated,
the whole sequence and the annihilator may be left out.
Example: BASE CELL+ @ XX @ NIP becomes XX @
* In combination with a juggler. If the outputs of "no store" sequence are juggled,
the sequences itself may be juggled, eliminating the juggler.
Example: XX CELL+ @ BASE @ SWAP becomes BASE @ XX CELL+ @
* In combinaton with a duplicator. Again a sequence may be duplicated and the duplicator
eliminated. This probably never makes sense as an optimisation.

Note that fetching from a port has an output side effect, (as well as an input side effect.)
forthsub subsection({The no fetch bit.})
The "no fetch" bit would better be named "no input side effect" bit.
It indicates that the outside world affects the outcome of this word.
Input side effects are weaker that output side effects and on their own
allow little optimisation.

In combiation with the "no store bit" a word is called "no side effect".
It is amenable to folding:
* If a NS-sequence has only constant inputs, it may be run at compile time
and the inputs and sequence by the resulting constant outputs.
Example: After "12 4 3    * +" is replaced by 24.
In fact this is equivalent to
* If a NS-sequence has no inputs, it may be run at compile time
and replaced by the resulting constant outputs.
The difference with the preceeding example is that the sequence starts
with 12 instead of *. Any literals are of course NS.


-------------------------------------------------------------
: A0 ;
: A1 A0 A0 ;
: A2 A1 A1 ;
: A3 A2 A1 :
By now you should understand that A2 does nothing and therefore we need another constant buffer.
: test UF 1m . THEN 12 ;
Right by remembering where it cane from , must return to.
How does it keep track e.g.can I execute the second A1 of A3 or of A2 the return stack.
Even here we can use the [ [ to interrupt the compulation and doe some calculation. The great advantage of a lifo buffer.

( In the first case A1 must return to point Q, and then A2 that is ..
this must return to R.
In the second case we must remember point P.
There is no problem that A1 in its turn executes A0 because that is the advatage of  las in first out buffer.

If you have interrupted a compilation or test in the module you can
investigate what FOrth is doing to compiler TEST. You can inspect the
memory where "TEXT" is stored and you will discover that IF has
remembered some dat that wll be used by THEN.

Keeping track of what you have,
As soon as you return from this subroutine you forgot where you were
(no problem) but you also forget what you have.
Or you must alwas "pass" data to subroutines beacse the data is not
remembered.
Total control
At each point, agter each word, you know in what overall state Forth
is in, and ytou can manipulate it.
For example. Instead of being carefull not to dusturb Forth by leaving
a number on betweeen [ and ] you can take cibtrik abd do everything
the compler would do, by hand. Note that you are supposed to undestand
, but the following is a means to compile tes by hand after IF
[ 'LIT >CFA , 1 , 'DOT >CFA , BACK ' S; >CFA , HIDDEN

-------------------------------------------------------------
FOR i FROM 0 TO 1 BY -1 DO ... WHILE ... OD
init : initialise start to 1,increment to 1, end to infirinity
cond to TRUE .
remember last index name and discard it.
FOR init
   make init the new index name

FROM
   if FOR-ed init set start to stack ahead
TO if FROM init
   set end to infinity

BY if started init
   set increment to ahead
      if end and increment differ in sign, end*=-1

while  compile noheader stuff

-------------------------------------------------------------
NSR
NSS
NSI
NSO
replicators
jugglers
anihilators
commutative
associative

A Folding
B Reordering
c Inlining
D Loop/Recursion optimisation

A
 NSR+NSS+NSI+NSO inc combination with constant input.
 Specials:
    0BRANCH EXECUTE i.c.w. constant input.
    NSO ic.w. NIP DROP
    Duplicators (e.g. DUP >R ) i.c.w. constant input
    Asociative operation ( + ) i.c.w. constant input and same
    operation

B SWAP/ROT sequences instead of results for NS .
   Commutative op's SWAP constants to top

C for NSR in line the code to a maximum of 1 K

D Loop optimizing
 1 A DO LOOP innermost is entitled to a reigster for I
 2. An intermost loop is entitled to 1K : .5 foldable,
 3. An intermost loop is entitled to 1K : .5 not foldable
 4 A recursion is entitled to registers for its inputs
 5. A recursion is entitled to 1K
 6 A loop is entitled to registers for the stack items accessed from
 the loop.

Optmise
    optimise constituents
    Fold reorder fold inline fold
    expand loop
    fold
    - - - - - -
    generate code for non-primary constituents
    generate code.


Note ad RECURSION
   Try to reorder to get like recursion together. That is really
   a bug win.
        DUP RECURSE >R RECURSE
    becomes
        DUP RECURSE DUP >R
-------------------------------------------------------------
Steps :
*1. Decompile code definitions by instruction
*2. For each pop add 1 to POPS
*3. For each push add 1 to PUSHES
4. Replace each by 0E if  variable stack effect
*4. Combine into one byte
*5. Add $11
* 6. Fill in

-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
