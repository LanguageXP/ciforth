@section Concepts

A forth user is well aware of how the memory of his 
computer is organised. He allocates it for certain purposes,
and frees it again at will.

The forthdefi({dictionary}) is the part of the memory where the forthcode({words}) are
(forthpxref({DICTIONARY})).
It owns a part of the dictionary, starting with its name and
ending where the name of the next word starts.
This structure is called a forthdefi({dictionary entry}) .
A word can be executed by typing its name. 
Each word in the dictionary belongs to precisely one forthdefi({vocabulary}) .
Apart from the name a word contains data and executable code,
(interpreted or not) and linking information 
(forthpxref({VOCABULARY}).

A word that generates a new entry in the dictionary is called a 
forthdefi({defining word}) forthxref({DEFINING}).
The new word is created in the forthcode({CURRENT}) vocabulary.

Each processor has a natural size for the information. (This is
sometimes called a machine word). For an Pentium processor this is 
32 bit, for the older Intel 8086 it is 16 bit.
The pendant in Forth is called a forthdefi({cell}) and its size
may deviate from the processor you are running on.
For this ciforth it is _BITS_,
It applies to the data remembered in the data stack, and the 
return addresses on the return stack.
memory accesses forthcode({@@}) and forthcode({!}) , the size of forthcode({VARIABLE})' s
and forthcode({CONSTANT})' s.
In Forth a cell has no hair. It is interpreted by you as a
signed integer, a bit-map, a memory address or an unsigned number.
The operator forthcode({+}) can be used to add numbers, to set a bit in 
a bitmap or advance a pointer a couple of bytes.
In accordance with this there are no errors such as overflow given.   

Sometimes we use data of two cells, a forthdefi({double}) .
The high-order cell are most accessable on the stack and if stored in 
memory, it is highest.

A so called high level word, one defined by forthcode({:}) , is just a 
sequence of addresses of other words. The forthdefi({inner interpreter})
takes care to execute these words in sequence.
It acts by fetching the address pointed by forthvar({IP}) , storing
this value in register forthvar({W}) . It then jumps to the address
pointed to by the address pointed to by forthvar({W}) . forthvar({W})
points to the code field of a definition which contains the address of
the code which executes for that definition. This usage of indirect
threaded code is a major contributor to the power, portability, and
extensibility of Forth. 

@section Portability
If you build your words from the words defined in the ISO standard,
and are otherwise careful, your programs may run on other systems that
are ISO standard. 

Here we will explain how you must read the glossary of ciforth,
in relation to terminology in the ISO standard.

Whenever the glossary specifies under which conditions a word ``may
crash'', then you will see the euphemism ``ambiguous condition'' in
the ISO standard. 

For example: 
forthbreak
If forthcodeni({HOLD}) is used not between 
forthcodeni({<#}) and forthcodeni({#>}) ciforth may crash.

Whenever we explicitly mention ciforth in a sentence that appears
in a glossary entry,
the behaviour may not apply to other ISO standard systems.
This is called forthdefi({ciforth specific behaviour})
If it mentions ``this ciforth'', you cannot even trust that
behaviour to be the same on other ciforth systems.
Often this is called an ``implementation defined'' behaviour in the standard.
Indeed we are obliged to specifiy this behaviour in our glossary,
or we don't comply to the standard. 
The behaviour of the other system may very well be a crash.
In that case the standard probably defines this an ``ambigous condition''.

For example: 
forthbreak
On this ciforth forthcodeni({OUT}) is set to zero whenever forthcodeni({CR}) is executed.

The bottom line is that you never want to write code where 
ciforth may crash. 
And that if you want your code to run on some other system,
you do not want to rely on forthdefi({ciforth specific behaviour}). 
If you couldn't get around that, 
you must keep the specific code separate. 
That part has to be checked carefully against the documentation
of any other system, 
where you want your code to run on.
@section Saving a new system

In combination with the change of the boot-up parameters at
forthcode({+ORIGIN}) this allows to make a turnkey system.
The procedure for saving the system.

In the following we use the naming convention of ISO about cells.
A cell is the fundamental unit of storage for the Forth engine.
Here it is _BITS_ bits (_BITS16_(2)_BITS32_(4) bytes).

Save the system as follows.
forthenumerate
forthitem
All user variables are saved by copying them from forthcode({U0})
to forthsamp({0 +ORIGIN}) 
 forthcode({U0}) is a user variable pointing to the start of the user area.
forthitem
If all user variables are to be initialised to what they are in this live system
skip to step 5.
Adjust any variables to what you want them to be in the 
saved system in the forthcode({+ORIGIN}) area.
The initialisation for user variable forthvar({Q}) can be found at 
    forthsamp({' Q @ +ORIGIN}).
forthitem
Adjust forthcode({VOCLINK}) (the 10-th user variable, so at forthvar({10 CELLS +ORIGIN})  )
forthitem
Adjust version information at 2 cells before forthcode({+ORIGIN}) (if needed)
forthitem
Copy from X to HERE to disk or where ever you want to restore 
from. _HOSTED_({In this ciforth you can do this 
By changing the current block file to the program file (using forthcode({BLOCK-EXIT}) and 
 forthcode({BLOCK-INIT}) )
and performing raw writes (using forthcode({R/W}) ), then switching back to your 
original block file. })
forthendenumerate

@section Memory organization

A running ciforth has 3 distinct memory areas. 

They occur sequentially from low memory to high. 
forthitemize
forthitem
The dictionary, 
forthitem
Memory, available for dictionary and stacks.
Its lowest part is used as a scratch area
forthitem
Stacks{}_HIGH_BUF_({, disk block buffers}) and terminal
input buffer. 
forthitem
forthenditemize

_LOW_BUF_({The disk block buffers are allocated in the dictionary,
because otherwise they would not be accessable to the BIOS})

The program as residing on disk may contain startup code, but that is
of no concern for the usage. 

The dictionary area is the only part that is initialised,
the other parts are just allocated.
Logically the Forth system consists of these 7 parts.
forthitemize forthbullet
forthitem
Boot-up parameters 
forthitem
Machine code definitions 
forthitem
Installation dependant code
forthitem
High level standard definitions
forthitem
High level user definitions 
forthitem
System tools (optional)
forthitem
RAM memory workspace 
forthenditemize

@subsection Boot-up Parameters

The boot-up area contains initial 
values for the registers needed for the Forth engine, 
like stack pointers, the pointers to the special memory area's, 
and the very important dictionary pointer forthcode({DP}) 
that determines the boundary between the dictionary and free space.

Instead they are copied to a separate area the forthdefi({user area}) ,
each time a Forth task, or Forth itself, is started.
The bootup area itself is not changed, but the variables in this area are.
By having several user area's, and switching between them,
ciforth can support multitasking.
When you have made extensions to your system, like for instance you
have loaded an editor, you can make these permanent by updating the
initial vvalues in the boot-area and saving the result to disk as an
executable program. 
The boot-area extends from forthcode({+ORIGIN}) 0100H bytes
upward. This is the image for the forthdefi({user area}).
It also extends 4 CELLS downwards, containing machine code for two 
jumps, to the warm and the cold start, ans a version number.
So in ciforth the bootup parameters are more or less the data field of the
+ORIGIN word. 
Executing +ORIGIN leaves a pointer in this area but after the jump vectors
and the release numbers. 

@subsection                     Installation Dependent Code

forthcode({KEY}) forthcode({EMIT}) forthcode({?TERMINAL}) forthcode({CR}) and 
forthcode({R/W}) are indeed different for different I/O models.
This is of little concern to you as a user, 
because these are perfectly normal dictionary entries. 
There will however be more differences between the different configurations for 
ciforth for these words than habitually.

@subsection                      Machine Code Definitions

The machine executable code definitions
play an important role because they
convert your computer into a standard Forth stack computer. 
It is clear that although you can define words by other words,
you will hit a lowest level.
The code words as these lowest level programs are called,
execute machine code directly, if you invoke them from 
the terminal or from some other definition.
The other definitions, called forthdefi({high level}) code, 
consist of a
sequence
of the machine executable code words. 
The Forth forthdefi({inner interpreter}) takes care that 
these code words are executed in turn.

In the assembler source (if you care to look at it)
you will see that they are interspersed with the 
high level Forth definitions. 
In fact it is quite common to decide to rewrite a code definition in high level
Forth, or the other way around.

Again code words are perfectly normal dictionary entries. 
@subsection                      High-level Standard Definitions

The high level standard definitions add all 
the colon-definitions, user variables, constants, and variables that
must be available in a 
"Forth stack computer" according to the ISO standard. 
They comprise the bulk of
the system, enabling you to execute and compile from the terminal,
execute and add definitions 
by forthdefi({loading}) code from disk etc.
Deviations from standards are ill advised, 
so you probably want to leave this area alone.
Again these words are perfectly normal dictionary entries. 
_VERBOSE_({The technique described for the next section, 
forget and recompile,
is not always possible here because of circular references.
That is in fact no problem with an assembler listing, 
but it is if you load Forth code.})

Again standard definitions words are perfectly normal dictionary entries. 
@subsection                    user definitions

The user definitions 
contain primarily definitions involving user interaction:
compiling aids, finding, forgetting, listing, and number formating. 
Some of these are fixed by the ISO standard too.
These definitions are placed above the standard definitions to
facilitate modification. 
That is you may forthcode({FORGET}) part of
the high-level and re-compile altered definitions from disc. 
This applies even to the ISO standard words.
Again these words are perfectly normal dictionary entries. 
Before long we plan to have these definitions added to the 
system exclusively by loading from disk.

Again user definitions words are perfectly normal dictionary entries. 
@subsection                    System Tools

A text editor and machine code assembler are the first tools 
normally available. 
They are not part of ciforth as delivered,
but they are among the first candidates to be integrated into 
your system. 
Please note how the boundary 
_PC_({ We are
including a sample editor, that is quite handy})
_LINUX_({Development in Linux uses the there available editors.
Code is tested by piping it into Forth, then commanding Forth to
look to the console, as follows :
forthbreak
forthsamp({(echo 8 LOAD; cat pascal.frt - )| ciforth })
forthbreak
Primitive and preliminary as this may seem, 
it has been used for quite substantial developments like the 
80386 assembler.})
386 and a 8086 
Forth assemblers are available in forthfile({BLOCKS.BLK}) .
They are loaded in accordance with the system that is run.

It is essential that you regard ciforth as just a way to get started
with Forth. 
Forth is an extensible language, and you can set it to your hand.
But that also means that you must not hesitate to throw
away parts of the system you don't like, and rebuilt them
even in conflict with standards. 
_VERBOSE_(
{Additions and changes must be planned and
tested at the usual Forth high level.
Later you can rewrite them as code words.})

Again words belonging to tools are perfectly normal dictionary entries. 
@subsection                    RAM Workspace
The RAM workspace contains the compilation space for the dictionary,
_HIGH_BUF_(disc buffers,}) the computation and return stacks, the user area,
and the terminal input buffer, 
_VERBOSE_({From the figforthuser manual
forthquotation
For a single user system, at least 2k bytes must be available above the
compiled system (the dictionary). A 16k byte total system is most typical. 
forthendquotation})
It is indeed possible to do useful work, 
like factoring numbers of a few hundred digits, in a workspace of 2k bytes.
More typical a workspace is several megabytes to over hundred megabytes.

_BITS16_({There is no longer a reason to put up with a 16-bit system less than 64K.})
_BITS32_({32 bits system are set at 64Mbyte but this is arbitrary and could be set much
higher or lower without consequences for system load or whatever. 
Before long we will put the dictionary space on I86-Linux to 4G minus
something and forget about this issue forver. })

_VERBOSE_(
{The boundary between this area and the previous one is pretty sharp, 
it is where forthcode({DP}) points.
The other areas are not clearly separated at all.
But even this boundary constantly changes as you add and forget definitions.})
@subsection                    crap
Underneath the I/O model has improved. TYPE and EXPECT are drawn into
the I/O model dependant part. If at all possible CR and EMIT used TYPE
such that TYPE becomes a natural vectoring point. Similarly KEY 
tries to use EXPECT, but mostly this is not possible because EXPECT doesnot
return before the user hits the Enter key.

@section         fig-FORTH VARIABLE NAME FIELD

A major FIG innovation in this model, is the introduction of variable length
definition names in compiled dictionary entries. 
Previous methods only saved three letters and the character count.

The user may select the letter count saved, up to the full natural length.
See the glossary definition for WIDTH. 


In this model, the following conventions have been established.

forthenumerate
forthitem
The first byte of the name field has the natural character count in the
low 5 bits. 
forthitem
The sixth bit = 1 when smudged, and will prevent a match by (FIND). 
forthitem
The seventh bit = 1 for IMMEDIATE definitions; it is called the
precedence bit. 
forthitem
The eighth or sign bit is always = 1. 
forthitem
The following bytes contain the names' letters, up to the value in WIDTH. 
forthitem
In the byte containing the last letter saved, the sign bit = 1. 
forthitem
In word addressing computer, a name may be padded with a blank to a word
boundary. 
forthendenumerate

The above methods are implemented in CREATE.
Remember that -FIND uses BL WORD to bring the next text to HERE with the
count preceeding. All that is necessary, is to limit by WIDTH and toggle the
proper delimiting bits. 

They were very proud at the time that names could be any length.
They felt obliged however to introduce the WIDTH/TRAVERSE to allow 
upwards compatibility with systems that stored only the first few (three)
characters of a word. This has become a major pain now. See the screens
for the $____ and $__ words that are absolutely unportable.


@section  MEMORY MAP         

The following memory map is broadly used. 
Specific installations may require alterations but you may forfeit functions
in future FIG offerings. 

The disc buffer area is at the upper bound of RAM memory. It is comprised of
an integral number of buffers, each B/BUF+4 bytes. 
B/BUF is the number of bytes read from the disc, usually one sector. B/BUF
must be a power of two (64, 128, 256, 512 or 1024). 
The constant FIRST has the value of the address of the start of the first
buffer. 
LIMIT has the value of the first address beyond the top buffer. The distance
between FIRST and LIMIT must be N*(B/BUF+4) bytes. 
This N must be two or more. 

I set the number of disk buffers at 2, the minimum possible. Even a floppy
is fast enough that working with blocks from memory has no merits. It is
dangerous because during testing you never know what was saved and what not.
The mass storage is easily the most crappy part of the fig model. What
little advantage it had, is no longer applicable. Interestingly this block
system is copied verbatim into ANS. 
32 bits systems can enlarge the dictionary by redefining the stacks and the
terminal input buffer positions. The block buffers are in the way. So I put
them in the dictionary space. In fact the block buffers have become the 
data field of FIRST.

Constant B/SCR has the value of the number of buffers per screen; 
i.e. 1024 / B/BUF. 

The user area must be at least 34 bytes; 48 is more appropriate. In a 
multi-user system, each user has his own user area, for his copy of system 
variables. This method allows reentrant use of the Forth vocabulary. 

The terminal input buffer is decimal 80 bytes (the hex 50 in QUERY) plus 2
at the end. If a different value is desired, change the limit in QUERY. A
parameter in the boot-up literals locates the address of this area for TIB.
The backspace character is also in the boot-up origin parameters. It is
universally expected that "rubout" is the backspace. 

The return stack grows downward from the user area toward the terminal
buffer. Forty-eight bytes are sufficient. The origin is in R0 (R-zero) and
is loaded from a boot-up literal. 

The computation stack grows downward from the terminal buffer toward the
dictionary which grows upward. The origin of the stack is is in variable S0
(S-zero) and is loaded from a boot-up literal. 

After a cold start, the user variables contain the addresses of the above
memory assignments. 
An advanced user may relocate while the system is running. A newcomer should
alter the startup literals and execute COLD. The word +ORIGIN is provided
for this purpose. +ORIGIN gives the address byte or word relative to the
origin depending on the computer addressing method. 

Despite all the talk about user variables, I am not aware that a multi-user
fig forth existed, ever. The above block policy is not compatible with 
multi-user (but the actual code is not worse than it ever was, and you can
rebuilt it with 1000 block buffers if you like.)

Rubout is best left to the EXPECT code. Remember, a Linux itself knows the
rubout key for any of its 500+ known terminal types and isn't it nice in
MSDOS that F3 gets the previous command back for you? 
If EXPECT builds up a line from separate key strokes, and if you ever want
to change the rubout key, just change the RUBOUT user variable. 


CUSTOMISING

The name USER reflects that more than one user could use the dictionary
and users could share the background storage, provided certain precautions
are taken. About this you can forget.
What you can do is, store back you user variables in the boot-up 
parameters as follows
forthsamp({USVA @   ' USVA @   +ORIGIN !})
where forthvar({USVA}) is the user variable which value you want to keep.

