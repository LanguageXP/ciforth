@section Concepts

A forth user is well aware of how the memory of his
computer is organised. He allocates it for certain purposes,
and frees it again at will.

The last-in first-out buffer that remembers data for us is called
the forthdefi({data stack}) or sometimes forthdefi({computation stack}).
There are other stacks around,
but if there is no confusion it is often called just the forthdefi({stack}).
Every stack is in fact a buffer and needs also a forthdefi({stack pointer})dnl
to keep track of how far it has been filled.
It is just the address where the last data item has been stored in the buffer.

The forthdefi({dictionary}) is the part of the memory where the forthcode({words}) are
(forthpxref({DICTIONARY})).
It owns a part of the dictionary, starting with its name and
ending where the name of the next word starts.
This structure is called a forthdefi({dictionary entry}).
A word can be executed by typing its name.
Each word in the dictionary belongs to precisely one forthdefi({word list}),
or as we will say here vocabulary.
Apart from the name a word contains data and executable code,
(interpreted or not) and linking information
forthpxref({VOCABULARY}).

The concept word list is part of the ISO standard, but we will
use forthdefi({vocabulary}) . A vocabulary is much more
convenient, being a word list with a name, created by
forthcode({VOCABULARY}) . ISO merely knows
forthdefi({word list identification}) 's, a kind of handle,
abbreviated as forthdefi({WID}) . A new word list is
initiated by the use of forthcode({VOCABULARY}), and if
you know the name you know the forthdefi({WID}) .

A word that is defined using forthcode({:}) is often called a
forthdefi({colon definition}). Its code is called
forthdefi({high level}) code.

A high level word, one defined by forthcode({:}) , is just a
sequence of addresses of other words. The forthdefi({inner interpreter})dnl
takes care to execute these words in sequence.
It acts by fetching the address pointed by forthvar({IP}) , storing
this value in register forthvar({W}) . It then jumps to the address
pointed to by the address pointed to by forthvar({W}) . forthvar({W}) dnl
points to the code field of a definition which contains the address of
the code which executes for that definition. This usage of indirect
threaded code is a major contributor to the power, portability, and
extensibility of Forth.

If the inner interpreter must execute another high level word,
while it is interpreting, it must remember the old value of
forthvar({IP}), and this so called forthdefi({nesting}) could go several
levels deep.
Keeping this on the data stack would interfere with the data the
words are expecting, so they are kept on a separate stack, the
forthdefi({return stack}).
The usage of two stacks is another hall mark of Forth.

A word that generates a new entry in the dictionary is called a
forthdefi({defining word}) forthxref({DEFINING}).
The new word is created in the forthcode({CURRENT}) word list .

Each processor has a natural size for the information. (This is
sometimes called a machine word). For an Pentium processor this is
32 bit, for the older Intel 8086 it is 16 bit.
The pendant in Forth is called a forthdefi({cell}) and its size
may deviate from the processor you are running on.
For this ciforth it is _BITS_,
It applies to the data remembered in the data stack, the
return addresses on the return stack,
memory accesses forthcode({@@}) and forthcode({!}) , the size of forthcode({VARIABLE})' s
and forthcode({CONSTANT})' s.
In Forth a cell has no hair. It is interpreted by you as a
signed integer, a bit-map, a memory address or an unsigned number.
The operator forthcode({+}) can be used to add numbers, to set a bit in
a bitmap or advance a pointer a couple of bytes.
In accordance with this there are no errors such as overflow given.

Sometimes we use data of two cells, a forthdefi({double}) .
The high-order cell are most accessable on the stack and if stored in
memory, it is highest.

The code for a high level word can be typed in from the terminal,
but it can also fed into Forth by redirection from a file, or
you can forthdefi({load}) it from the file forthfile({BLOCKS.BLK}) .
This file is divided into forthdefi({screen})'s , consisting of
16 lines of 64 characters.
To forthdefi({load}) such a screen has the same effect as
typing its content from the terminal.

Traditionnally Forthers have things called
forthdefi({number})'s, words that are present in the source be
it interpreted or compiled, and are thought of not as being
executed but rather being a description of something to be put
on the stack directly. In early implementations the word forthsamp({NUMBER})
was a catch-all for anything not found in the dictionary, and
could be adapted to the application.
For such an extensible language as
Forth, and in particular where strings and floating point
numbers play an increasing role, numbers must be generalised to
the concept of forthdefi({denotation})'s and the need of a way
that catch those is as present as it was in those early days.
Denotations put a
constant object on the stack without the need to define it
first. Naturally they look, and in fact are, the same in both
modes. Here we adopt a practice of selecting a type of the denotations
based on the first letter. This is quite practical and familiar.
Examples of this are (some from C, some from assemblers, some
from this Forth) :
forthexample({10
'a'
^A
0DEAD
$8000403A
#3487
0177
"Arpeggio"
"JAMES BROWN IS DEAD"
" JK "
' DROP})
These examples demonstrate
that a denotation may contain spaces, and still are easy to scan.
And yes, I insist that forthsamp({' DROP}) is a denotation.
Of course a sensible programmer will not define a word that looks like
a denotation :
forthexample({ : 7 CR "This must be my lucky day" TYPE ; ( DON'T DO THIS) })
@section Portability
If you build your words from the words defined in the ISO standard,
and are otherwise careful, your programs may run on other systems that
are ISO standard.

Here we will explain how you must read the glossary of ciforth,
in relation to terminology in the ISO standard.

Whenever the glossary specifies under which conditions a word may
``crash'', then you will see the euphemism ``ambiguous condition'' in
the ISO standard.

For example:
forthbreak
Using forthcodeni({HOLD}) other than between
forthcodeni({<#}) and forthcodeni({#>}) leads to a crash.

Whenever we explicitly mention ciforth in a sentence that appears
in a glossary entry,
the behaviour may not apply to other ISO standard systems.
This is called forthdefi({ciforth specific behaviour})
If it mentions ``this ciforth'', you cannot even trust that
behaviour to be the same on other ciforth systems.
Often this is called an ``implementation defined'' behaviour in the standard.
Indeed we are obliged to specifiy this behaviour in our glossary,
or we don't comply to the standard.
The behaviour of the other system may very well be a crash.
In that case the standard probably defines this an ``ambigous condition''.

For example:
forthbreak
On this ciforth forthcodeni({OUT}) is set to zero whenever forthcodeni({CR}) is executed.

The bottom line is that you never want to write code where
ciforth may crash.
And that if you want your code to run on some other system,
you do not want to rely on forthdefi({ciforth specific behaviour}).
If you couldn't get around that,
you must keep the specific code separate.
That part has to be checked carefully against the documentation
of any other system,
where you want your code to run on.

By using forthcode({CELL+}) it is easy to keep your code 16/32 bit clean.
This means that it runs on 16 and 32 bits systems.
@section Saving a new system
We have said it before: ``Programming Forth is extending the Forth language.''.
A facility to save your system after it has been extended is of the essential.
It can be argued that if you don't have that, you ain't have no Forth.
It is used for two purposes, that are in fact the same.
Make a customised Forth, like forthemph({you}) want to have it.
Make a customised environment, like a customer wants to have it.
Such a ``customised environment'', for example a game, is also
called a forthdefi({turnkey system}) .
It often hides the normal working of the underlying Forth.
Of course, whether you have a
hosted system _HOSTED_LINUX_(like this one) _HOSTED_MSDOS_(like this one) or
a booted system _BOOTED_(like this one), it is clear that some
system-dependant information goes into accomplishing this.

In the following we use the naming convention of ISO about cells.
A cell is the fundamental unit of storage for the Forth engine.
Here it is _BITS_ bits (_BITS16_(2)_BITS32_(4) bytes).

The change of the boot-up parameters at
forthcode({+ORIGIN}), in combination with storing an image on disk
goes a long way to extending the system.
This proceeds as follows:
forthenumerate
forthitem
All user variables are saved by copying them from forthsamp({U0 @@})
to forthsamp({0 +ORIGIN}).
The user variable forthcode({U0}) dnl
points to the start of the user area. The length of the area is hex 100.
If in doubt check out the variable forthvar({US}) in the assembler code.
forthitem
If all user variables are to be initialised to what they are in this live system
skip the next step.
forthitem
Adjust any variables to what you want them to be in the
saved system in the forthcode({+ORIGIN}) area.
The initialisation for user variable forthvar({Q}) can be found at
    forthsamp({' Q >DFA @@ +ORIGIN}).
forthitem
Adjust
version information at 2 cells before forthcode({+ORIGIN}) (if needed)
forthitem
Copy your ciforth to a new file. Modify the header in that file
and overwrite the ciforth in that file,
after the header, by the area
from forthcode({BM}) to forthcode({HERE}).
forthendenumerate

_LINUX_N_({In this ciforth you can do this by the forthcode({SAVE-SYSTEM}) of block 146.
It changes the current block file to the program file (using forthcode({BLOCK-EXIT}) and
 forthcode({BLOCK-INIT}) )
and performing raw writes (using forthcode({LINOS}) ),
then switching back to your original block file. })

@section Memory organization

A running ciforth has 3 distinct memory areas.

They occur sequentially from low memory to high.
forthitemize
forthitem
The dictionary,
forthitem
Free memory, available for dictionary, from below, and stacks, from above.
Its lowest part is used as a scratch area
forthitem
Stacks{}_HIGH_BUF_({, disk block buffers}) and terminal
input buffer.
forthenditemize

_LOW_BUF_({The disk block buffers are allocated in the dictionary,
because otherwise they would not be accessable to the BIOS})

The program as residing on disk may contain startup code, but that is
of no concern for the usage.

The dictionary area is the only part that is initialised,
the other parts are just allocated.
Logically the Forth system consists of these 7 parts.
forthitemize
forthitem
Boot-up parameters
forthitem
Machine code definitions
forthitem
Installation dependant code
forthitem
High level standard definitions
forthitem
High level user definitions
forthitem
System tools (optional)
forthitem
RAM memory workspace
forthenditemize

@subsection Boot-up Parameters

The boot-up area contains initial
values for the registers needed for the Forth engine,
like stack pointers, the pointers to the special memory area's,
and the very important dictionary pointer forthcode({DP})dnl
that determines the boundary between the dictionary and free space.

Instead they are copied to a separate area the forthdefi({user area}) ,
each time a Forth task, or Forth itself, is started.
The bootup area itself is not changed, but the variables in the user
area are.
By having several user area's, and switching between them,
ciforth can support multitasking.
When you have made extensions to your system, like for instance you
have loaded an editor, you can make these permanent by updating the
initial values in the boot-area and saving the result to disk as an
executable program.
The boot-area extends from forthsamp({0 +ORIGIN}) 0100H bytes
upward. This is the image for the forthdefi({user area}).
It also extends 6 cells downwards, containing machine code for two
jumps, to the warm and the cold start, and a version number.
So in ciforth the bootup parameters are more or less the data field of the
forthcode({+ORIGIN}) word.
Executing forthcode({+ORIGIN}) leaves a pointer in this area but after the jump vectors
and the release numbers.

@subsection                     Installation Dependent Code

forthcode({KEY}) forthcode({EMIT}) forthcode({KEY?}) forthcode({CR}) and
forthcode({R/W}) are indeed different for different I/O models.
This is of little concern to you as a user,
because these are perfectly normal dictionary entries and the different
implementations serves to make them behave similarly.
There will however be more differences between the different configurations for
ciforth for these words than habitually.

@subsection                      Machine Code Definitions

The machine executable code definitions
play an important role because they
convert your computer into a standard Forth stack computer.
It is clear that although you can define words by other words,
you will hit a lowest level.
The forthdefi({code word})'s as these lowest level programs are called,
execute machine code directly, if you invoke them from
the terminal or from some other definition.
The other definitions, called forthdefi({high level}) code,
consist of a
sequence
of the machine executable code words.
The Forth forthdefi({inner interpreter}) takes care that
these code words are executed in turn.

In the assembler source (if you care to look at it)
you will see that they are interspersed with the
high level Forth definitions.
In fact it is quite common to decide to rewrite a code definition in high level
Forth, or the other way around.

Again code words are perfectly normal dictionary entries.
@subsection                      High-level Standard Definitions

The high level standard definitions add all
the colon-definitions, user variables, constants, and variables that
must be available in a
"Forth stack computer" according to the ISO standard.
They comprise the bulk of
the system, enabling you to execute and compile from the terminal,
execute and
forthdefi({load}) code from disk to add definitions
etc.
Deviations from standards are ill advised,
so you probably want to leave this area alone.
Again these words are perfectly normal dictionary entries.
_VERBOSE_({The technique described for the next section,
forget and recompile,
is not always possible here because of circular references.
That is in fact no problem with an assembler listing,
but it is if you load Forth code.})

Again standard definitions words are perfectly normal dictionary entries.
@subsection                    User definitions

The user definitions
contain primarily definitions involving user interaction:
compiling aids, finding, forgetting, listing, and number formating.
Some of these are fixed by the ISO standard too.
These definitions are placed above the standard definitions to
facilitate modification.
That is you may forthcode({FORGET}) part of
the high-level and re-compile altered definitions from disc.
This applies even to the ISO standard words from the
forthvar({TOOLS}) wordset like forthcode({DUMP}) (show a memory area as
numbers and text) and forthcode({.S}) (show the data stack).

Again these words are perfectly normal dictionary entries.
_LOAD_({A number of entries that could easily be made loadable
are integrated in the assembler source of this ciforth version.})
You can forget them, and load your own version from files or blocks.

Again user definitions words are perfectly normal dictionary entries.
@subsection                    System Tools

The boundary between categories are vague. A system tools is
contrary to a user tool, a larger set of cooperating words.
A text editor and machine code assembler are the first tools
normally available.
An editor is
not part of ciforth as delivered, but an assembler is available via
screen 120. It automatically loads the proper _BITS_-bits version.
They are among the first candidates to be integrated into
your system by SAVE-SYSTEM .
_PC_({ We are including a sample editor, that is quite handy})
_HOSTED_LINUX_({An editor is not part of ciforth as delivered.
Development in Linux uses the there available editors.
Even without tools, code can be
tested by piping it into Forth, then commanding Forth to
look to the console, as follows :
forthbreak
forthsamp({(echo 8 LOAD; cat pascal.frt - )| ciforth })
forthbreak
Primitive and preliminary as this may seem,
it has been used for quite substantial developments like the
80386 assembler.
forthbreak
More advanced is using Your Favorite Editor, followed by
including files:
forthbreak
forthsamp({"vim mysrc.frt" SYSTEM})
forthbreak
forthsamp({"mysrc.frt" INCLUDED})
})

386 and a 8086
Forth assemblers are available in forthfile({BLOCKS.BLK}) .
They are loaded in accordance with the system that is run.

It is essential that you regard ciforth as just a way to get started
with Forth.
Forth is an extensible language, and you can set it to your hand.
But that also means that you must not hesitate to throw
away parts of the system you don't like, and rebuilt them
even in conflict with standards.
_VERBOSE_(
{Additions and changes must be planned and
tested at the usual Forth high level.
Later you can rewrite them as code words.})

Again words belonging to tools are perfectly normal dictionary entries.
@subsection                    RAM Workspace
The RAM workspace contains the compilation space for the dictionary,
_HIGH_BUF_({disc buffers,}) the computation and return stacks, the user area,
and the terminal input buffer,
_VERBOSE_({From the figforthuser manual
forthquotation
For a single user system, at least 2k bytes must be available above the
compiled system (the dictionary). A 16k byte total system is most typical.
forthendquotation})
It is indeed possible to do useful work,
like factoring numbers of a few hundred digits, in a workspace of 2k bytes.
More typical a workspace is several megabytes to over hundred megabytes.

_BITS16_({There is no longer a reason to put up with a 16-bit system less than 64K.})
_BITS32_({32 bits system are set at 64Mbyte but this is arbitrary and could be set much
higher or lower without consequences for system load or whatever.
Before long we will put the dictionary space on I86-Linux to 4G minus
something and forget about this issue forver. })

_VERBOSE_(
{The boundary between this area and the previous one is pretty sharp,
it is where forthcode({DP}) points.
The other areas are not clearly separated at all.
But even this boundary constantly changes as you add and forget definitions.})
@section Specific layouts
@subsection The layout of a dictionary entry

We will divide the dictionary in entries.
A forthdefi({dictionary entry}) is a part of the dictionary that
belongs to a specific word.
A forthdefi({dictionary entry address}), abbreviated
forthdefi({DEA}) is a pointer to a dictionary entry. In this
ciforth it is the lowest addres of the entry, where the code
field is.


A dictionary entry has fields, and the addresses of fields directly
offset from the dictionary entry address, are called
forthdefi({field address}). This is a bit strange terminology, but
it makes a distinction between those addresses and other addresses.
For example, this allows to make the distinction between a
forthdefi({data field address}), that is always present, and a
forthdefi({data field}) in the ISO sense that has only a
(differing) meaning for
forthcode({CREATE}) forthcode({DOES> }) definitions.
Typically, a field address contains a pointer. A
forthdefi({data field address}) contains a pointer to
near the forthdefi({data field}), whenever the latter exists.

They go from lowest in memory to highest:
forthenumerate
forthitem
The code field. This is one cell.
A pointer to such a field is called a forthdefi({code field address}) .
It contains the address of the code to be executed for this word.
forthitem
The data field, of the DEA, not in the ISO sense.
This is one cell.
A pointer to such a field is called a forthdefi({data field address}) .
It contains a pointer to an area owned by this definition.
forthitem
The flag field. This is one cell.
A pointer to such a field is called a forthdefi({flag field address}) .
For the meaning of the bits of the flag field sea below.
forthitem
The link field. This is one cell.
A pointer to such a field is called a forthdefi({link field address}) .
It contains the
dictionary entry address of the last word that was
defined in the same forthdefi({word list}) before this one.
forthitem
The name field. This is one cell.
This contains a pointer to a string.
A pointer to such a field is called a forthdefi({name field address}).
The name itself is stored at outside of the dictionary header
in a regular string, i.e. a one cell count followed by as many characters.
_VERBOSE_({Unfortunately, forthdefi({name field address}) is
often used, where a forthdefi({dictionary entry address}) would
be more correct, especially in older documentation, and this
usage may leak into this document. This came about because the
name was lowest in memory. That they happen to be the same is
no reason to confuse two completely different concepts. In this
Forth the code field address and the dictionary address are the
same, but not accidentally so. })
forthitem
Past the header . This is actually not a field, but the
free roaming dictionary. However, most of the time the part of
the dictionary space owned by a dictionary entry starts here. A
pointer to such a field is called a forthdefi({post header
address}) .
Mostly a forthdefi({data field address}) contains a
pointer to just this address.
forthendenumerate

Note that the entries are not only in alphabetic order, they
are in order of essentiality. They are accessed by
forthcode({>CFA}) forthcode({>DFA}) forthcode({>FFA})
forthcode({>LFA}) forthcode({>NFA}) forthcode({>PHA}) .

Note forthdefi({data field}) has a specific meaning in the ISO
standard. It is accessed through forthcode({>BODY}) from the
forthdefi({execution token}) while a data field address is
accessed through forthcode({>DFA}) from the
forthdefi({dictionary entry address}). It is in fact one cell
behind the forthdefi({past header address}).

The most important flag bits currently defined are:
forthitemize
forthitem
The INVISIBLE bit = 1 when forthdefi({smudge})d, and will prevent a
match by forthcode({(FIND)}).
forthitem
The IMMEDIATE bit = 1 for IMMEDIATE definitions; it is called the
 forthdefi({immediate bit}).
forthitem
The DUMMY bit =1 for a dictionary header contained in the
data of a vocabulary. This indicates that it shoudl not be executed.
forthitem
The DENOTATION bit =1 for a word from the DENOTATION word list.
This means that it is a one letter word, that can parse
all forthdefi({denotation})'s (numbers) that start with that letter, e.g. 0 .
_ALIGNED_(
{forthitem
After the last letter follow zero bytes uptill the next cell boundary.})
forthenditemize
forthcode({(CREATE)}) takes care to generate this data structure;
it is called by all defining words.

For all forthdefi({colon definition}) the code field contains
a pointer to the same code, the forthdefi({inner interpreter}), called
forthsamp({DOCOL}).
For all word defined via forthsamp({CREATE ... DOES>}) the code field
contains the same code, forthsamp({DODOES}).

At the forthdefi({data field address}) we find a pointer to an area with a
length and content that depends on the type of the word.
forthitemize
forthitem
For a code word, it contains machine code.
The code field of this word points to it too.
forthitem
For a word defined by
forthcode({VARIABLE}), forthcode({USER}), or forthcode({CONSTANT}) dq
it has a width of one cell, and contains data.
forthitem
For all forthdefi({colon definition}) the data field address
contains a pointer to an area variable length and contains the
compiled high level code, a sequence of forthdefi({code field
address})es.
forthitem
For a word defined via forthsamp({CREATE ... DOES>}) the first
cell of this area contains a pointer to the forthdefi({high
level}) code defined by forthcode({DOES>}) and the remainder is
data. A pointer to the data is passed to this
forthcode({DOES>}) code.
forthenditemize

A forthdefi({dictionary entry address}) can be turned into any
of these fields by words that are in the vocabulary
forthsamp({DICTIONARY}) . forthxref({DICTIONARY}). They
customaryly start with > .

A dictionary falls apart into the
forthenumerate
forthitem
Headers, with their fields.
forthitem
Names, pointed to by some forthdefi({name field address}) .
forthitem
Data, pointed to by some forthdefi({data field address}) .
This includes high level code, that is merely data fed into
the high level interpreter.
forthitem
Code, pointed to by some forthdefi({code field address}) .
This is directly executable machine code.
forthendenumerate
@subsection Details of memory layout

The disc buffers are mainly needed for source code that is fetched
from disk were it resides in a file.
_HIGH_BUF_({
The disc buffer area is at the upper bound of RAM memory, So it ends at forthcode({EM}) . })
_LOW_BUF_({
The disc buffer area is in fact the data area owned by forthcode({FIRST}). })
It is comprised of
an integral number of buffers, each forthcode({B/BUF}) bytes plus two cells.
forthcode({B/BUF}) is the number of bytes read from the disc in one go{}_VERBOSE_({,
originally thought of as one sector}).
In ciforth forthcode({B/BUF}) is always the size of one screen according to ISO :
1024 bytes.
The constant forthcode({FIRST}) has the value of the address of the start of the first
buffer.
 forthcode({LIMIT}) has the value of the first address beyond the top buffer.
The distance between forthcode({FIRST}) and forthcode({LIMIT}) is a multiple of
forthcode({B/BUF CELL+ CELL+}) bytes.

I set the number of disk buffers at 8, the minimum possible.
_VERBOSE_(
{Even a floppy
is fast enough that working with blocks from memory has no merits.
It is
dangerous because during testing you never know what was saved and what not.})

The user area is 100H bytes, most of it unused. There is no
word to add user variables.
_HIGH_BUF_({ The user area is just under the disc
buffers. So it ends at forthcode({FIRST}) . }) _LOW_BUF_({ The
user area is at the upper bound of RAM memory. So it ends at
forthcode({EM}) . })

The terminal input buffer  and the return stack share an area of
_BITS16_(0A0H)_BITS32_(010000H) bytes.
The lower half is intended for the terminal input buffer, and the higher part
is used for the return stack, growing down from the end.
The initial stackpointer is in variable forthcode({R0}).
The return stack grows downward from the user area toward the terminal
buffer.

The computation stack grows downward from the terminal buffer toward the
dictionary which grows upward.
The initial stackpointer is in variable forthcode({S0}).

During a cold start, the user variables are initialised from the bootup parameters
to contain the addresses of the above memory assignments.
_VERBOSE_({
They can be changed.
The safest way is to change the bootup parameters and
perform forthcode({COLD}). forthxref({+ORIGIN}).
But if you are careful you can change the system on the fly.})

_VERBOSE_( {If you need multi-tasking you have to allocate a
separate user area for each task, as well as a separate return
stack area and a separate data stack area. A task that asks for
input, also needs an extra terminal input buffer.})
@subsection  Terminal I/O and vectoring.
It is usefull to be able to change the behaviour of I/O words such
that they put their output to a different channel.
For instance they must output to the
printer instead of to the console.
In general this is called forthdefi({vectoring}).
Remember that in normal Forth system,
all printing of numbers is to the terminal,
not to a file or even a buffer.

_HOSTED_LINUX_({On a linux system the need for this is less,
because of the redirection facilities available.})
_HOSTED_MSDOS_({On a MSDOS system the need for this should be low,
because of the redirection facilities available.
However they are buggy.})
_BOOTED_({On a standalone system the need for this is high,
because there is no redirection.})
For this reason character output forthcode({CR}), forthcode({EMIT}) and
forthcode({TYPE}) all go through a common word that can be changed.
_LINUX_N_({For this ciforth it is forthcode({TYPE}) }).
Because this is defined in high level code it can temporarily be replaced
by other code.
As an example we replace forthcode({TYPE}) by forthcode({MYTYPE}) .
forthbreak
forthsamp({' MYTYPE >DFA @ ' TYPE >DFA !})
forthbreak
And back to default:
forthbreak
forthsamp({' TYPE >PHA ' TYPE >DFA !})
Be careful not to define forthcode({MYTYPE}) in terms of forthcode({TYPE}) , as a
recursive tangle will result.
This method works in all versions of ciforth an is called forthdefi({revectoring}) .

A similar technique is not so useful on the input side,
because keys entered during EXPECT are subject to correction
until <RET> has been pressed.
_HOSTED_LINUX_({On this linux ciforth forthcode({EXPECT}) is left to the
operating system, such that inputting to ciforth has the same
look and feel as other input.
Text can be pasted in with the mouse, etc.
Consequently forthcode({RUBOUT}) is not used.
}).
