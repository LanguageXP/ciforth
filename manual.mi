@section Concepts

A forth user is well aware of how the memory of his 
computer is organised. He allocates it for certain purposes,
and frees it again at will.

The forthdefi({dictionary}) is the part of the memory where the forthcode({words}) are
(forthpxref({DICTIONARY})).
It owns a part of the dictionary, starting with its name and
ending where the name of the next word starts.
This structure is called a forthdefi({dictionary entry}) .
A word can be executed by typing its name. 
Each word in the dictionary belongs to precisely one forthdefi({vocabulary}) .
Apart from the name a word contains data and executable code,
(interpreted or not) and linking information 
(forthpxref({VOCABULARY}).

A word that is defined using forthcode({:}) is often called a
forthdefi({colon definition}) . Its code is called 
forthdefi({high level}) code.

A word that generates a new entry in the dictionary is called a 
forthdefi({defining word}) forthxref({DEFINING}).
The new word is created in the forthcode({CURRENT}) vocabulary.

Each processor has a natural size for the information. (This is
sometimes called a machine word). For an Pentium processor this is 
32 bit, for the older Intel 8086 it is 16 bit.
The pendant in Forth is called a forthdefi({cell}) and its size
may deviate from the processor you are running on.
For this ciforth it is _BITS_,
It applies to the data remembered in the data stack, and the 
return addresses on the return stack.
memory accesses forthcode({@@}) and forthcode({!}) , the size of forthcode({VARIABLE})' s
and forthcode({CONSTANT})' s.
In Forth a cell has no hair. It is interpreted by you as a
signed integer, a bit-map, a memory address or an unsigned number.
The operator forthcode({+}) can be used to add numbers, to set a bit in 
a bitmap or advance a pointer a couple of bytes.
In accordance with this there are no errors such as overflow given.   

Sometimes we use data of two cells, a forthdefi({double}) .
The high-order cell are most accessable on the stack and if stored in 
memory, it is highest.

A so called high level word, one defined by forthcode({:}) , is just a 
sequence of addresses of other words. The forthdefi({inner interpreter})dnl
takes care to execute these words in sequence.
It acts by fetching the address pointed by forthvar({IP}) , storing
this value in register forthvar({W}) . It then jumps to the address
pointed to by the address pointed to by forthvar({W}) . forthvar({W}) dnl
points to the code field of a definition which contains the address of
the code which executes for that definition. This usage of indirect
threaded code is a major contributor to the power, portability, and
extensibility of Forth. 

@section Portability
If you build your words from the words defined in the ISO standard,
and are otherwise careful, your programs may run on other systems that
are ISO standard. 

Here we will explain how you must read the glossary of ciforth,
in relation to terminology in the ISO standard.

Whenever the glossary specifies under which conditions a word may
``crash'', then you will see the euphemism ``ambiguous condition'' in
the ISO standard. 

For example: 
forthbreak
Using forthcodeni({HOLD}) other than between 
forthcodeni({<#}) and forthcodeni({#>}) leads to a crash.

Whenever we explicitly mention ciforth in a sentence that appears
in a glossary entry,
the behaviour may not apply to other ISO standard systems.
This is called forthdefi({ciforth specific behaviour})
If it mentions ``this ciforth'', you cannot even trust that
behaviour to be the same on other ciforth systems.
Often this is called an ``implementation defined'' behaviour in the standard.
Indeed we are obliged to specifiy this behaviour in our glossary,
or we don't comply to the standard. 
The behaviour of the other system may very well be a crash.
In that case the standard probably defines this an ``ambigous condition''.

For example: 
forthbreak
On this ciforth forthcodeni({OUT}) is set to zero whenever forthcodeni({CR}) is executed.

The bottom line is that you never want to write code where 
ciforth may crash. 
And that if you want your code to run on some other system,
you do not want to rely on forthdefi({ciforth specific behaviour}). 
If you couldn't get around that, 
you must keep the specific code separate. 
That part has to be checked carefully against the documentation
of any other system, 
where you want your code to run on.

By using forthcode({CELL+}) it is easy to keep your code 16/32 bit clean.
This means that it runs on 16 and 32 bits systems.
@section Saving a new system

In combination with the change of the boot-up parameters at
forthcode({+ORIGIN}) this allows to make a turnkey system.
The procedure for saving the system.

In the following we use the naming convention of ISO about cells.
A cell is the fundamental unit of storage for the Forth engine.
Here it is _BITS_ bits (_BITS16_(2)_BITS32_(4) bytes).

Saving the system proceeds as follows:
forthenumerate
forthitem
All user variables are saved by copying them from forthsamp({U0 @@})
to forthsamp({0 +ORIGIN}). 
The user variable forthcode({U0}) dnl
points to the start of the user area.
forthitem
If all user variables are to be initialised to what they are in this live system
skip to step 5.
Adjust any variables to what you want them to be in the 
saved system in the forthcode({+ORIGIN}) area.
The initialisation for user variable forthvar({Q}) can be found at 
    forthsamp({' Q @ +ORIGIN}).
forthitem
Adjust forthsamp({0 +ORIGIN}) (the 0-th user variable without a name),
normally by storing forthcode({LATEST}). This will restore the 
forthcode({FORTH}) vocabulary at a cold start.
forthitem
Adjust 
version information at 2 cells before forthcode({+ORIGIN}) (if needed)
forthitem
Copy your ciforth to a new file. Modify the header in that file
and overwrite the ciforth in that file,
after the header, by the area 
from forthcode({BM}) to forthcode({HERE}).
forthendenumerate

_LINUX_N_({In this ciforth you can do this by the forthcode({SAVE-SYSTEM}) of block 146. 
It changes the current block file to the program file (using forthcode({BLOCK-EXIT}) and 
 forthcode({BLOCK-INIT}) )
and performing raw writes (using forthcode({R/W}) ), then switching back to your 
original block file. })

@section Memory organization

A running ciforth has 3 distinct memory areas. 

They occur sequentially from low memory to high. 
forthitemize
forthitem
The dictionary, 
forthitem
Free memory, available for dictionary, from below, and stacks, from above.
Its lowest part is used as a scratch area
forthitem
Stacks{}_HIGH_BUF_({, disk block buffers}) and terminal
input buffer. 
forthitem
forthenditemize

_LOW_BUF_({The disk block buffers are allocated in the dictionary,
because otherwise they would not be accessable to the BIOS})

The program as residing on disk may contain startup code, but that is
of no concern for the usage. 

The dictionary area is the only part that is initialised,
the other parts are just allocated.
Logically the Forth system consists of these 7 parts.
forthitemize forthbullet
forthitem
Boot-up parameters 
forthitem
Machine code definitions 
forthitem
Installation dependant code
forthitem
High level standard definitions
forthitem
High level user definitions 
forthitem
System tools (optional)
forthitem
RAM memory workspace 
forthenditemize

@subsection Boot-up Parameters

The boot-up area contains initial 
values for the registers needed for the Forth engine, 
like stack pointers, the pointers to the special memory area's, 
and the very important dictionary pointer forthcode({DP})dnl
that determines the boundary between the dictionary and free space.

Instead they are copied to a separate area the forthdefi({user area}) ,
each time a Forth task, or Forth itself, is started.
The bootup area itself is not changed, but the variables in the user
area are.
By having several user area's, and switching between them,
ciforth can support multitasking.
When you have made extensions to your system, like for instance you
have loaded an editor, you can make these permanent by updating the
initial vvalues in the boot-area and saving the result to disk as an
executable program. 
The boot-area extends from forthsamp({0 +ORIGIN}) 0100H bytes
upward. This is the image for the forthdefi({user area}).
It also extends 6 cells downwards, containing machine code for two 
jumps, to the warm and the cold start, and a version number.
So in ciforth the bootup parameters are more or less the data field of the
forthcode({+ORIGIN}) word. 
Executing forthcode({+ORIGIN}) leaves a pointer in this area but after the jump vectors
and the release numbers. 

@subsection                     Installation Dependent Code

forthcode({KEY}) forthcode({EMIT}) forthcode({?TERMINAL}) forthcode({CR}) and 
forthcode({R/W}) are indeed different for different I/O models.
This is of little concern to you as a user, 
because these are perfectly normal dictionary entries. 
There will however be more differences between the different configurations for 
ciforth for these words than habitually.

@subsection                      Machine Code Definitions

The machine executable code definitions
play an important role because they
convert your computer into a standard Forth stack computer. 
It is clear that although you can define words by other words,
you will hit a lowest level.
The forthdefi({code words}) as these lowest level programs are called,
execute machine code directly, if you invoke them from 
the terminal or from some other definition.
The other definitions, called forthdefi({high level}) code, 
consist of a
sequence
of the machine executable code words. 
The Forth forthdefi({inner interpreter}) takes care that 
these code words are executed in turn.

In the assembler source (if you care to look at it)
you will see that they are interspersed with the 
high level Forth definitions. 
In fact it is quite common to decide to rewrite a code definition in high level
Forth, or the other way around.

Again code words are perfectly normal dictionary entries. 
@subsection                      High-level Standard Definitions

The high level standard definitions add all 
the colon-definitions, user variables, constants, and variables that
must be available in a 
"Forth stack computer" according to the ISO standard. 
They comprise the bulk of
the system, enabling you to execute and compile from the terminal,
execute and add definitions 
by forthdefi({loading}) code from disk etc.
Deviations from standards are ill advised, 
so you probably want to leave this area alone.
Again these words are perfectly normal dictionary entries. 
_VERBOSE_({The technique described for the next section, 
forget and recompile,
is not always possible here because of circular references.
That is in fact no problem with an assembler listing, 
but it is if you load Forth code.})

Again standard definitions words are perfectly normal dictionary entries. 
@subsection                    user definitions

The user definitions 
contain primarily definitions involving user interaction:
compiling aids, finding, forgetting, listing, and number formating. 
Some of these are fixed by the ISO standard too.
These definitions are placed above the standard definitions to
facilitate modification. 
That is you may forthcode({FORGET}) part of
the high-level and re-compile altered definitions from disc. 
This applies even to the ISO standard words.
Again these words are perfectly normal dictionary entries. 
Before long we plan to have these definitions added to the 
system exclusively by loading from disk.

Again user definitions words are perfectly normal dictionary entries. 
@subsection                    System Tools

A text editor and machine code assembler are the first tools 
normally available. 
They are not part of ciforth as delivered,
but they are among the first candidates to be integrated into 
your system. 
Please note how the boundary 
_PC_({ We are
including a sample editor, that is quite handy})
_HOSTED_LINUX_({Development in Linux uses the there available editors.
Code is tested by piping it into Forth, then commanding Forth to
look to the console, as follows :
forthbreak
forthsamp({(echo 8 LOAD; cat pascal.frt - )| ciforth })
forthbreak
Primitive and preliminary as this may seem, 
it has been used for quite substantial developments like the 
80386 assembler.})

386 and a 8086 
Forth assemblers are available in forthfile({BLOCKS.BLK}) .
They are loaded in accordance with the system that is run.

It is essential that you regard ciforth as just a way to get started
with Forth. 
Forth is an extensible language, and you can set it to your hand.
But that also means that you must not hesitate to throw
away parts of the system you don't like, and rebuilt them
even in conflict with standards. 
_VERBOSE_(
{Additions and changes must be planned and
tested at the usual Forth high level.
Later you can rewrite them as code words.})

Again words belonging to tools are perfectly normal dictionary entries. 
@subsection                    RAM Workspace
The RAM workspace contains the compilation space for the dictionary,
_HIGH_BUF_(disc buffers,}) the computation and return stacks, the user area,
and the terminal input buffer, 
_VERBOSE_({From the figforthuser manual
forthquotation
For a single user system, at least 2k bytes must be available above the
compiled system (the dictionary). A 16k byte total system is most typical. 
forthendquotation})
It is indeed possible to do useful work, 
like factoring numbers of a few hundred digits, in a workspace of 2k bytes.
More typical a workspace is several megabytes to over hundred megabytes.

_BITS16_({There is no longer a reason to put up with a 16-bit system less than 64K.})
_BITS32_({32 bits system are set at 64Mbyte but this is arbitrary and could be set much
higher or lower without consequences for system load or whatever. 
Before long we will put the dictionary space on I86-Linux to 4G minus
something and forget about this issue forver. })

_VERBOSE_(
{The boundary between this area and the previous one is pretty sharp, 
it is where forthcode({DP}) points.
The other areas are not clearly separated at all.
But even this boundary constantly changes as you add and forget definitions.})
@subsection                    crap
Underneath the I/O model has improved. TYPE and EXPECT are drawn into
the I/O model dependant part. If at all possible CR and EMIT used TYPE
such that TYPE becomes a natural vectoring point. Similarly KEY 
tries to use EXPECT, but mostly this is not possible because EXPECT doesnot
return before the user hits the Enter key.

@section Specific layouts
@subsection The layout of a dictionary entry

We will divide the dictionary in entries. 
An forthdefi({dictionary entry}) is a part of the dictionary that
belongs to a specific word.
A forthdefi({dictionary entry address}) is a pointer to a dictionary entry.
In this ciforth it is the lowest addres of the entry, where the name is.

A dictionary entry has the following fields:
forthenumerate
forthitem
The name field.
This is of variable length.
A pointer to such a field is called a forthdefi({name field address}).
It starts and ends with a byte with the sign bit (8th bit) up{}_ALIGNED_(, followed
by padding to the next cell boundary.}).
_VERBOSE_({Unfortunately, forthdefi({name field address}) is often used, 
where a forthdefi({dictionary entry address}) would be more correct. 
That they happen to be the same is no reason to confuse two completely different concepts.})
forthitem
The link field. This is one cell. 
A pointer to such a field is called a forthdefi({link field address}) .
It contains the 
dictionary entry address of the last word that was 
defined in the same            forthdefi({vocabulary}).
forthitem
The code field. This is one cell. 
A pointer to such a field is called a forthdefi({code field address}) .
It contains the address of the code to be executed for this word.
forthitem
The parameter field. 
This is of variable length.
A pointer to such a field is called a forthdefi({parameter field address}) .
It contains everything not mentionned above.
forthendenumerate
Of these fields two deserve special attention.

The name field need not contain all the letters that 
belong to the name of the word. 
The word will be found if the length of the word matches, 
and the letters that are present agree with the name sought for.
forthxref({WIDTH}).
forthitemize
forthitem
The first byte of the name field has the natural character count in the
low 5 bits. 
forthitem
The sixth bit = 1 when forthdefi({smudge})d, and will prevent a 
match by forthcode({(FIND)})  
forthitem
The seventh bit = 1 for IMMEDIATE definitions; it is called the
 forthdefi({precedence bit}). 
forthitem
The eighth or sign bit is always = 1. 
forthitem
The following bytes contain the names' letters, up to the value in 
forthcode({WIDTH}) at the time of compilation.
forthitem
In the byte containing the last letter saved, the sign bit = 1. 
_ALIGNED_(
{forthitem
After the last letter follow zero bytes uptill the next cell boundary.})
forthenditemize
_VERBOSE_(
{The above methods are implemented in forthcode({CREATE}) .
Remember that forthcode({-FIND}) uses forthsamp({BL WORD}) to bring the next text 
to forthcode({HERE}) with the count preceeding. 
All that is necessary, is to limit by forthcode({WIDTH}) and toggle the
proper delimiting bits. 
forthbreak})
For a demostration of the (non portable) tricks that are allowed by this,
see the forthcodeni({$____}) and forthcodeni({$__}) words in forthfile({BLOCKS.BLK}) . 

The parameter field has a length and content that depends on the type of the word.
forthitemize
forthitem
For a code word, it contains machine code. 
The code field of this word points to it.
forthitem
For a word defined by 
forthcode({VARIABLE}), forthcode({USER}), or forthcode({CONSTANT}) dnl
it has a width of one cell, and contains data.
forthitem
For a forthdefi({colon definition}) the code field contains
a pointer to the forthdefi({inner interpreter}) code.
The parameter field has a variable length and contains the
compiled high level code, a sequence of forthdefi({code field address})es.
forthitem
For all word defined via forthdefi({<BUILDS ... DOES>}) the code field 
contains the same code, forthsamp({DODOES}).
The first cell contains a pointer to the forthdefi({high level}) code 
defined by forthcode({DOES>}) and the remainder is data. 
A pointer to the data is passed to the forthcode({DOES>}) code.
forthenditemize
@subsection Details of memory layout

The disc buffer area is at the upper bound of RAM memory. It is comprised of
an integral number of buffers, each B/BUF+4 bytes. 
B/BUF is the number of bytes read from the disc, usually one sector. B/BUF
must be a power of two (64, 128, 256, 512 or 1024). 
The constant FIRST has the value of the address of the start of the first
buffer. 
LIMIT has the value of the first address beyond the top buffer. The distance
between FIRST and LIMIT must be N*(B/BUF+4) bytes. 
This N must be two or more. 

I set the number of disk buffers at 2, the minimum possible. Even a floppy
is fast enough that working with blocks from memory has no merits. It is
dangerous because during testing you never know what was saved and what not.
The mass storage is easily the most crappy part of the fig model. What
little advantage it had, is no longer applicable. Interestingly this block
system is copied verbatim into ANS. 
32 bits systems can enlarge the dictionary by redefining the stacks and the
terminal input buffer positions. The block buffers are in the way. So I put
them in the dictionary space. In fact the block buffers have become the 
data field of FIRST.

Constant B/SCR has the value of the number of buffers per screen; 
i.e. 1024 / B/BUF. 

The user area must be at least 34 bytes; 48 is more appropriate. In a 
multi-user system, each user has his own user area, for his copy of system 
variables. This method allows reentrant use of the Forth vocabulary. 

The terminal input buffer is decimal 80 bytes (the hex 50 in QUERY) plus 2
at the end. If a different value is desired, change the limit in QUERY. A
parameter in the boot-up literals locates the address of this area for TIB.
The backspace character is also in the boot-up origin parameters. It is
universally expected that "rubout" is the backspace. 

The return stack grows downward from the user area toward the terminal
buffer. Forty-eight bytes are sufficient. The origin is in R0 (R-zero) and
is loaded from a boot-up literal. 

The computation stack grows downward from the terminal buffer toward the
dictionary which grows upward. The origin of the stack is is in variable S0
(S-zero) and is loaded from a boot-up literal. 

After a cold start, the user variables contain the addresses of the above
memory assignments. 
An advanced user may relocate while the system is running. A newcomer should
alter the startup literals and execute COLD. The word +ORIGIN is provided
for this purpose. +ORIGIN gives the address byte or word relative to the
origin depending on the computer addressing method. 

Despite all the talk about user variables, I am not aware that a multi-user
fig forth existed, ever. The above block policy is not compatible with 
multi-user (but the actual code is not worse than it ever was, and you can
rebuilt it with 1000 block buffers if you like.)

Rubout is best left to the EXPECT code. Remember, a Linux itself knows the
rubout key for any of its 500+ known terminal types and isn't it nice in
MSDOS that F3 gets the previous command back for you? 
If EXPECT builds up a line from separate key strokes, and if you ever want
to change the rubout key, just change the RUBOUT user variable. 


CUSTOMISING

The name USER reflects that more than one user could use the dictionary
and users could share the background storage, provided certain precautions
are taken. About this you can forget.
What you can do is, store back you user variables in the boot-up 
parameters as follows
forthsamp({USVA @   ' USVA @   +ORIGIN !})
where forthvar({USVA}) is the user variable which value you want to keep.

