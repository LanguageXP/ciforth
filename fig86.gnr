;               HCC FIG generic 8086 FORTH
; $Id$
; Copyright (2000): Albert van der Horst, HCC FIG Holland by GNU Public License
;
	PAGE  66,106
 TITLE   GENERIC FORTH FOR 8086 $Revision$
 _HEADER_ASM
_COMMENT 
	A generic version of FIG-FORTH for IBM type standard PC's
		Albert van der Horst
		HCC Forth user group
		The Netherlands
		www.forth.hccnet.nl

              based on 
	      FIG-FORTH
   implemented by:  Charlie Krajewski
		    205 ( BIG ) Blue Rd.
		    Middletown, CT  06457

  This implementation supports only one 64k segment

  The listing has been made possible by the
  prior work of:
	       Thomas Newman, Hayward, Ca.

 : other_acknowledgements
	 John_Cassidy
	 Kim_Harris
	 George_Flammer
	 Robert_D._Villwock ;
 To upgrade, modify, and understand Fig Forth, the
 value of the following book cannot be overstated:
	 Systems Guide to FIG Forth
	 C. H. Ting, PhD
 It is available through MVP.  See any recent issue
 of FORTH Dimensions for their ad. (DIXIT AD MDCCCCLXXX)

No one who programs with FORTH can afford to be without:
  Starting Forth
  Leo Brodie
Get it.  Available through FORTH Interest Group.
Can also be found in many book stores.
Chapter 3 serves as a guide for the EDITOR that you
will probably type in from the FIG-Forth installation
manual.

Although there is much to be said for typing in your own
listing and getting it running, there is much to be said 
not typing in your own listing.  If you feel that 100+
pages of plinking is nutty, contact me for availability
of a disc with source & executable files.  Obtainable at
a bargain basement price, prepare yourself for bargain
basement support.

All publications of the FORTH Interest Group are public domain.
They may be further distributed by the inclusion of this
credit notice:
	       This publication has been made available by:
       
	       FORTH Interest Group
	       P.O. Box 1105
	       San Carlos, Ca.  94070
_ENDCOMMENT
	PAGE
FIGREL	EQU	2	; FIG RELEASE #
FIGREV	EQU	0	; FIG REVISION #
USRVER  EQU     0  	; USER VERSION NUMBER
;
;	ASCII CHARACTER EQUIVALENTS
;
ABL	EQU	20H	; SPACE
ACR	EQU    	0DH	; CR
ADOT	EQU	2EH	; PERIOD
BELL	EQU	07H	; ^G
BSIN	EQU	08H	; INPUT DELETE CHARACTER
BSOUT	EQU	08H	; OUTPUT BACKSPACE ( ^H )
LF	EQU 	0AH	; LINE FEED, USED INTERNALLY AS
                        ; LINE ENDER
FF	EQU	0CH	; FORM FEED
;
;	MEMORY + I/O CONSTANTS
;
EM	EQU	04000H	; END OF MEMORY + 1
NBUF	EQU	2	; NO. OF BUFFERS AKA SCREENS 
KBBUF	EQU	1024    ;DATA BYTES PER DISK BUFFER
US	EQU	40H	; USER VARIABLE SPACE
RTS	EQU	0A0H	; RETURN STACK & TERM BUFFER
;
CO	EQU	KBBUF+4		; DISK BUFFER + 4 BYTES
BUF1	EQU	EM-CO*NBUF	; FIRST DISK BUFFER
STRUSA  EQU     BUF1-US         ; User area
STRTIB  EQU     STRUSA-RTS      ; Start return stack area
                                ; Under this : data stack
INITR0  EQU     STRUSA         ; Grows down
INITS0  EQU     STRTIB          ; Growns down

;____1_____ _USEDOS_1_({
DRIVE   EQU     0       ; Use floppy A for blocks.
});_END___1__({_USEDOS_1_})

BPS     EQU     512             ;Bytes/sector, common to all of MSDOS
;
;____1_____ _USEBIOS_1_({
;
; Disk parameters:
; HD drive 3" 
TRKS    EQU     80    ;Number of tracks
SPT     EQU     18    ;Sectors/track
HEADS   EQU     2     ;Number of heads 
NFAT    EQU     2     ; Number of FATS
SECROOT EQU     0EH   ; Sectors for root directory entry.
SECFAT  EQU     9     ; Sectors per FAT
MEDIA   EQU    0F0H   ; Descriptor byte. Anachronism.

_COMMENT
; HD drive 5" 
TRKS    EQU     80      ;Number of tracks
SPT     EQU     15      ;Sectors/track
HEADS   EQU     2       ;Number of heads 
NFAT    EQU     2       ; Number of FATS
SECROOT EQU     ?       ; Sectors for root directory entry.
SECFAT  EQU     ?       ; Sectors per FAT
MEDIA   EQU    F0H      ; Descriptor byte. Anachronism.
_ENDCOMMENT

; Bios specific equates.
BOOTADDRESS     EQU     07C00H          ; PC jumps to 0:7C00 to boot
SPDRV   EQU     HEADS*TRKS*SPT    ; sectors/drive
        ; Skip boot sector,fats and root dir.
SECSTRT EQU     1+NFAT*SECFAT + SECROOT            
_COMMENT
; Alternative if the disk need not be recognized by MSDOS
; Usable for generating a bootable floppy simple.
SECSTRT EQU     1       
_ENDCOMMENT
});_END___1__({_USEBIOS_1_})

        PAGE
        CSEG    SEGMENT PARA PUBLIC 'CODE'
	ASSUME CS:CSEG,DS:CSEG,SS:CSEG,ES:CSEG
define( {}, _no({$0}) )dnl       

;____1_____ _BOOTED__1_({
          ORG     0H
ORG0:   JMP     SHORT BOOT
        NOP
        ; MSDOS programmers reference (thru 6, 3.9)
        DB    "DFW--EXP"
LBPS    DW         BPS
        DB         001H
RESSECTORS  DW     01H
        DB         NFAT 
        DW BPS*SECROOT/32
        DW         SPDRV
        DB         MEDIA
        DB         SECFAT, 0H
LSPT    DW         SPT
LHEADS  DW       HEADS
HIDDENSECS    DD        0H
HUGESECS      DD         000H
      ; BIOS parameter block ends here
        DB 000H, 000H, 029H                  ; Required magic.
        DB         004H, 01CH, 040H,  00BH
        DB    "           "
        DB    "FAT12   "

RETRY:
        CALL    DISPLAYW
        MOV     AL,' '
        MOV     AH,00   ; Reset
        MOV     DL,00            ;Drive 0 (floppy 1)
        INT(13H)                 ;BIOS disk read function
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
        MOV     AX,CX
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
BOOT:   
;       CALL DUMPREGS
        MOV     AL,'D'
        CALL    DISPLAY
        MOV AX,CS
        AND AX,AX       ; Z = BOOTING ?
        JNZ  ELSE1
        ; Adjust code segment address without leaving the ball
        ; Generating machine code is actually simpler than
        ; beating the assembler. After 10 attempts I gave up
        ; This is a simple straightforward intersegment jump
;       JMP FAR BOOTADDRESS+ELSE1
         DB      0EAH
         DW      ELSE1
         DW     BOOTADDRESS/10H
ELSE1:  
;MYSELF: JMP MYSELF    ; STOP IT RIGHT HERE
        MOV     AL,'F'
        CALL    DISPLAY
        CLI                     ; Disallow interrups until stack ready
        MOV     AX,CS
        MOV     DS,AX
        MOV     SS,AX
        MOV     ES,AX
        MOV     SP,0H
        STI                     ; Allow interrupts
        MOV     AH,00   ; Reset
        MOV     DL,00            ;Drive 0 (floppy 1)
        INT(13H)                 ;BIOS disk read function
        JB      RETRY

        ; The first file copied to a freshly formatted floppy will
        ; be at SECSTRT (See also genboot.bat)
        MOV     CX,SECSTRT                                                     
        MOV     BX,BPS
BEGIN1: CALL    READSECTOR
        JB      RETRY
        CMP     CX,SECSTRT + EM/BPS      ; Grossly overestimated.
        JNE     BEGIN1
        
        MOV     AL,'W'
        CALL    DISPLAY
        CALL    DISPLAYCR
        JMP     ORIG
        
;       Read the sector with number in CX (Counting from 0)
;       Leave into CX the incremented sec# 
READSECTOR:
        PUSH    CX
        PUSH    BX
        MOV     AX,CX
        XOR     DX,DX
        DIV     _WORD_PTR[LSPT]
        MOV     CL,DL
        INC     CL      ; Sectors counting from 1!
        XOR     DX,DX
        DIV     _WORD_PTR[LHEADS]
        MOV     DH,DL   ; Head number
        MOV     CH,AL   ; Only small disks <256 cylinders
        MOV     DL,00            ;Drive 0 (floppy 1)
        MOV     AX,0201H   ; Read absolute one sector
        INT(13H)                 ;BIOS disk read function
        POP     BX
        ADD     BX,BPS
        POP     CX
        INC     CX
        RET
DUMPREGS:
        CALL    DISPLAYPC
        CALL    DISPLAYCR
        MOV     AX,CS
        CALL    DISPLAYW
        CALL    DISPLAYCR
        MOV     AX,DS
        CALL    DISPLAYW
        CALL    DISPLAYCR
        MOV     AX,ES
        CALL    DISPLAYW
        CALL    DISPLAYCR
        MOV     AX,SS
        CALL    DISPLAYW
        CALL    DISPLAYCR
        MOV     AX,SI
        CALL    DISPLAYW
        CALL    DISPLAYCR
        MOV     AX,DI
        CALL    DISPLAYW
        CALL    DISPLAYCR
;MYSELF: JMP MYSELF    ; Put in if you really want to see them
        RET
        
DISPLAYCR:
        MOV     AL,ACR
        CALL    DISPLAY
        MOV     AL,LF
        JMP DISPLAY
        
DISPLAYPC:      POP     AX
        PUSH    AX
DISPLAYW:       PUSH    AX              ; Display AX in hex 
        MOV     AL,AH
        CALL    DISPLAYHEX
        POP     AX
        ; CALL DISPLAYHEX ; RET
DISPLAYHEX:     PUSH    AX              ; Display AL in hex 
        MOV     CL,4
        SAR     AL,CL
        CALL    DISPLAYHD
        POP     AX
        ; CALL DISPLAYHD ; RET
DISPLAYHD:      AND     AL,0FH          ; Display AL as one hex digit
        DAA
        MOV     AH,AL
        MOV     CL,5
        SHR     AH,CL
        ADC     AL,30H
        ; CALL DISPLAY ; RET
DISPLAY:XOR     BH,BH           ; Display AL as an ASCII char
        MOV     AH,0EH
        INT(10H)
        RET
        
        _NEW_ORG(01FEH)
        ; Signature. 
        DB         055H, 0AAH
                 
});_END___1__({ _BOOTED__1_})

;____1_____ _HOSTED__1_({
	ORG	100H	; Required start of .COM program.
});_END___1__({ _HOSTED__1_})

ORIG:
	NOP
	JMP	LCLD     ;VECTOR TO COLD START
	NOP
	JMP	WRM	; VECTOR TO WARM START
;
; This are is accessed trough three incompatible means:
;        1 label
;        2 hard coded offset with respect to orig
;        3 Idem but through PORIG.
; Note also LAINI could be without harm a 
	DB	FIGREL	; FIG RELEASE #
	DB	FIGREV	; FIG REVISION #
	DB	USRVER	; USER REVISION #
	DB	0EH	; VERSION ATTRIBUTES
LAINI:  DW	_LINK_FIELD(TASK) ; LAST WORD
	DW	BSIN	; BACKSPACE
	DW	STRUSA  ; INIT (UP)
;
;	Initialisation block for user variables through VOC-LINK
;       <<<<< must be in same order as user variables >>>>>
;       If the assembler used supports it, we better just initialise
;       the UP area directly. A COLD start cannot be used to get
;       the system under control, only to remove user programs.
;
USINI:
	DW 	INITS0	; INIT (S0)
	DW 	INITR0	; INIT (R0)
	DW 	STRTIB  ; INIT (TIB)
	DW	32	; INIT (WIDTH)
	DW	0	; INIT (WARNING)
	DW	INITDP	;	INIT (FENCE)
	DW	INITDP  ;	INIT (DP)
	DW	_VOC_LATEST(FORTH) ;       INIT (VOC-LINK)
	;
;	<<<<< end of data used by cold start >>>>>
;
;	The following is the CPU's name, printed
;       during cold start.
;       The name is 32 bits in base 36.
;
CPUNM   DW      5H,0B328H       ; '8088'
UP	DW	INITR0	; USER AREA POINTER
RPP	DW	INITR0	; RETURN STACK POINTER
	PAGE
_COMMENT
   FORTH REGISTERS

   FORTH   8088     FORTH PRESERVATION RULES
   -----   ----     ----- ------------ -----
    IP      SI      Interpreter pointer.  Must be preserved
		    across FORTH words.

     W      DX      Working register.  Jump to 'DPUSH' will
		    push contents onto the parameter stack
		    before executing 'APUSH'.
 
    SP      SP      Parameter stack pointer.  Must be preserved 
		    across FORTH words.
 
    RP      BP      Return stack.  Must be preserved across
		    FORTH words.

	    AX      General register.  Must be preserved across
		    FORTH words.

	    BX      General purpose register.
 
	    CX      General purpose register.

	    DI      General purpose register.

	    CS      Segment register.  Must be preserved
		    across FORTH words.

	    DS      ditto
	
	    SS      ibid
 
	    ES      Temporary segment register only used by
		    a few words.

---------------------------------------------------------- 
_ENDCOMMENT
	PAGE
_COMMENT 
---------------------------------------------

   COMMENT CONVENTIONS
   ------- -----------

   =       IS EQUAL TO
   <-      ASSIGNMENT

  NAME        =  Address of name
  (NAME)      =  Contents of name
  ((NAME))    =  Indirect contents

  CFA         =  Address of CODE FIELD
  LFA         =  Address of LINK FIELD
  NFA         =  Address of NAME FIELD
  PFA         =  Address of PARAMETER FIELD

  S1          =  Parameter stack - 1st word
  S2          =  Parameter stack - 2nd word
  R1          =  Return stack    - 1st word
  R2          =  Return stack    - 2nd word

  LSB         =  Least significant bit
  MSB         =  Most  significant bit
  LB          =  Low byte
  HB          =  High byte
  LW          =  Low  word

------------------------------------------------------------ 
_ENDCOMMENT
	PAGE
_COMMENT 
	     DEBUG SUPPORT

THIS ROUTINE WILL ALLOW YOU TO STEP THRU FORTH PROGRAMS
EVERY TIME 'NEXT' IS EXECUTED.

IN ORDER TO USE THE STEP FEATURE YOU MUST DO THE FOLLOWING:

	1.  PATCH THE INSTRUCTION IN 'NEXT' WITH A JUMP
	    TO 'TNEXT'
 
	2.  PATCH YOUR BREAKPOINT ROUTINE AT
	    LABEL   'BREAK'
	
	3.  SET VARIABLES, `BIP' & `BIPE' TO THE
	    ADDRESSES YOU WANT TO STEP THRU.

THE CONTENTS OF THE 2 VARIABLES 'BIP` AND `BIPE'
ARE INTERPRETED AS FOLLOWS:

BIP	BIPE	DEBUG-CONDITION
---	----	---------------

  0	   X	OFF
 -1	   X    TRACE ALL `NEXT' CALLS
ADDR1      0    TRACE `ADDR1' ONLY
ADDR1  ADDR2    TRACE `ADDR1' TO `ADDR1'

NOTE:	THE ABOVE ADDRESSES CAN'T POINT TO A
	`CODE FIELD ADDRESS'. 
	X = DON'T CARE

----------------------------------------------------- 
_ENDCOMMENT

BIP	DW	0	; BREAKPOINT START ADDRESS
BIPE	DW	0	; BREAKPOINT END ADDR
	PAGE
;	THIS IS THE `NEXT' WITH DEBUG SUPPORT

TNEXT:  PUSHF		;SAVE REGISTER
	PUSH	AX
	MOV	AX,[BIP]  ; BREAKPOINT START ADDR
	OR	AX,AX	; ZERO?
	JZ	TNEXT2	; NO BREAKPOINT
	CMP	AX,-1
	JZ	TNEXT1	; STEP ALL POINTS
	CMP	AX,SI	; IN BREAKPOINT RANGE?
	JZ	TNEXT1	; STEP THIS LOCATION
	JA	TNEXT2	; NO
	MOV	AX,[BIPE] ; BREAKPOINT END ADDR
	OR	AX,AX	; ZERO?
	JZ	TNEXT2	; ONLY 1 LOCATION
	CMP	AX,SI	; IN RANGE STILL?
	JB	TNEXT2	; NO

;	PAUSE ON ADDRESS
;
TNEXT1: POPF
;
;********  ADD YOUR BREAKPOINT HERE  **********
;
BREAK:  JMP	SHORT	TNEXT3	;CONT WITH PROGRAM
;
;	NO BREAKPOINT PAUSE - RESTORE REGISTERS
;
TNEXT2:	POP	AX
	POPF
TNEXT3:	LODSW		; AX <- (IP)
	MOV	BX,AX
	JMP	SHORT	NEXT1
	PAGE
DPUSH:	PUSH	DX
APUSH:	PUSH	AX
_COMMENT

    Patch the next 3 locations ( using a DBUG monitor ) with a
    `JMP TNEXT' for tracing through high level FORTH words. 

_ENDCOMMENT
NEXT:	LODSW		;AX <- (IP)
	MOV	BX,AX
;
NEXT1:	MOV	DX,BX	; (W) <- (IP)
	INC	DX	; (W) <- (W) + 1
	JMP     _WORD_PTR[BX]    ; TO `CFA'
	PAGE
;
;       Dictionary starts here.
DP0:
HEADER({LIT},{LIT},{$ + 2})
	LODSW		; AX <- LITERAL
	JMP SHORT     APUSH   ; TO TOP OF STACK
;
HEADER({EXECUTE},{EXEC},{$+2})
	POP     BX      ; GET CFA
	JMP SHORT     NEXT1   ; EXECUTE NEXT
;
HEADER({BRANCH},{BRAN},{$+2})
BRAN1:	ADD	SI,[SI]
	JMP SHORT     NEXT    ; JUMP TO OFFSET
;
HEADER({0BRANCH},{ZBRAN},{$+2})
	POP	AX	; GET STACK VALUE
	OR	AX,AX	; ZERO?
	JZ	BRAN1	; YES, BRANCH
	INC	SI	; NO - CONTINUE...
	INC 	SI
	JMP SHORT     NEXT
	PAGE
;
HEADER({(LOOP)},{XLOOP},{$+2})
	MOV	BX,1	; INCREMENT
XLOO1:	ADD	[BP],BX	; INDEX = INDEX + INCR
	MOV	AX,[BP]	; GET NEW INDEX
	SUB	AX,[2+BP]        ; COMPARE WITH LIMIT
	XOR	AX,BX	; TEST SIGN
	JS	BRAN1	; KEEP LOOPING
;
;  END OF `DO' LOOP
	ADD	BP,_BYTE 4    ; ADJ RETURN STACK
	INC	SI	; BYPASS BRANCH OFFSET
	INC	SI
	JMP SHORT     NEXT
;
HEADER({NOOP},{NOOP},{$+4})
;	DEBUG STUFF
NOP0	DW	$+2
	JMP SHORT     NEXT
NOP1	DW 	$+2
	JMP SHORT     NEXT
NOP2	DW	$+2
	JMP SHORT     NEXT
;
HEADER({(+LOOP)},{XPLOO},{$+2})
	POP	BX	; GET LOOP VALUE
	JMP SHORT     XLOO1
;
HEADER({(DO)},{XDO},{$+2})
	POP	DX	; INITIAL INDEX VALUE
	POP	AX	; LIMIT VALUE
	XCHG	BP,SP	; GET RETURN STACK
	PUSH	AX
	PUSH	DX
	XCHG	BP,SP	; GET PARAMETER STACK
	JMP	NEXT
	PAGE
HEADER({I},{IDO},{$+2})
	MOV	AX,[BP]	; GET INDEX VALUE
	JMP	APUSH	; TO PARAMETER STACK
;
HEADER({DIGIT},{DIGIT},{$+2})
	POP	DX	;NUMBER BASE
	POP	AX	;ASCII DIGIT
	SUB	AL,'0'
	JB	DIGI2	;NUMBER ERROR
	CMP	AL,9
	JBE	DIGI1	;NUMBER = 0 THRU 9
	SUB	AL,7
	CMP	AL,10	;NUMBER 'A' THRU 'Z'?
	JB	DIGI2	;NO
DIGI1:	CMP	AL,DL	; COMPARE NUMBER TO BASE
	JAE	DIGI2	;NUMBER ERROR
	SUB	DX,DX	;ZERO
	MOV	DL,AL	;NEW BINARY NUMBER
	MOV	AL,1	;TRUE FLAG
	JMP	DPUSH	;ADD TO STACK
;   NUMBER ERROR
DIGI2:	SUB	AX,AX	;FALSE FLAG
	JMP	APUSH
	PAGE
HEADER({(FIND)},{PFIND},{$+2})
	MOV	AX,DS
	MOV	ES,AX	;ES = DS
	POP	BX	;NFA
	POP	CX	;STRING ADDR
;
;  SEARCH LOOP
PFIN1:  MOV	DI,CX	;GET ADDR
	MOV	AL,[BX]	;GET WORD LENGTH
	MOV	DL,AL	;SAVE WORD LENGTH
	XOR	AL,[DI]
	AND	AL,3FH	;CHECK LENGTHS
	JNZ	PFIN5	;LENGTHS DIFFER

;
;   LENGTHS MATCH - CHECK EACH CHARACTER IN NAME
PFIN2:	INC	BX
	INC	DI	; NEXT CHAR OF NAME
	MOV	AL,[BX]
	XOR	AL,[DI]	;COMPARE NAMES
	ADD	AL,AL	;THIS WILL BE TEST BIT 8
	JNZ	PFIN5	;NO MATCH
	JNB	PFIN2	;MATCH SO FAR - LOOP
;
;   FOUND END OF NAME (BIT 8 SET) - A MATCH
	ADD	BX,_BYTE 5    ; BX = PFA
	PUSH	BX	; (S3) <- PFA
	MOV	AX,1	;TRUE VALUE
	SUB	DH,DH
	JMP	DPUSH
;
;   NO NAME MATCH - TRY ANOTHER
;
; GET NEXT LINK FIELD ADDR (LFA)
; ( ZERO = FIRST WORD OF DICTIONARY )
;
PFIN5:	INC	BX	;NEXT ADDR
	JB	PFIN6	;END OF NAME
	MOV	AL,[BX]	;GET NEXT CHAR
	ADD	AL,AL	;SET/RESET CARRY
	JMP SHORT     PFIN5   ;LOOP UNTIL FOUND
;
PFIN6:	MOV	BX,[BX]	; GET LINK FIELD ADDR
	OR	BX,BX	; START OF DICT ( 0 )
	JNZ	PFIN1	; NO , LOOK MORE
	MOV	AX,0	; FALSE FLAG
	JMP	APUSH	; DONE ( NO MATCH FOUND )
	PAGE
HEADER({ENCLOSE},{ENCL},{$+2})
	POP	AX	;S1 - TERMINATOR CHAR
	POP	BX	;S2 - TEXT ADDR
	PUSH	BX	;ADDR - BACK TO STACK ( IT RHYMES )
	MOV	AH,0	;ZERO
	MOV	DX,-1	;CHAR OFFSET COUNTER
	DEC	BX	;ADDR -1
;
;   SCAN TO FIRST NON-TERMINATOR CHARACTER
ENCL1:	INC	BX	;ADDR+1
	INC	DX	;COUNT+1
	CMP	AL,[BX]
	JZ	ENCL1	;WAIT FOR NON-TERMINATOR
	PUSH	DX	;OFFSET TO 1ST TEXT CHAR
	CMP	AH,[BX]	;NULL CHAR?
	JNZ	ENCL2	;NO
;
;  FOUND NULL BEFORE 1ST NON-TERM CHAR
	MOV	AX,DX	;COPY COUNTER
	INC	DX	; +1
	JMP	DPUSH
;
;   FOUND FIRST TEXT CHAR - COUNT THE CHARS
ENCL2:	INC	BX	; ADDR+1
	INC	DX	;COUNT+1
	CMP	AL,[BX]	;TERMINATOR CHAR?
	JZ	ENCL4	;YES
	CMP	AH,[BX]	;NULL CHAR?
	JNZ	ENCL2	;NO, LOOP AGAIN
;
;   FOUND NULL AT END OF TEXT
ENCL3:	MOV	AX,DX	;COUNTERS ARE EQUAL
	JMP	DPUSH
;
;   FOUND TERMINATOR CHARACTER
ENCL4:	MOV	AX,DX
	INC	AX	;COUNT+1
	JMP	DPUSH
	PAGE
	; At line     LINE ~500
HEADER({CR},{CR},{DOCOL})
        DW      LIT,LF
        DW      EMIT
        DW      SEMIS
	PAGE
HEADER({CMOVE},{LCMOVE},{$+2})
	CLD             ;INC DIRECTION
	MOV	BX,SI	;SAVE IF
	POP	CX	;COUNT
	POP	DI	;DEST
	POP	SI	;SOURCE
	MOV	AX,DS
	MOV	ES,AX	;ES <- DS
	REP	MOVSB	;THAT'S THE MOVE
	MOV	SI,BX	;GET BACK IP
	JMP	NEXT
;
HEADER({U*},{USTAR},{$+2})
	POP	AX
	POP	BX
	MUL	BX	;UNSIGNED
	XCHG	AX,DX	;AX NOW = MSW
	JMP	DPUSH	;STORE DOUBLE WORD
;
HEADER({U/},{USLAS},{$+2})
	POP	BX	;DIVISOR
	POP	DX	;MSW OF DIVIDEND
	POP	AX	;LSW OF DIVIDEND
	CMP	DX,BX	;DICIDE BY 0?
	JNB	DZERO	; ERROR - ZERO DIVIDE
	DIV	BX	;16 BIT DIVIDE
	JMP	DPUSH	;STORE QUOT/REM
;
;	DIVIDE BY ZERO ERROR - SHOW MAX NUMBERS
DZERO:	MOV	AX,-1
	MOV	DX,AX
	JMP	DPUSH	;STORE QUOT/REM
	PAGE
HEADER({AND},{LAND},{$+2})
	POP	AX
	POP	BX
	AND	AX,BX
	JMP	APUSH
;
HEADER({OR},{LOR},{$+2})
	POP	AX      ; (S1) <- (S1) OR (S2)
	POP	BX
	OR	AX,BX
	JMP	APUSH
;
HEADER({XOR},{LXOR},{$+2})
	POP	AX      ; (S1) <- (S1) XOR (S2)
	POP	BX
	XOR	AX,BX
	JMP	APUSH
	PAGE
HEADER({SP@},{SPFET},{$+2})
	MOV	AX,SP   ; (S1) <- (SP)
	JMP	APUSH
;
HEADER({SP!},{SPSTO},{$+2})
	MOV	BX,[UP]   ;USER VAR BASE ADDR
	MOV	SP,[6+BX]        ;RESET PARAM STACK POINTER
	JMP	NEXT
;
HEADER({RP@},{RPFET},{$+2})      ;(S1) <- (RP)
	MOV	AX,BP	;RETURN STACK ADDR
	JMP	APUSH
;
HEADER({RP!},{RPSTO},{$+2})
	MOV	BX,[UP]   ;(AX) <- USR VAR BASE
	MOV	BP,[8+BX]        ;RESET RETURN STACK PTR
	JMP	NEXT
	PAGE
HEADER({;S},{SEMIS},{$+2})
	MOV	SI,[BP]	;(IP) <- (R1)
	INC	BP
	INC	BP	;ADJUST STACK
	JMP	NEXT
;
HEADER({LEAVE},{LLEAV},{$+2})  ;LIMIT <- INDEX
	MOV	AX,[BP]	;GET INDEX
	MOV	[2+BP],AX        ;STORE IT AT LIMIT
	JMP	NEXT
	PAGE
;
HEADER({>R},{TOR},{$+2})        ; (R1) <- (S1)
	POP	BX	;GET STACK PARAMETER
	DEC	BP
	DEC	BP	;MOVE RETURN STACK DOWN
	MOV	[BP],BX	;ADD TO RETURN STACK
	JMP	NEXT
;
HEADER({R>},{FROMR},{$+2})      ;(S1) <- (R1)
	MOV	AX,[BP]	; GET RETURN STACK VALUE
	INC	BP	;DELETE FROM STACK
	INC	BP
	JMP	APUSH
;
HEADER({R},{RR},{IDO+2})
	PAGE
HEADER({0=},{ZEQU},{$+2})
	POP	AX
	OR	AX,AX	;DO TEST
	MOV	AX,1	;TRUE
	JZ	ZEQU1	;IT'S 0
	DEC	AX	;FALSE
ZEQU1:	JMP	APUSH
;
HEADER({0<},{ZLESS},{$+2})
	POP	AX
	OR	AX,AX	;SET FLAGS
	MOV	AX,1	;TRUE
	JS	ZLESS1
	DEC	AX	;FALSE
ZLESS1:	JMP	APUSH
;
HEADER({+},{PLUS},{$+2})
	POP	AX      ;(S1) <- (S1) + (S2)
	POP	BX
	ADD	AX,BX
	JMP	APUSH
	PAGE
HEADER({D+},{DPLUS},{$+2})
	POP	AX	; YHW
	POP	DX	; YLW
	POP	BX	; XHW
	POP	CX	; XLW
	ADD	DX,CX	; SLW
	ADC	AX,BX	; SHW
	JMP	DPUSH
;
HEADER({MINUS},{MINUS},{$+2})
	POP	AX
	NEG	AX
	JMP	APUSH
;
HEADER({DMINUS},{DMINU},{$+2})
	POP	BX
	POP	CX
	SUB	AX,AX
	MOV	DX,AX
	SUB	DX,CX	; MAKE 2'S COMPLEMENT
	SBB	AX,BX	; HIGH WORD
	JMP	DPUSH
	PAGE
;
HEADER({OVER},{OVER},{$+2})
	POP	DX
	POP	AX
	PUSH	AX
	JMP	DPUSH
;
HEADER({DROP},{DROP},{$+2})
	POP	AX
	JMP	NEXT
;
HEADER({SWAP},{SWAP},{$+2})
	POP	DX
	POP	AX
	JMP	DPUSH
;
HEADER({DUP},{DUPE},{$+2})
	POP	AX
	PUSH	AX
	JMP	APUSH
	PAGE
HEADER({2DUP},{TDUP},{$+2})
	POP	AX
	POP	DX
	PUSH	DX
	PUSH	AX
	JMP	DPUSH
;
HEADER({+!},{PSTOR},{$+2})
	POP	BX	;ADDRESS
	POP	AX	;INCREMENT
	ADD	[BX],AX
	JMP	NEXT
;
HEADER({TOGGLE},{TOGGL},{$+2})
	POP	AX	;BIT PATTERN
	POP	BX	;ADDR
	XOR	[BX],AL	;
	JMP	NEXT
;
HEADER({@},{FETCH},{$+2})
	POP	BX
	MOV	AX,[BX]
	JMP	APUSH
	PAGE
HEADER({C@},{CFET},{$+2})
	POP	BX
	MOV	AL,[BX]
	SUB	AH,AH
	JMP	APUSH
;
HEADER({2@},{TFET},{$+2})
	POP	BX	;ADDR
	MOV	AX,[BX]	;MSW
	MOV	DX,[2+BX]        ;LSW
	JMP	DPUSH
;
HEADER({!},{STORE},{$+2})
	POP	BX	;ADDR
	POP	AX	;DATA
	MOV	[BX],AX
	JMP	NEXT
;
HEADER({C!},{CSTOR},{$+2})
	POP	BX	;ADDR
	POP	AX	;DATA
	MOV	[BX],AL
	JMP	NEXT
;
HEADER({2!},{TSTOR},{$+2})
	POP	BX	;ADDR
	POP	AX	;MSW
	MOV	[BX],AX
	POP	AX	;LSW
	MOV	[2+BX],AX
	JMP	NEXT
;
HEADER({L@},{LFET},{$+2})
	POP	BX	;MEM LOC
	POP	CX	;SEG REG VAL
	MOV	DX,DS
	MOV	DS,CX
	MOV	AX,[BX]
	MOV	DS,DX
	JMP	APUSH
;
HEADER({L!},{LSTORE},{$+2})
	POP	BX
	POP	CX
	MOV	DX,DS
	MOV	DS,CX
	POP	AX
	MOV	[BX],AX
	MOV	DS,DX
	JMP	NEXT
	PAGE
	; At line     LINE ~1000
;
HEADER({:},{COLON},{DOCOL},1)
	DW	QEXEC
	DW	SCSP
	DW	CURR
	DW	FETCH
	DW	CONT
	DW	STORE
	DW	CREAT
	DW	RBRAC
	DW	PSCOD
DOCOL:	INC	DX	;W=W+1
	DEC	BP
	DEC	BP	;(RP) <- (RP)-2
	MOV	[BP],SI	;R1 <- (RP)
	MOV	SI,DX	;(IP) <- (W)
	JMP	NEXT
;
HEADER({;},{SEMI},{DOCOL},1)
	DW	QCSP
	DW	COMP
	DW	SEMIS
	DW	SMUDG
	DW	LBRAC
	DW	SEMIS
	PAGE
HEADER({CONSTANT},{CON},{DOCOL})
	DW	CREAT
	DW	SMUDG
	DW	COMMA
	DW	PSCOD
DOCON:	INC	DX	;PFA
	MOV	BX,DX
	MOV	AX,[BX]	;GET DATA
	JMP	APUSH
;
HEADER({VARIABLE},{VAR},{DOCOL})
	DW	CON
	DW	PSCOD
DOVAR:	INC	DX	;(DE) <- PFA
	PUSH	DX
	JMP	NEXT
;
HEADER({USER},{USER},{DOCOL})
	DW	CON
	DW	PSCOD
DOUSE:	INC	DX	;PFA
	MOV	BX,DX
	MOV	BL,[BX]
	SUB	BH,BH
	MOV	DI,[UP]   ;USER VAR ADDRESS
	LEA	AX,[BX+DI]	;ADDR OF VARIABLE
	JMP	APUSH
	PAGE
HEADER({0},{ZERO},{$+2})
	XOR	AX,AX
	JMP	APUSH
;
HEADER({1},{ONE},{$+2})
	MOV	AX,1
	JMP	APUSH
;
HEADER({2},{TWO},{$+2})
	MOV	AX,2
	JMP	APUSH
;
HEADER({3},{THREE},{$+2})
	MOV	AX,3
	JMP	APUSH
;
HEADER({BL},{BLS},{DOCON})
;	THIS IS ONLY A SPAC
	DW	20H
;
HEADER({C/L},{CSLL},{DOCON})
	DW	64
;
HEADER({FIRST},{FIRST},{DOCON})
	DW	BUF1
;
HEADER({LIMIT},{LIMIT},{DOCON})
	DW	EM
;
HEADER({B/BUF},{BBUF},{DOCON})
	DW	KBBUF
;
HEADER({B/SCR},{BSCR},{DOCON})
	DW	400H/KBBUF
;
HEADER({+ORIGIN},{PORIG},{DOCOL})
	DW	LIT
	DW	ORIG
	DW	PLUS
	DW	SEMIS
	PAGE
;
; The following user variables are intialised 
; with the values from USINI.
; Their numbers (6..16H) are fixed.
HEADER({S0},{SZERO},{DOUSE})
	DW	6
;
HEADER({R0},{RZERO},{DOUSE})
	DW	8
;
HEADER({TIB},{TIB},{DOUSE})
	DW	0AH
;
HEADER({WIDTH},{WIDTHE},{DOUSE})
	DW	0CH
;
HEADER({WARNING},{WARN},{DOUSE})
	DW	0EH
;
HEADER({FENCE},{FENCE},{DOUSE})
	DW	10H
;
HEADER({DP},{LDP},{DOUSE})
	DW	12H
;

HEADER({VOC-LINK},{VOCL},{DOUSE})
	DW	14H
; End of user variables with fixed place.
HEADER({BLK},{BLK},{DOUSE})
	DW	16H
;
	PAGE
HEADER({IN},{LIN},{DOUSE})
	DW	18H
;
HEADER({OUT},{LOUT},{DOUSE})
	DW	1AH
;
HEADER({SCR},{SCR},{DOUSE})
	DW	1CH
;
HEADER({OFFSET},{OFSET},{DOUSE})
	DW	0
;
HEADER({CONTEXT},{CONT},{DOUSE})
	DW	20H
;
HEADER({CURRENT},{CURR},{DOUSE})
	DW	22H
;
HEADER({STATE},{STATE},{DOUSE})
	DW	24H
;
HEADER({BASE},{BASE},{DOUSE})
	DW	26H
;
HEADER({DPL},{DPL},{DOUSE})
	DW	28H
;
HEADER({FLD},{LFLD},{DOUSE})
	DW	2AH
;
HEADER({CSP},{LCSP},{DOUSE})
	DW	2CH
;
HEADER({R#},{RNUM},{DOUSE})
	DW	2EH
;
HEADER({HLD},{HLD},{DOUSE})
	DW	30H
;
;========== END USER VARIABLES =============;
	PAGE
HEADER({1+},{ONEP},{$+2})
	POP	AX
	INC	AX
	JMP	APUSH
;
HEADER({2+},{TWOP},{$+2})
	POP	AX
	ADD	AX,2
	JMP	APUSH
;
HEADER({HERE},{HERE},{DOCOL})
	DW	LDP
	DW	FETCH
	DW	SEMIS
;
HEADER({ALLOT},{ALLOT},{DOCOL})
	DW	LDP
	DW	PSTOR
	DW	SEMIS
;
HEADER({,},{COMMA},{DOCOL})
	DW	HERE
	DW	STORE
	DW	TWO
	DW	ALLOT
	DW	SEMIS
;
HEADER({C,},{CCOMM},{DOCOL})
	DW	HERE
	DW	CSTOR
	DW	ONE
	DW	ALLOT
	DW	SEMIS
;
HEADER({-},{LSUB},{$+2})
	POP	DX	;S1
	POP	AX
	SUB	AX,DX
	JMP	APUSH	;S1 = S2 - S1
;
HEADER({=},{EQUAL},{DOCOL})
	DW	LSUB
	DW	ZEQU
	DW	SEMIS
;
HEADER({<},{LESS},{$+2})
	POP	DX	;S1
	POP	AX	;S2
	MOV	BX,DX
	XOR	BX,AX	;TEST FOR EQUAL SIGNS
	JS	LES1	;SIGNS ARE NOT THE SAME
	SUB	AX,DX
LES1:	OR	AX,AX	;TEST SIGN BIT
	MOV	AX,0	;ASSUME FALSE
	JNS	LES2	;NOT LESS THAN
	INC	AX	;TRUE (1)
LES2:	JMP	APUSH
;
HEADER({U<},{ULESS},{DOCOL})
        DW      TDUP
	DW	LXOR,ZLESS
	_0BRANCH(ULES1) ;IF
	DW	DROP,ZLESS
	DW	ZEQU
	_BRANCH(ULES2) 
ULES1	DW	LSUB,ZLESS      ;ELSE
ULES2	DW	SEMIS		;ENDIF
;
HEADER({>},{GREAT},{DOCOL})
	DW	SWAP
	DW	LESS
	DW	SEMIS
;
HEADER({ROT},{ROT},{$+2})
	POP	DX	;S1
	POP	BX	;S2
	POP	AX	;S3
	PUSH	BX
	JMP	DPUSH
;
HEADER({SPACE},{SPACE},{DOCOL})
	DW	BLS
	DW	EMIT
	DW	SEMIS
;
HEADER({-DUP},{DDUP},{DOCOL})
	DW	DUPE
	_0BRANCH(DDUP1) ; IF
	DW	DUPE	;ENDIF
DDUP1	DW	SEMIS
;
HEADER({TRAVERSE},{TRAV},{DOCOL})
	DW	SWAP
TRAV1	DW	OVER	;BEGIN
	DW	PLUS
	DW	LIT,7FH
	DW	OVER
	DW	CFET
	DW	LESS
	_0BRANCH(TRAV1) ;UNTIL
	DW	SWAP
	DW	DROP
	DW	SEMIS
;
HEADER({LATEST},{LATES},{DOCOL})
	DW	CURR
	DW	FETCH
	DW	FETCH
	DW	SEMIS
;
HEADER({LFA},{LFA},{DOCOL})
	DW	LIT,4
	DW	LSUB
	DW	SEMIS
;
HEADER({CFA},{CFA},{DOCOL})
	DW	TWO
	DW	LSUB
	DW	SEMIS
;
HEADER({NFA},{NFA},{DOCOL})
	DW	LIT,5
	DW	LSUB
	DW	LIT,0FFFFH
	DW	TRAV
	DW	SEMIS
;
HEADER({PFA},{PFA},{DOCOL})
	DW	ONE
	DW	TRAV
	DW	LIT,5
	DW	PLUS
	DW	SEMIS
	PAGE
	; At line     LINE ~1500
HEADER({!CSP},{SCSP},{DOCOL})
	DW	SPFET
	DW	LCSP
	DW	STORE
	DW	SEMIS
;
HEADER({?ERROR},{QERR},{DOCOL})
	DW	SWAP
	_0BRANCH(QERR1) ;IF
	DW	ERROR
	_BRANCH(QERR2)  ;ELSE
QERR1	DW	DROP	;ENDIF
QERR2	DW	SEMIS
;
HEADER({?COMP},{QCOMP},{DOCOL})
	DW	STATE
	DW	FETCH
	DW	ZEQU
	DW	LIT,11H
	DW	QERR
	DW	SEMIS
	PAGE
HEADER({?EXEC},{QEXEC},{DOCOL})
	DW	STATE
	DW	FETCH
	DW	LIT,12H
	DW	QERR
	DW	SEMIS
;
HEADER({?PAIRS},{QPAIR},{DOCOL})
	DW	LSUB
	DW	LIT,13H
	DW	QERR
	DW	SEMIS
;
HEADER({?CSP},{QCSP},{DOCOL})
	DW	SPFET
	DW	LCSP
	DW	FETCH
	DW	LSUB
	DW	LIT,14H
	DW	QERR
	DW	SEMIS
;
HEADER({?LOADING},{QLOAD},{DOCOL})
	DW	BLK
	DW	FETCH
	DW	ZEQU
	DW	LIT,16H
	DW	QERR
	DW	SEMIS
	PAGE
HEADER({COMPILE},{COMP},{DOCOL})
	DW	QCOMP
	DW	FROMR
	DW	DUPE
	DW	TWOP
	DW	TOR
	DW	FETCH
	DW	COMMA
	DW	SEMIS
;
HEADER({[},{LBRAC},{DOCOL},1)
	DW	ZERO
	DW	STATE
	DW	STORE
	DW	SEMIS
;
HEADER({]},{RBRAC},{DOCOL})
	DW	LIT,0C0H
	DW	STATE
	DW	STORE
	DW	SEMIS
	PAGE
HEADER({SMUDGE},{SMUDG},{DOCOL})
	DW	LATES
	DW	LIT,20H
	DW	TOGGL
	DW	SEMIS
;
HEADER({HEX},{HEX},{DOCOL})
	DW	LIT,16
	DW	BASE
	DW	STORE
	DW	SEMIS
;
HEADER({DECIMAL},{DECA},{DOCOL})
	DW	LIT,10               
	DW	BASE
	DW	STORE
	DW	SEMIS
;
HEADER({(;CODE)},{PSCOD},{DOCOL})
	DW	FROMR
	DW	LATES
	DW	PFA
	DW	CFA
	DW	STORE
	DW	SEMIS
;
HEADER({;CODE},{SEMIC},{DOCOL},1)
	DW	QCSP
	DW	COMP
	DW	PSCOD
	DW	LBRAC
SEMI1	DW	NOOP	; ( ASSEMBLER )
	DW	SEMIS
;
HEADER({<BUILDS},{BUILD},{DOCOL})
	DW	ZERO
	DW	CON
	DW	SEMIS
;
HEADER({DOES>},{DOES},{DOCOL})
	DW	FROMR
	DW	LATES
	DW	PFA
	DW	STORE
	DW	PSCOD
DODOE:	XCHG	BP,SP	;GET RETURN STACK
	PUSH	SI	; (RP) <- (IP)
	XCHG	BP,SP
	INC	DX	;PFA
	MOV	BX,DX
	MOV	SI,[BX]	;NEW CFA
	INC	DX
	INC	DX
	PUSH	DX	;PFA
	JMP	NEXT
;
HEADER({COUNT},{COUNT},{DOCOL})
	DW	DUPE
	DW	ONEP
	DW	SWAP
	DW	CFET
	DW	SEMIS
;
HEADER({-TRAILING},{DTRAI},{DOCOL})
	DW	DUPE
	DW	ZERO
	DW	XDO	;DO
DTRA1	DW	OVER
	DW	OVER
	DW	PLUS
	DW	ONE
	DW	LSUB
	DW	CFET
	DW	BLS
	DW	LSUB
	_0BRANCH(DTRA2) ;IF
	DW	LLEAV
	_BRANCH(DTRA3)  ; ELSE
DTRA2	DW	ONE
	DW	LSUB    ; ENDIF
DTRA3	_LOOP(DTRA1)    ; LOOP
	DW	SEMIS
	PAGE
	; At line     LINE ~2000
HEADER_SGQ({(.")},{PDOTQ},{DOCOL})
	DW	RR
	DW	COUNT
	DW	DUPE
	DW	ONEP
	DW	FROMR
	DW	PLUS
	DW	TOR
	DW	TYPES
	DW	SEMIS
;
HEADER_SGQ({."},{DOTQ},{DOCOL},1)
	DW	LIT,22H
	DW	STATE
	DW	FETCH
	_0BRANCH(DOTQ1) ; IF
	DW	COMP
	DW	PDOTQ
	DW	WORDS
	DW	HERE
	DW	CFET
	DW	ONEP
	DW	ALLOT
	_BRANCH(DOTQ2)  ; ELSE
DOTQ1	DW	WORDS
	DW	HERE
	DW	COUNT
	DW	TYPES	; ENDIF
DOTQ2	DW	SEMIS
	PAGE
HEADER({QUERY},{QUERY},{DOCOL})
	DW	TIB
	DW	FETCH
	DW	LIT,50H
	DW	EXPEC
	DW	ZERO
	DW	LIN
	DW	STORE
	DW	SEMIS
	PAGE
HEADER_NULL({(NULL)},{NULL},{DOCOL})
;       Special header putting an ASCII NULL in the dictionary.
	DW	BLK
	DW	FETCH
	_0BRANCH(NULL1) ; IF
	DW	ONE
	DW	BLK
	DW	PSTOR
	DW	ZERO
	DW	LIN
	DW	STORE
	DW	BLK
	DW	FETCH
	DW	BSCR
	DW	ONE
	DW	LSUB
	DW	LAND
	DW	ZEQU
	_0BRANCH(NULL2) ; IF
	DW	QEXEC
	DW	FROMR
	DW	DROP	; ENDIF
NULL2	_BRANCH(NULL3)  ; ELSE
NULL1	DW	FROMR
	DW	DROP	; ENDIF
NULL3	DW	SEMIS
;
HEADER({FILL},{FILL},{$+2})
	POP	AX	; FILL CHAR
	POP	CX	; FILL COUNT
	POP	DI	; BEGIN ADDR
	MOV	BX,DS
	MOV	ES,BX	; ES <- DS
	CLD		; INC DIRECTION
	REP	STOSB	;STORE BYTE
	JMP	NEXT
;
HEADER({ERASE},{ERASEE},{DOCOL})
	DW	ZERO
	DW	FILL
	DW	SEMIS
;
HEADER({BLANKS},{BLANK},{DOCOL})
	DW	BLS
	DW	FILL
	DW	SEMIS
;
HEADER({HOLD},{HOLD},{DOCOL})
	DW	LIT,-1
	DW	HLD
	DW	PSTOR
	DW	HLD
	DW	FETCH
	DW	CSTOR
	DW	SEMIS
;
HEADER({PAD},{PAD},{DOCOL})
	DW	HERE
	DW	LIT,84
	DW	PLUS
	DW	SEMIS
;
HEADER({WORD},{WORDS},{DOCOL})
	DW	BLK
	DW	FETCH
	_0BRANCH(WORD1) ; IF
	DW	BLK
	DW	FETCH
	DW	BLOCK
	_BRANCH(WORD2)  ; ELSE
WORD1	DW	TIB
	DW	FETCH      ; ENDIF
WORD2	DW	LIN
	DW	FETCH
	DW	PLUS
	DW	SWAP
	DW	ENCL
	DW	HERE
	DW	LIT,22H
	DW	BLANK
	DW	LIN
	DW	PSTOR
	DW	OVER
	DW	LSUB
	DW	TOR
	DW	RR
	DW	HERE
	DW	CSTOR
	DW	PLUS
	DW	HERE
	DW	ONEP
	DW	FROMR
	DW	LCMOVE
	DW	SEMIS
	PAGE
HEADER({(NUMBER)},{PNUMB},{DOCOL})
PNUM1	DW	ONEP	; BEGIN
	DW	DUPE
	DW	TOR
	DW	CFET
	DW	BASE
	DW	FETCH
	DW	DIGIT
	_0BRANCH(PNUM2) ; WHILE
	DW	SWAP
	DW	BASE
	DW	FETCH
	DW	USTAR
	DW	DROP
	DW	ROT
	DW	BASE
	DW	FETCH
	DW	USTAR
	DW	DPLUS
	DW	DPL
	DW	FETCH
	DW	ONEP
	_0BRANCH(PNUM3) ; IF
	DW	ONE
	DW	DPL
	DW	PSTOR	; ENDIF
PNUM3	DW	FROMR
	_BRANCH(PNUM1)  ; REPEAT
PNUM2	DW	FROMR
	DW	SEMIS
	PAGE
HEADER({NUMBER},{NUMB},{DOCOL})
	DW	ZERO
	DW	ZERO
	DW	ROT
	DW	DUPE
	DW	ONEP
	DW	CFET
	DW	LIT,2DH
	DW	EQUAL
	DW	DUPE
	DW	TOR
	DW	PLUS
	DW	LIT,-1
NUMB1	DW	DPL	; BEGIN
	DW	STORE
	DW	PNUMB
	DW	DUPE
	DW	CFET
	DW	BLS
	DW	LSUB
	_0BRANCH(NUMB2) ; WHILE
	DW	DUPE
	DW	CFET
	DW	LIT,2EH
	DW	LSUB
	DW	ZERO
	DW	QERR
	DW	ZERO
	_BRANCH(NUMB1)  ; REPEAT
NUMB2	DW	DROP
	DW	FROMR
	_0BRANCH(NUMB3) ; IF
	DW	DMINU	; ENDIF
NUMB3	DW	SEMIS
	PAGE
HEADER({-FIND},{DFIND},{DOCOL})
	DW	BLS
	DW	WORDS
	DW	HERE
	DW	CONT
	DW	FETCH
	DW	FETCH
	DW	PFIND
	DW	DUPE
	DW	ZEQU
	_0BRANCH(DFIN1) ;IF
	DW	DROP
	DW	HERE
	DW	LATES
	DW	PFIND	;ENDIF
DFIN1	DW	SEMIS
;
HEADER({(ABORT)},{PABOR},{DOCOL})
	DW	ABORT
	DW	SEMIS
;
HEADER({ERROR},{ERROR},{DOCOL})
	DW	WARN
	DW	FETCH
	DW	ZLESS
	_0BRANCH(ERRO1) ;IF
	DW	PABOR	;ENDIF
ERRO1	DW	HERE
	DW	COUNT
	DW	TYPES
	DW	PDOTQ
	DB	2
	DB	'? '
	DW	MESS
	DW	SPSTO
;
;	CHANGE FROM FIG MODEL
;	DW LIN,FETCH,BLK,FETCH
;
	DW	BLK,FETCH
	DW	DDUP
	_0BRANCH(ERRO2) ; IF
	DW	LIN,FETCH
	DW	SWAP	;ENDIF
ERRO2	DW	QUIT
;
HEADER({ID.},{IDDOT},{DOCOL})
	DW	PAD
	DW	LIT,20H
	DW	LIT,5FH
	DW	FILL
	DW	DUPE
	DW	PFA
	DW	LFA
	DW	OVER
	DW	LSUB
	DW	PAD
	DW	SWAP
	DW	LCMOVE
	DW	PAD
	DW	COUNT
	DW	LIT,1FH
	DW	LAND
	DW	TYPES
	DW	SPACE
	DW	SEMIS
	PAGE
HEADER({CREATE},{CREAT},{DOCOL})
	DW	DFIND
	_0BRANCH(CREA1) ;IF
	DW	DROP
	DW	NFA
	DW	IDDOT
	DW	LIT,4
	DW	MESS
	DW	SPACE	;ENDIF
CREA1	DW	HERE
	DW	DUPE
	DW	CFET
	DW	WIDTHE
	DW	FETCH
	DW	MIN
	DW	ONEP
	DW	ALLOT
	DW	DUPE
	DW	LIT,0A0H
	DW	TOGGL
	DW	HERE
	DW	ONE
	DW	LSUB
	DW	LIT,80H
	DW	TOGGL
	DW	LATES
	DW	COMMA
	DW	CURR
	DW	FETCH
	DW	STORE
	DW	HERE
	DW	TWOP
	DW	COMMA
	DW	SEMIS
	PAGE
HEADER({[COMPILE]},{BCOMP},{DOCOL},1)
	DW	DFIND
	DW	ZEQU
	DW	ZERO
	DW	QERR
	DW	DROP
	DW	CFA
	DW	COMMA
	DW	SEMIS
;
HEADER({LITERAL},{LITER},{DOCOL},1)
	DW	STATE
	DW	FETCH
	_0BRANCH(LITE1) ;IF
	DW	COMP
	DW	LIT
	DW	COMMA	;ENDIF
LITE1	DW	SEMIS
	PAGE
;
HEADER({DLITERAL},{DLITE},{DOCOL},1)
	DW	STATE
	DW	FETCH
	_0BRANCH(DLIT1) ; IF
	DW	SWAP
	DW	LITER
	DW	LITER	; ENDIF
DLIT1	DW	SEMIS
;
HEADER({?STACK},{QSTAC},{DOCOL})
	DW	SPFET
	DW	SZERO
	DW	FETCH
	DW	SWAP
	DW	ULESS
	DW	ONE
	DW	QERR
	DW	SPFET
	DW	HERE
	DW	LIT,80H
	DW	PLUS
	DW	ULESS
	DW	LIT,7
	DW	QERR
	DW	SEMIS
	PAGE
	; At line     LINE ~2500
HEADER({INTERPRET},{INTER},{DOCOL})
INTE1	DW	DFIND	;BEGIN
	_0BRANCH(INTE2) ;IF
	DW	STATE
	DW	FETCH
	DW	LESS
	_0BRANCH(INTE3) ;IF
	DW	CFA
	DW	COMMA
	_BRANCH(INTE4)  ;ELSE
INTE3	DW	CFA
	DW	EXEC	;ENDIF
INTE4	DW	QSTAC
	_BRANCH(INTE5)  ;ELSE
INTE2	DW	HERE
	DW	NUMB
	DW	DPL
	DW	FETCH
	DW	ONEP
	_0BRANCH(INTE6) ;IF
	DW	DLITE
	_BRANCH(INTE7)  ;ELSE
INTE6	DW	DROP
	DW	LITER	;ENDIF
INTE7	DW	QSTAC	;ENDIF
INTE5	_BRANCH(INTE1)  ;AGAIN
	PAGE
HEADER({IMMEDIATE},{IMMED},{DOCOL})
	DW	LATES
	DW	LIT,40H
	DW	TOGGL
	DW	SEMIS
;
HEADER({VOCABULARY},{VOCAB},{DOCOL})
	DW	BUILD
	DW	LIT
	DW	0A081H
	DW	COMMA
	DW	CURR
	DW	FETCH
	DW	CFA
	DW	COMMA
	DW	HERE
	DW	VOCL
	DW	FETCH
	DW	COMMA
	DW	VOCL
	DW	STORE
	DW	DOES
DOVOC	DW	TWOP
	DW	CONT
	DW	STORE
	DW	SEMIS
	PAGE
;
;   THE LINKFIELD OF TASK IS A COLD START VALUE ONLY.
;   IT IS CHANGED EACH TIME A DEFINITION IS
;   APPENDED TO THE 'FORTH' VOCABULARY.
;
HEADER({FORTH},{FORTH},{DODOE},1)
	DW	DOVOC
	DW	0A081H
	DW	_LINK_FIELD(TASK)
	DW	0	; END OF VOCABULARY LIST
;
HEADER({DEFINITIONS},{DEFIN},{DOCOL})
	DW	CONT
	DW	FETCH
	DW	CURR
	DW	STORE
	DW	SEMIS
;
HEADER({(},{PAREN},{DOCOL},1)
	DW	LIT,')'
	DW	WORDS
	DW	SEMIS
	PAGE
HEADER({QUIT},{QUIT},{DOCOL})
	DW	ZERO
	DW	BLK
	DW	STORE
	DW	LBRAC
QUIT1	DW	RPSTO	;BEGIN
	DW	CR
	DW	QUERY
	DW	INTER
	DW	STATE
	DW	FETCH
	DW	ZEQU
	_0BRANCH(QUIT2) ;IF
	DW	PDOTQ
	DB	2
	DB	'OK'	;ENDIF
QUIT2	_BRANCH(QUIT1)  ;AGAIN
;
HEADER({ABORT},{ABORT},{DOCOL})
	DW	SPSTO
	DW	DECA
	DW	QSTAC	; IT DID TO & INCL THIS
	DW	CR
	DW	DOTCPU
	DW	PDOTQ
	DB	20
	DB	'IBM-PC Fig-Forth '
	DB	FIGREL+30H,ADOT,FIGREV+30H
	DW	FORTH
	DW	DEFIN
	DW	QUIT
	PAGE
;	WARM START VECTOR COMES HERE
;
WRM:	MOV	SI,_OFFSET WRM1
	JMP	NEXT
;
WRM1	DW	WARM
;
HEADER({WARM},{WARM},{DOCOL})
	DW	MTBUF
	DW	ABORT
;
;	COLD START VECTOR COMES HERE
;
LCLD:    MOV     SI,_OFFSET CLD1  ; (IP) <-
	MOV	AX,0
	MOV	DS,AX		;TO VECTOR AREA
	MOV	BX,08CH
	LEA	AX,[WRM]
	MOV	[BX],AX		;JUMP TO WRM ON <CTRL-BREAK>
	INC	BX
	INC	BX
	MOV	[BX],CS
	MOV	AX,CS
	MOV	DS,AX		; SET DATA SEG
	MOV	SP,_WORD_PTR[USINI]    ;PARAM. STACK
	MOV	SS,AX		; SET STACK SEGMENT
	MOV	ES,AX		; SET EXTRA SEG
	CLD			; DIR = INC
	MOV	BP,[RPP]          ; RETURN STACK
	JMP	NEXT
;
CLD1	DW	COLD
;
HEADER({COLD},{COLD},{DOCOL})
	DW	MTBUF
	DW	FIRST
	DW	USE,STORE
	DW	FIRST
	DW	PREV,STORE
        DW      ZERO, OFSET,STORE
	DW	LIT, USINI   
	DW	LIT,UP
	DW	FETCH
	DW	LIT,6
	DW	PLUS
	DW	LIT,10H
	DW	LCMOVE
	DW	LIT,LAINI
	DW	FETCH
	DW	LIT,_VOC_LATEST(FORTH)
	DW	STORE
	DW	ABORT
	PAGE
HEADER({S->D},{STOD},{$+2})
	POP	DX	;S1
	SUB	AX,AX
	OR	DX,DX
	JNS	STOD1	;POS
	DEC	AX	;NEG
STOD1:	JMP	DPUSH
;
HEADER({+-},{PM},{DOCOL})
	DW	ZLESS
	_0BRANCH(PM1)   ;IF
	DW	MINUS	;ENDIF
PM1	DW	SEMIS
;
HEADER({D+-},{DPM},{DOCOL})
	DW	ZLESS
	_0BRANCH(DPM1)  ;IF
	DW	DMINU	;ENDIF
DPM1	DW	SEMIS
;
HEADER({ABS},{LABS},{DOCOL})
	DW	DUPE
	DW	PM
	DW	SEMIS
;
HEADER({DABS},{DABS},{DOCOL})
	DW	DUPE
	DW	DPM
	DW	SEMIS
;
HEADER({MIN},{MIN},{DOCOL})
        DW      TDUP
	DW	GREAT
	_0BRANCH(MIN1)  ;IF
	DW	SWAP	;ENDIF
MIN1	DW	DROP
	DW	SEMIS
;
HEADER({MAX},{MAX},{DOCOL})
        DW      TDUP
	DW	LESS
	_0BRANCH(MAX1)  ;IF
	DW	SWAP	;ENDIF
MAX1	DW	DROP
	DW	SEMIS
	PAGE
HEADER({M*},{MSTAR},{DOCOL})
        DW      TDUP
	DW	LXOR       
	DW	TOR
	DW	LABS
	DW	SWAP
	DW	LABS
	DW	USTAR
	DW	FROMR
	DW	DPM
	DW	SEMIS
;
HEADER({M/},{MSLAS},{DOCOL})
	DW	OVER
	DW	TOR
	DW	TOR
	DW	DABS
	DW	RR
	DW	LABS
	DW	USLAS
	DW	FROMR
	DW	RR
	DW	LXOR
	DW	PM
	DW	SWAP
	DW	FROMR
	DW	PM
	DW	SWAP
	DW	SEMIS
;
HEADER({*},{STAR},{DOCOL})
	DW	MSTAR
	DW	DROP
	DW	SEMIS
;
HEADER({/MOD},{SLMOD},{DOCOL})
	DW	TOR
	DW	STOD
	DW	FROMR
	DW	MSLAS
	DW	SEMIS
;
HEADER({/},{SLASH},{DOCOL})
	DW	SLMOD
	DW	SWAP
	DW	DROP
	DW	SEMIS
;
HEADER({MOD},{MODD},{DOCOL})
	DW	SLMOD
	DW	DROP
	DW	SEMIS
;
HEADER({*/MOD},{SSMOD},{DOCOL})
	DW	TOR
	DW	MSTAR
	DW	FROMR
	DW	MSLAS
	DW	SEMIS
;
HEADER({*/},{SSLA},{DOCOL})
	DW	SSMOD
	DW	SWAP
	DW	DROP
	DW	SEMIS
;
HEADER({M/MOD},{MSMOD},{DOCOL})
	DW	TOR
	DW	ZERO
	DW	RR
	DW	USLAS
	DW	FROMR
	DW	SWAP
	DW	TOR
	DW	USLAS
	DW	FROMR
	DW	SEMIS
	PAGE
HEADER({(LINE)},{PLINE},{DOCOL})
	DW	TOR
	DW	LIT,64
	DW	BBUF
	DW	SSMOD
	DW	FROMR
	DW	BSCR
	DW	STAR
	DW	PLUS
	DW	BLOCK
	DW	PLUS
	DW	LIT,64
	DW	SEMIS
;
HEADER({.LINE},{DLINE},{DOCOL})
	DW	PLINE
	DW	DTRAI
	DW	TYPES
	DW	SEMIS
;
HEADER({MESSAGE},{MESS},{DOCOL})
	DW	WARN
	DW	FETCH
	_0BRANCH(MESS1) ;IF
	DW	DDUP
	_0BRANCH(MESS2) ;IF
	DW	LIT,4
	DW	OFSET
	DW	FETCH
	DW	BSCR
	DW	SLASH
	DW	LSUB
	DW	DLINE
	DW	SPACE	;ENDIF
MESS2	_BRANCH(MESS3)  ;ELSE
MESS1	DW	PDOTQ
	DB	6
	DB	'MSG # '
	DW	DOT	;ENDIF
MESS3	DW	SEMIS
	PAGE
	; At line     LINE ~3000
;--------------------------------------------
;
;	8086/88 PORT FETCH AND STORE
;
;--------------------------------------------
;
HEADER({PC@},{PCFET},{$+2})
; FETCH CHARACTER (BYTE) FROM PORT
	POP	DX	; PORT ADDR
	IN	AL,DX	; BYTE INPUT
	SUB	AH,AH
	JMP	APUSH
;
HEADER({PC!},{PCSTO},{$+2})
; STORE CHARACTER (BYTE) AT PORT
	POP	DX	;PORT ADDR
	POP	AX	;DATA
	OUT	DX,AL	; BYTE OUTPUT
	JMP	NEXT
;
HEADER({P@},{PFET},{$+2})
; FETCH WORD FROM PORT
	POP	DX	;PORT ADDR
	IN	AX,DX	;WORD INPUT
	JMP	APUSH
;
HEADER({P!},{PSTO},{$+2})
; STORE WORD AT PORT
	POP	DX	;PORT ADDR
	POP	AX	;DATA
	OUT	DX,AX	;WORD OUTPUT
	JMP	NEXT
;
HEADER({USE},{USE},{DOVAR})
        ;ADDR OF NEXT BUFR TO USE
	DW BUF1
;
HEADER({PREV},{PREV},{DOVAR})
;       ;ADDR OF PREV USED BUFR
	DW	BUF1
        PAGE
HEADER({#BUFF},{NOBUF},{DOCON})
        ;NO. OF BUFFERS
        DW      NBUF
;
HEADER({+BUF},{PBUF},{DOCOL})
	DW	LIT,CO
	DW	PLUS,DUPE
	DW	LIMIT,EQUAL
	_0BRANCH(PBUF1) 
	DW	DROP,FIRST
PBUF1	DW	DUPE,PREV
	DW	FETCH,LSUB
	DW	SEMIS
;
HEADER({UPDATE},{UPDAT},{DOCOL})
        DW      PREV
	DW	FETCH,FETCH
	DW	LIT,8000H
	DW	LOR
	DW	PREV,FETCH
	DW	STORE,SEMIS
;
HEADER({EMPTY-BUFFERS},{MTBUF},{DOCOL})
        DW      FIRST
	DW	LIMIT,OVER
	DW	LSUB,ERASEE
	DW	SEMIS
	PAGE
;
HEADER({BUFFER},{BUFFE},{DOCOL})
; NOTE: THIS WORD WON'T WORK IF ONLY USING SINGLE BUFFER
        DW      USE
	DW	FETCH,DUPE
	DW	TOR
BUFF1	DW	PBUF
	_0BRANCH(BUFF1) 
	DW	USE,STORE
	DW	RR,FETCH
	DW	ZLESS
	_0BRANCH(BUFF2) 
	DW	RR,TWOP
	DW	RR,FETCH
	DW	LIT,7FFFH
	DW	LAND,ZERO
	DW	RSLW
BUFF2	DW	RR,STORE
	DW	RR,PREV
	DW	STORE,FROMR
	DW	TWOP,SEMIS
	PAGE
HEADER({BLOCK},{BLOCK},{DOCOL})
        DW      OFSET
	DW	FETCH,PLUS
	DW	TOR,PREV
	DW	FETCH,DUPE
	DW	FETCH,RR
	DW	LSUB
	DW	DUPE,PLUS
	_0BRANCH(BLOC1) 
BLOC2	DW	PBUF,ZEQU
	_0BRANCH(BLOC3) 
	DW	DROP,RR
	DW	BUFFE,DUPE
	DW	RR,ONE
	DW	RSLW
	DW	TWO,LSUB
BLOC3	DW	DUPE,FETCH
	DW	RR,LSUB
	DW	DUPE,PLUS
	DW	ZEQU
	_0BRANCH(BLOC2) 
	DW	DUPE,PREV
	DW	STORE
BLOC1	DW	FROMR,DROP
	DW	TWOP,SEMIS
	PAGE
HEADER({FLUSH},{FLUSH},{DOCOL})
	DW	NOBUF,ONEP
	DW	ZERO,XDO
FLUS1	DW	ZERO,BUFFE
	DW	DROP
	_LOOP(FLUS1) 
	DW	SEMIS
;
HEADER({LOAD},{LOAD},{DOCOL})
        DW      BLK
	DW	FETCH,TOR
	DW	LIN,FETCH
	DW	TOR,ZERO
	DW	LIN,STORE
	DW	BSCR,STAR
	DW	BLK,STORE	;BLK <- SCR * B/SCR
	DW	INTER	;INTERPRET FROM OTHER
SCREEN	DW	FROMR,LIN
	DW	STORE
	DW	FROMR,BLK
	DW	STORE
	DW	SEMIS
	PAGE
HEADER({-->},{ARROW},{DOCOL},1)
	DW	QLOAD
	DW	ZERO
	DW	LIN
	DW	STORE
	DW	BSCR
	DW	BLK
	DW	FETCH
	DW	OVER
	DW	MODD
	DW	LSUB
	DW	BLK
	DW	PSTOR
	DW	SEMIS
        PAGE
;
; Generic call on BIOS. A boon for experimenters.
; Because there is no such thing as a variable interrupt:
; THIS IS SELF MODIFYING CODE! NOT REENTRANT! DO NOT PUT IN ROM!
; BEWARE OF THE SOFTWARE POLICE!
HEADER({BIOS},{BIOS},{$ + 2})
        POP     AX      ; Function code
        ; Once we are more acknowledgable, put segment overwrite here.
        MOV     _BYTE_PTR([RQBIOS+1]),AL ; Patch the code.
        POP     DX        
        POP     CX      
        POP     BX      
        POP     AX      
	PUSH     SI      ; Save Forth registers. NEEDED? 
	PUSH     BP      
RQBIOS: INT(0)          ; Request number to be overwritten.
	POP	BP	; Restore Forth registers. NEEDED? 
	POP	SI	;INTERPRETER PNTR
        PUSHF      ; Sometimes status is returned into flags!
        PUSH     AX      
        PUSH     BX      
        PUSH     CX      
        PUSH     DX      
        JMP     NEXT    ;
; SELF MODIFYING CODE ENDS HERE! YOU HAVE BEEN WARNED!

; Generic call on MSDOS/MS WIndows2000
; This works in a standalone Forth (if started from MSDOS).
HEADER({BDOS},{BDOS},{$ + 2})
        POP     DX        
        POP     CX      
        POP     BX      
        POP     AX      
        INT(21H)
        PUSH     AX      
        PUSH     BX      
        PUSH     CX      
        PUSH     DX      
        PUSHF      ; Status usually returned into flags!
        JMP     NEXT 

             ; SVGA-modus 43*132 char's
HEADER({SMALL},{SMALL},{DOCOL})
             DW      LIT, 4F02H, LIT, 010AH, ZERO, ZERO
             DW      LIT, 0010H, BIOS
             DW      DROP, DROP, DROP, DROP, DROP, SEMIS
             ;                          ^ MUST BE 4FH
	PAGE    
;------------------------------------
;       SYSTEM DEPENDANT CHAR I/O
;------------------------------------
;____1_____ _MODERN_1_({
; All I/O goes through the modern (unix-borrowed)
; file I/O.    
HEADER({TYPE},{TYPES},{DOCOL})
        DW      DUPE, LOUT, PSTOR
        DW      TOR, TOR
        DW      LIT,04000H ; Write file or device 
	DW      ONE     ; Handle
        DW      FROMR, FROMR, SWAP
        DW      BDOS, DROP ; ignore error 
        DW      DROP, DROP, DROP, DROP
        DW      SEMIS
;
HEADER({EMIT},{EMIT},{DOCOL})      
        DW      DUPE,LIT,LF,EQUAL
        _0BRANCH(EMIT1)
        DW      LIT,ACR,EMIT
        DW      ZERO,LOUT,STORE
EMIT1:  
	DW	SPFET, ONE, TYPES
        DW      DROP
	DW	SEMIS
;
 HEADER({EXPECT},{EXPEC},{DOCOL})
        DW      OVER 
        DW      TOR, TOR
        DW      LIT,03F00H ; Write file or device 
	DW      ZERO     ; Handle
        DW      FROMR, FROMR
        DW      BDOS, DROP ; ignore error 
        DW      DROP, DROP, DROP ; Leave count
        DW      TWO, LSUB ; Rid of 0D0A
        DW      PLUS, ZERO, SWAP, CSTOR
        DW      SEMIS
;
HEADER({KEY},{KEY},{$+2})
        DW      LIT,0800H 
        DW      ZERO,ZERO,ZERO
        DW      BDOS, DROP ; ignore error 
        DW      DROP, DROP, DROP
        DW      LIT, 0FFH, LAND
        DW      SEMIS
;
HEADER({?TERMINAL},{QTERM},{DOCOL})
        DW      LIT,0B00H 
        DW      ZERO,ZERO,ZERO
        DW      BDOS, DROP ; ignore error 
        DW      DROP, DROP, DROP
        DW      LIT, 01H, LAND
        DW      SEMIS
;

});_END___1__({_MODERN_1_})
;____1_____ _USEDOS_1_({
; All I/O goes through the 3 assembler functions
; CI CHO CSTAT. They could be collapsed into the 
; code definitions, but this way they are available
; to be called from code.
HEADER({EXPECT},{EXPEC},{DOCOL})        
	DW	OVER                            
	DW	PLUS                            
	DW	OVER                            
	DW	XDO	; DO                    
EXPE1	DW	KEY                             
	DW	DUPE                            
	DW	LIT,0EH  ; RUBOUT : should be USER variable.
	DW	PORIG                           
	DW	FETCH                           
	DW	EQUAL                           
	_0BRANCH(EXPE2) ; IF                    
	DW	DROP                            
	DW	DUPE                            
	DW	IDO                             
	DW	EQUAL                           
	DW	DUPE                            
	DW	FROMR                           
	DW	TWO                             
	DW	LSUB                            
	DW	PLUS                            
	DW	TOR                             
	_0BRANCH(EXPE6) ; IF                    
	DW	LIT                             
	DW	BELL                            
	_BRANCH(EXPE7)  ; ELSE                  
EXPE6	DW	LIT                             
	DW	BSOUT	; ENDIF                 
EXPE7	_BRANCH(EXPE3)  ; ELSE                  
EXPE2	DW	DUPE                            
	DW	LIT,0DH
	DW	EQUAL
	_0BRANCH(EXPE4) ; IF
	DW	LLEAV
	DW	DROP
	DW	BLS
	DW	ZERO
	_BRANCH(EXPE5)  ; ELSE
EXPE4	DW	DUPE	; ENDIF
EXPE5	DW	IDO
	DW	CSTOR
	DW	ZERO
	DW	IDO
	DW	ONEP
	DW	STORE	; ENDIF
EXPE3	DW	EMIT
	_LOOP(EXPE1) 	; LOOP
	DW	DROP
	DW	SEMIS
;
HEADER({KEY},{KEY},{$+2})
	JMP	PKEY
PKEY:	CALL	CI	;CONSOLE INPUT
        MOV     AH,0    ;MAKE 16 BITS
	JMP	APUSH	;SAVE KEY VALUE
CI	PROC	NEAR
	MOV	AH,0	; READ CHAR FUNCTION
	INT	16H
	RET
_ENDP CI      ENDP
;
HEADER({TYPE},{TYPES},{DOCOL})
	DW	DDUP
	_0BRANCH(TYPE1) ; IF
	DW	OVER
	DW	PLUS
	DW	SWAP
	DW	XDO	; DO
TYPE2	DW	IDO
	DW	CFET
	DW	LIT,7FH
	DW	LAND    ;STRIP 80H FROM LAST CHAR
	DW	EMIT
        _LOOP(TYPE2)    ; LOOP
	_BRANCH(TYPE3)  ; ELSE
TYPE1	DW	DROP	; ENDIF
TYPE3	DW	SEMIS
;
HEADER({EMIT},{EMIT},{DOCOL})
	DW	PEMIT
	DW	ONE,LOUT
	DW	PSTOR,SEMIS
PEMIT	DW	$+2
	POP	AX	;GET CHAR
        CMP     AL,LF   ; Precede ^J with ^M
        JNE     PEMIT1
    	MOV	AL,ACR
	CALL	CHO    
	MOV	AL,LF  
        ; Bizar, without the colon MASM reports error.
PEMIT1: CALL	CHO    ;CHAR OUTPUT
	JMP	NEXT
CHO	PROC	NEAR
	PUSH	DX
	PUSH	AX	;SAVE CHAR
	MOV	DL,AL	;CHAR TO WRITE
	MOV	AH,2	;CHAR OUT FUNCTION
	INT	21H	;DOS
	POP	AX
	POP	DX
	RET
_ENDP CHO     ENDP
;
HEADER({?TERMINAL},{QTERM},{$+2})
	JMP	PQTER
PQTER:	CALL	CSTAT	;TEST FOR KEY
	OR	AL,AL	;ANY KEY?
	JZ	PQTER1	;NO
	MOV	AL,1	;TRUE = CHAR FOUND
PQTER1:	MOV	AH,0	;MAKE 16 BITS
	JMP	APUSH	;SAVE STATUS
;
CSTAT	PROC	NEAR
	PUSH	DX
	MOV	DX,0FFH
	MOV	AX,0600H
	INT	21H
	POP	DX
STATRT: RET
_ENDP CSTAT   ENDP
});_END___1__({_USEDOS_1_})
;____1_____ _USEBIOS_1_({
HEADER({EXPECT},{EXPEC},{DOCOL})        
	DW	OVER                            
	DW	PLUS                            
	DW	OVER                            
	DW	XDO	; DO                    
EXPE1	DW	KEY                             
	DW	DUPE                            
	DW	LIT,0EH  ; RUBOUT : should be USER variable.
	DW	PORIG                           
	DW	FETCH                           
	DW	EQUAL                           
	_0BRANCH(EXPE2) ; IF                    
	DW	DROP                            
	DW	DUPE                            
	DW	IDO                             
	DW	EQUAL                           
	DW	DUPE                            
	DW	FROMR                           
	DW	TWO                             
	DW	LSUB                            
	DW	PLUS                            
	DW	TOR                             
	_0BRANCH(EXPE6) ; IF                    
	DW	LIT                             
	DW	BELL                            
	_BRANCH(EXPE7)  ; ELSE                  
EXPE6	DW	LIT                             
	DW	BSOUT	; ENDIF                 
EXPE7	_BRANCH(EXPE3)  ; ELSE                  
EXPE2	DW	DUPE                            
	DW	LIT,0DH
	DW	EQUAL
	_0BRANCH(EXPE4) ; IF
	DW	LLEAV
	DW	DROP
	DW	BLS
	DW	ZERO
	_BRANCH(EXPE5)  ; ELSE
EXPE4	DW	DUPE	; ENDIF
EXPE5	DW	IDO
	DW	CSTOR
	DW	ZERO
	DW	IDO
	DW	ONEP
	DW	STORE	; ENDIF
EXPE3	DW	EMIT
	_LOOP(EXPE1) 	; LOOP
	DW	DROP
	DW	SEMIS
;
HEADER({KEY},{KEY},{DOCOL})
             DW         LIT, 1000H, ZERO, ZERO, ZERO
             DW         LIT, 0016H, BIOS
             DW         DROP,DROP,DROP,SWAP,DROP
             DW         LIT, 00FFH, LAND, SEMIS

HEADER({TYPE},{TYPES},{DOCOL})
             DW      DDUP
             _0BRANCH(TYPE1)
             DW      OVER,   PLUS
             DW      SWAP,   XDO
TYPE2:       DW      IDO,    CFET,    EMIT
             _LOOP(TYPE2)
             _BRANCH(TYPE3)
TYPE1:       DW      DROP
TYPE3:       DW      SEMIS
;            
HEADER({EMIT},{EMIT},{DOCOL})
             DW      ONE,LOUT,PSTOR
             DW      LIT, 07FH, LAND
             DW      DUPE,LIT,LF,EQUAL
             _0BRANCH(EMIT1)
             DW      LIT,ACR,PEMIT
             DW      ZERO,LOUT,STORE
EMIT1:       DW      PEMIT
             DW      SEMIS
;            
HEADER({(EMIT)},{PEMIT},{DOCOL})
             DW      LIT, 0E00H, PLUS, ZERO, ZERO, ZERO
             DW      LIT, 0010H, BIOS
             DW      DROP, DROP, DROP, DROP, DROP, SEMIS

;
HEADER({?TERMINAL},{QTERM},{DOCOL})
             DW      LIT, 01100H, ZERO, ZERO, ZERO
             DW      LIT, 016H, BIOS, DROP, DROP, DROP, DROP
             DW      LIT, 040H, LAND, ZEQU, SEMIS

             ; Output to PRN 
HEADER({POUT},{POUT},{DOCOL})
             DW      ZERO, ZERO, ZERO
             DW      LIT, 0017H, BIOS
             DW      DROP, DROP, DROP, DROP, DROP, SEMIS
;
});_END___1__({_USEBIOS_1_})
	PAGE
;------------------------------------
;       SYSTEM DEPENDANT DISK I/O
;------------------------------------

;____1_____ _MODERN_1_({
HEADER({BLOCK-FILE},{BLFL},{DOVAR})
        DB      10,"BLOCKS.FRT"
        RESB    20              ; Allow for some path
;
HEADER({BLOCK-HANDLE},{BHAN},{DOVAR})
;
HEADER({DISK-ERR},{DERR},{DOCOL})
        DW      ONE, LAND
        DW      LIT, 21H, QERR
	DW	SEMIS
;
HEADER({BLOCK-INIT},{BLINI},{DOCOL})
        DW      LIT, 03D02H    ; Open file for read/write
        DW      ZERO,ZERO
        DW      BLFL
        DW      COUNT, OVER, PLUS
        DW      ZERO, SWAP, CSTOR  ; Zero ended as required
	DW	BDOS, DERR
        DW      DROP, DROP, DROP
        DW      BHAN, STORE
	DW	SEMIS
;
HEADER({BLOCK-EXIT},{BLEXI},{DOCOL})
        DW      LIT, 03E00H    ; Open file for read/write
        DW      BHAN, FETCH
        DW      ZERO, ZERO
	DW	BDOS, DERR
        DW      DROP, DROP, DROP, DROP
	DW	SEMIS
;
;       Block #, Handle
HEADER({SEEK},{SEEK},{DOCOL})
        DW      SWAP, TOR, TOR
        DW      LIT, 04200      ; Seek from start
        DW      FROMR           ; Handle
        DW      FROMR, LIT, KBBUF, USTAR
        DW      SWAP    ; L.S. ON TOP
	DW	BDOS, DERR
        DW      DROP, DROP, DROP, DROP
        DW      SEMIS
;
;	( ADDR  BLK#  FLAG (0=W, 1=R) --- )
HEADER({R/W},{RSLW},{DOCOL})
	_0BRANCH(RSLW1) 
	DW	LIT, 03F00H     ; Disk read 
	_BRANCH(RSLW2) 
RSLW1	DW      LIT, 04000H     ; Disk write
RSLW2:  DW      TOR 
        DW      BHAN, FETCH, SEEK ; That's done
        DW      FROMR, SWAP, TOR
        DW      BHAN, FETCH
        DW      LIT, KBBUF
        DW      FROMR           ; ADDR
	DW	BDOS, DERR
;       DW      DROP, DROP, DROP, DROP
        DW      DROP, DROP, DROP, DOT
        DW      SEMIS

});_END___1__({_MODERN_1_})
;____1_____ _USEDOS_1_({
;
WERR	DB  	'DISK WRITE ERROR  $'
RERR	DB  	'DISK READ ERROR   $'
;
SBLK    PROC    NEAR
;	( ADDR  BLK# -- )
;	THIS ROUTINE WILL PREPARE PARAMETERS FOR DISK I/O
;       DRIVE, ADDRESS, LENGTH, SEC#
	POP	DI	;SAVE RETURN
	MOV	CX,KBBUF/BPS 
	POP	DX	;BLK #
        MUL     DX,CX   ;SEC #
	MOV	AL,DRIVE    ;SELECT DR A
        POP     BX      ;TRANSFER ADDR
	PUSH	DI	;GET THAT RETURN BACK
	RET
_ENDP SBLK    ENDP
;
HEADER({RBLK},{RBLK},{$+2})
	CALL	SBLK
	PUSH	SI	;PRESERVE INTERPRETER POINTER
	PUSH	BP	;RETURN POINTER
	INT	25H
	JNC	DOK	;NO ERRORS
	LEA	DX,[RERR]
	JMP	DERR
;
HEADER({WBLK},{WBLK},{$+2})
	CALL	SBLK
	PUSH	SI
	PUSH	BP
	INT	26H
	JNC	DOK
	LEA	DX,[WERR]
DERR:	PUSH	AX
	MOV	AH,9	;STRING WRITE FNCN
	INT	21H
	POP	AX	;ERROR CODE IN AX
;  WRITE ERROR MESSAGE HERE
;
DOK:	POPF		;POP FLAGS
	POP	BP	;RETURN STACK
	POP	SI	;INTERPRETER PNTR
	JMP	NEXT
;
;
HEADER({R/W},{RSLW},{DOCOL})
;	( ADDR  BLK#  FLAG (0=W, 1=R) --- )
	_0BRANCH(RSLW1) 
	DW	RBLK
	_BRANCH(RSLW2) 
RSLW1	DW	WBLK
RSLW2	DW	SEMIS
});_END___1__({_USEDOS_1_})
;____1_____ _USEBIOS_1_({
;
HEADER({DRIVE},{DRIVE},{DOVAR})
      DW  0
;
HEADER({RECORD},{REC},{DOVAR})
      DW  0
;
HEADER({SEC/BLK},{SPBLK},{DOCON}) ;# SECTORS/BLOCK
	DW	KBBUF/BPS
;
HEADER({DISK-ERROR},{DSKERR},{DOVAR})
      DW  0

HEADER({T&SCALC},{TSCALC},{DOCOL})
                DW      LIT,    SPDRV, SLMOD
                DW      DRIVE,  STORE
                DW      REC,    STORE,  SEMIS
;
HEADER({BLOCK-READ},{BLKRD},{DOCOL})
                DW      LIT, 0201H, USE, FETCH                ;AL = drive no.
                DW      REC, FETCH, LIT, SPT*HEADS, SLMOD
                DW      SWAP, LIT, SPT, SLMOD, TOR
                DW      SWAP, LIT, 0100H, STAR, PLUS, ONEP
                DW      FROMR, LIT, 0100H, STAR, DRIVE, FETCH, PLUS
                DW      LIT, 13H, BIOS
                DW      DROP, DROP, DROP, DROP
                DW      ONE, LAND, DSKERR, STORE
                DW      SEMIS

HEADER({BLOCK-WRITE},{BLKWRT},{DOCOL})
                DW      LIT, 0301H, USE, FETCH                ;AL = drive no.
                DW      REC, FETCH, LIT, SPT*HEADS, SLMOD
                DW      SWAP, LIT, SPT, SLMOD, TOR
                DW      SWAP, LIT, 0100H, STAR, PLUS, ONEP
                DW      FROMR, LIT, 0100H, STAR, DRIVE, FETCH, PLUS
                DW      LIT, 13H, BIOS
                DW      DROP, DROP, DROP, DROP
                DW      ONE, LAND, DSKERR, STORE
                DW      SEMIS
;
;
HEADER({R/W},{RSLW},{DOCOL})
                DW      USE,    FETCH,     TOR
                DW      TOR
                DW      SWAP,   USE, STORE
                DW      SPBLK,  STAR
                DW      TSCALC
                DW      FROMR
                _0BRANCH(RSLW1)
                DW      BLKRD
                _BRANCH(RSLW2)
RSLW1:          DW      BLKWRT
RSLW2:          DW      FROMR,  USE,    STORE
                DW      DSKERR, FETCH,     DDUP
                _0BRANCH(RSLW5)              ;OK
                DW      ZLESS
                _0BRANCH(RSLW3)
                DW      LIT,    9                       ;Write error
                _BRANCH(RSLW4)
RSLW3:          DW      LIT,    8                       ;Read error
RSLW4:          DW      ZERO,   PREV,   FETCH,     STORE   ;This  buffer
                                                        ; is no good!
                DW      QERR
RSLW5:          DW      SEMIS
;
});_END___1__({_USEBIOS_1_})
	PAGE
	; At line     LINE ~3500
HEADER({'},{TICK},{DOCOL},1)
	DW	DFIND
	DW	ZEQU
	DW	ZERO
	DW	QERR
	DW	DROP
	DW	LITER
	DW	SEMIS
;
HEADER({FORGET},{FORG},{DOCOL})
	DW	CURR
	DW	FETCH
	DW	CONT
	DW	FETCH
	DW	LSUB
	DW	LIT,18H
	DW	QERR
	DW	TICK
	DW	DUPE
	DW	FENCE
	DW	FETCH
	DW	LESS
	DW	LIT,15H
	DW	QERR
	DW	DUPE
	DW	NFA
	DW	LDP
	DW	STORE
	DW	LFA
	DW	FETCH
	DW	CONT
	DW	FETCH
	DW	STORE
	DW	SEMIS
	PAGE
HEADER({BACK},{BACK},{DOCOL})
	DW	HERE
	DW	LSUB
	DW	COMMA
	DW	SEMIS
;
HEADER({BEGIN},{BEGIN},{DOCOL},1)
	DW	QCOMP
	DW	HERE
	DW	ONE
	DW	SEMIS
;
HEADER({ENDIF},{ENDIFF},{DOCOL},1)
	DW	QCOMP
	DW	TWO
	DW	QPAIR
	DW	HERE
	DW	OVER
	DW	LSUB
	DW	SWAP
	DW	STORE
	DW	SEMIS
	PAGE
HEADER({THEN},{THEN},{DOCOL},1)
	DW	ENDIFF
	DW	SEMIS
;
HEADER({DO},{DO},{DOCOL},1)
	DW	COMP
	DW	XDO
	DW	HERE
	DW	THREE
	DW	SEMIS
;
HEADER({LOOP},{LOOPC},{DOCOL},1)
	DW	THREE
	DW	QPAIR
	DW	COMP
	DW	XLOOP
	DW	BACK
	DW	SEMIS
	PAGE
HEADER({+LOOP},{PLOOP},{DOCOL},1)
	DW	THREE
	DW	QPAIR
	DW	COMP
	DW	XPLOO
	DW	BACK
	DW	SEMIS
;
HEADER({UNTIL},{UNTIL},{DOCOL},1)
	DW	ONE
	DW	QPAIR
	DW	COMP
	DW	ZBRAN
	DW      BACK
	DW	SEMIS
;
HEADER({END},{ENDD},{DOCOL},1)
	DW	UNTIL
	DW	SEMIS
	PAGE
HEADER({AGAIN},{AGAIN},{DOCOL},1)
	DW	ONE
	DW	QPAIR
	DW	COMP
	DW	BRAN
	DW      BACK
	DW	SEMIS
;
HEADER({REPEAT},{REPEA},{DOCOL},1)
	DW	TOR
	DW	TOR
	DW	AGAIN
	DW	FROMR
	DW	FROMR
	DW	TWO
	DW	LSUB
	DW	ENDIFF
	DW	SEMIS
;
HEADER({IF},{IFF},{DOCOL},1)
	DW	COMP
	DW	ZBRAN
	DW      HERE
	DW	ZERO
	DW	COMMA
	DW	TWO
	DW	SEMIS
	PAGE
HEADER({ELSE},{ELSEE},{DOCOL},1)
	DW	TWO
	DW	QPAIR
	DW	COMP
	DW	BRAN
	DW      HERE
	DW	ZERO
	DW	COMMA
	DW	SWAP
	DW	TWO
	DW	ENDIFF
	DW	TWO
	DW	SEMIS
;
HEADER({WHILE},{WHILE},{DOCOL},1)
	DW	IFF
	DW	TWOP
	DW	SEMIS
	PAGE
HEADER({SPACES},{SPACS},{DOCOL})
	DW	ZERO
	DW	MAX
	DW	DDUP
	_0BRANCH(SPAX1) 
	DW	ZERO
	DW	XDO	;DO
SPAX2	DW	SPACE
	_LOOP(SPAX2) 	;LOOP
SPAX1	DW	SEMIS
;
HEADER({<#},{BDIGS},{DOCOL})
	DW	PAD
	DW	HLD
	DW	STORE
	DW	SEMIS
;
HEADER({#>},{EDIGS},{DOCOL})
	DW	DROP
	DW	DROP
	DW	HLD
	DW	FETCH
	DW	PAD
	DW	OVER
	DW	LSUB
	DW	SEMIS
	PAGE
HEADER({SIGN},{SIGN},{DOCOL})
	DW	ROT
	DW	ZLESS
	_0BRANCH(SIGN1) ;IF
	DW	LIT,2DH
	DW	HOLD	;ENDIF
SIGN1	DW	SEMIS
;
HEADER({#},{DIG},{DOCOL})
	DW	BASE
	DW	FETCH
	DW	MSMOD
	DW	ROT
	DW	LIT,9
	DW	OVER
	DW	LESS
	_0BRANCH(DIG1)  ;IF
	DW	LIT,7
	DW	PLUS	;ENDIF
DIG1	DW	LIT,30H
	DW	PLUS
	DW	HOLD
	DW	SEMIS
;
HEADER({#S},{DIGS},{DOCOL})
DIGS1	DW	DIG	;BEGIN
	DW	OVER
	DW	OVER
	DW	LOR
	DW	ZEQU
	_0BRANCH(DIGS1) ;UNTIL
	DW	SEMIS
;
HEADER({D.R},{DDOTR},{DOCOL})
	DW	TOR
	DW	SWAP
	DW	OVER
	DW	DABS
	DW	BDIGS
	DW	DIGS
	DW	SIGN
	DW	EDIGS
	DW	FROMR
	DW	OVER
	DW	LSUB
	DW	SPACS
	DW	TYPES
	DW	SEMIS
;
HEADER({.R},{DOTR},{DOCOL})
	DW	TOR
	DW	STOD
	DW	FROMR
	DW	DDOTR
	DW	SEMIS
	PAGE
HEADER({D.},{DDOT},{DOCOL})
	DW	ZERO
	DW	DDOTR
	DW	SPACE
	DW	SEMIS
;
HEADER({.},{DOT},{DOCOL})
	DW	STOD
	DW	DDOT
	DW	SEMIS
;
HEADER({?},{QUES},{DOCOL})
	DW	FETCH
	DW	DOT
	DW	SEMIS
;
HEADER({U.},{UDOT},{DOCOL})
	DW	ZERO
	DW	DDOT
	DW	SEMIS
	PAGE
	; At line     LINE ~4000
HEADER({VLIST},{VLIST},{DOCOL})
	DW	LIT,80H
	DW	LOUT
	DW	STORE
	DW	CONT
	DW	FETCH
	DW	FETCH
VLIS1	DW	LOUT    ;BEGIN
	DW	FETCH
	DW	CSLL
	DW	GREAT
	_0BRANCH(VLIS2) ;IF
	DW	CR
	DW	ZERO
	DW	LOUT
	DW	STORE	;ENDIF
VLIS2	DW	DUPE
	DW	IDDOT
	DW	SPACE
	DW	SPACE
	DW	PFA
	DW	LFA
	DW	FETCH
	DW	DUPE
	DW	ZEQU
	DW	QTERM
	DW	LOR
	_0BRANCH(VLIS1) ;UNTIL
	DW	DROP
	DW	SEMIS
;
HEADER({BYE},{BYE},{$+2})
; EXIT TO PC-DOS
	INT	27H	;I'M HISTORY
	PAGE
HEADER({LIST},{LISTC},{DOCOL})
        DW      DECA
	DW	CR,DUPE
	DW	SCR,STORE
	DW	PDOTQ
	DB	6,'SCR # '
	DW	DOT
	DW	LIT,10H
	DW	ZERO,XDO
LIST1	DW	CR,IDO
	DW	LIT,3
	DW	DOTR,SPACE
	DW	IDO,SCR
	DW	FETCH,DLINE
	DW	QTERM	; ?TERMINAL
	_0BRANCH(LIST2) 
	DW	LLEAV
LIST2	_LOOP(LIST1) 
	DW	CR,SEMIS
;
HEADER({INDEX},{INDEX},{DOCOL})
	DW	LIT,FF
	DW	EMIT,CR
	DW	ONEP,SWAP
	DW	XDO
INDE1	DW	CR,IDO
	DW	LIT,3
	DW	DOTR,SPACE
	DW	ZERO,IDO
	DW	DLINE,QTERM
	_0BRANCH(INDE2) 
	DW	LLEAV
INDE2	_LOOP(INDE1) 
	DW	SEMIS
	PAGE
HEADER({TRIAD},{TRIAD},{DOCOL})
	DW	LIT,FF
	DW	EMIT
	DW	LIT,3
	DW	SLASH
	DW	LIT,3
	DW	STAR
	DW	LIT,3
	DW	OVER,PLUS
	DW	SWAP,XDO
TRIA1	DW	CR,IDO
	DW	LISTC
	DW	QTERM	; ?TERMINAL
	_0BRANCH(TRIA2) 
	DW	LLEAV   ;LEAVE
TRIA2	_LOOP(TRIA1) 	;ENDIF
	DW	CR
	DW	SEMIS
;
HEADER({.CPU},{DOTCPU},{DOCOL})
; PRINT CPU TYPE (8088)
	DW	BASE,FETCH
	DW	LIT,36
	DW	BASE,STORE
	DW	LIT,CPUNM-ORIG,PORIG ; 
	DW	TFET
	DW	DDOT
	DW	BASE,STORE
	DW	SEMIS
	PAGE
_COMMENT 

	    CODE LEVEL "MATCH" DEFINITIONS

 STACK PARAMETERS:

 ( cursor:addr   byte:left   str:addr  str:len
	   ---   flag  new:cursor:offset         )

 This version of MATCH will handle string lengths
      up to 65535 bytes in length.

_ENDCOMMENT
HEADER({MATCH},{MATCH},{$+2})
	MOV	DI,SI	; SAVE IP
	POP	CX	; STRING COUNT
	POP	BX	;STRING ADDR
	POP	DX	;BYTES LEFT TO SEARCH
	POP	SI	;CURSOR ADDR
	PUSH	SI	;SAVE COPY
MAT1:	LODSB		;GET FIRST BYTE
	CMP	AL,[BX]	;MATCH?
	JNZ	MAT3	;NO
	PUSH	BX	;SAVE STRING ADDR
	PUSH	CX	; &   STRING COUNT
	PUSH	SI	; &   CURSOR ADDR
; TRY TO MATCH REMAINING CHARS IN STRING
;
MAT2:	DEC	CX	;STR. COUNT -1
	JZ	MATCHOK	;EXIT - MATCH FOUND
	DEC	DX	;BYTES LEFT -1
	JZ	NOMATCH	;EXIT - NO MATCH
	INC	BX	;NEXT STR CHAR ADDR
	LODSB		;GET FIRST BYTE
	CMP	AL,[BX]	;MATCH?
	JZ	MAT2	;YES, GET MORE
; NO MATCH YET
	POP	SI
	POP	CX
	POP	BX	;RESTORE POINTERS
MAT3:	DEC	DX	;BYTE LEFT COUNT -1
	JNZ	MAT1	;START OVER
	JMP	MAT4	;EXIT...NO MATCH
MATCHOK:
NOMATCH:
	POP	CX	;ADJUST STACK
	POP	CX	;FOR EXIT
	POP	CX
; EXIT HERE: DX = TRUE/FALSE FLAG ( 0=NO MATCH)
;
MAT4:	MOV	AX,SI	;NEW CURSOR ADDR
	POP	SI	;GET STARTING ADDR
	SUB	AX,SI	;COMPUTE CURSOR OFFSET
	MOV	SI,DI	;GET BACK UP
	JMP	DPUSH	; BYE..BYE
	PAGE
;
;**** LAST DICTIONARY WORD ****
HEADER({TASK},{TASK},{DOCOL})
	DW	SEMIS
;
INITDP	EQU	$	;SHOW END OF DICTIONARY
;
_COMMENT 

The remaining memory ( up to 'EM' ) is 
used for:

	1. EXTENSION DICTIONARY
	2. PARAMETER STACK
	3. TERMINAL INPUT BUFFER
	4. RETURN STACK
	5. USER VARIABLE AREA
	6. DISK BUFFERS


_ENDCOMMENT
					
 CSEG    ENDS
	PAGE
_COMMENT 

  MISC. NOTES AND SCATTERED THOUGHTS

- This source will assemble on all platforms where NASM is 
  available by the command line:
  nasm -fbin fig86.asm -o fig86.com
  (There may be exceptions for special configurations.)
  The result will run on MSDOS systems only, or stand alone
  an an IBM-compatible computer

- In a MODERN version <ctrl> P  will echo all output to the
  printer. This is not programmed here, but a feature of the OS.
  The operating system may make available a command history too.

- Use the installation manual.  Descriptions for all FIG
  words are given.  Those ERROR messages you get in FORTH
  correspond to the relative line numbers in blocks
  4 and 5 of the installation manual's model.  

- Remember that all the FORTH words in this version are
  upper case letters.  Use <CAPS LOCK> when in FORTH.

- Changing variable EM will allow you to create a larger
  dictionary space.  However I suggest you develop and
  DEBUG with EM set to 4000H.  Setting it to a larger value
  will result in a larger FORTH.EXE file, and you may
  need to run EXE2BIN ( Chap 10, DOS 2.0 ) to get enough
  disk space.  Once you are satisfied with what you have,
  then by all means take that extra memory.

- Reading the section on batch files may speed up your
  developement.  See the example files that came with
  the Macro Assembler.

- Subscribe to FORTH Dimensions.  It is a valuable source
  of system and application ideas.  Talking with fellow
  FORTH programmers is sure to stir up some exciting ideas.
  Consider joining a FIG chapter.  See the back of FORTH
  Dimensions for more info.

- <Ctrl-Break> will vector to WARM start ( Label WRM: )

_ENDCOMMENT

; Define the entry point, not valid for auto booting.
	END	ORIG

