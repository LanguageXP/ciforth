s/;[^"']*$//
s/
//
s/\([0-9][0-9A-F]*\)H/0x\1/g
s/\<EQU\>/=/
s/\<DW\>/ .WORD /
s/\<DB\>/ .BYTE /
# Reverse the order of the operands of an instruction
# Not of .HEADER() !
s/^[ 	]*\([^\.]\<[A-Z][A-Z]*\>\)\([^,]*\),\(.*\)/\1 \3,\2/
s/\$/./
s/\<ORG\>/. =/
# General registers
s/\<AL\>/%AL/g
s/\<AH\>/%AH/g
s/\<EAX\>/%EAX/g
s/\<BL\>/%BL/g
s/\<BH\>/%BH/g
s/\<EBX\>/%EBX/g
s/\<CL\>/%CL/g
s/\<CH\>/%CH/g
s/\<ECX\>/%ECX/g
s/\<DL\>/%DL/g
s/\<DH\>/%DH/g
s/\<EDX\>/%EDX/g
# Index registers
s/\<ESI\>/%ESI/g
s/\<EDI\>/%EDI/g
# Stacks and base registers
s/\<EBP\>/%EBP/g
s/\([^"]\)\<ESP\>/\1%ESP/g
# Segment registers
s/\<CS\>/%CS/g
s/\<DS\>/%DS/g
s/\<SS\>/%SS/g
s/\<ES\>/%ES/g
# GNU want indirect jumps this way.
s/\<JMP[ 	]*\[\(%[A-Z][A-Z]\)\]/JMP	*\1/g
s/\[\(%[A-Z][A-Z]\)\]/0(\1)/g
s/LEA[ 	]*\[\(%[A-Z][A-Z]\)+\(%[A-Z][A-Z]\)\]/LEA	(\1,\2)/g
s/\[\(\<.*\>\)+\(\<[0-9x]*\>\)\]/\1+\2/g
s/\[\(%[A-Z][A-Z]\)+\([^\]]*\)\]/\2(\1)/g
s/\([^`]\)\[\(\<[A-Z][A-Z0-9]*\>\)\]/\1\2/g
s/".""/".\\""/
s/"(.")"/"(.\\")"/

