@section                        Legalese

This Forth is called ciforth and is made available through the
DFW 
All publications of the DFW are available under GPL, the GNU public license.
The file COPYING containing the legal expression of these lines must accompagny it.

Because Forth is ``programming by extending the language'' the GPL
could be construed to mean that systems based on ciforth
always are legally obliged to make the source available. 
But we consider this ``fair use in the Forth sense''.

In addition to the GPL the DFW states the following:

The GPL is interpreted in the sense that a system based on ciforth
and intended to serve a particular purpose, that purpose not being a
``general purpose Forth system'', is fair use of the system, even if it
could accomplish everything ciforth could, under the condition that the
ciforth it is based on is available in accordance to the GPL rules,
and this is made known to the user of the derived system.

@section                         Rationale 

What you find here is a Forth for the Intel 86. It is a figforth
as of old.Complying in detail with the Fig glossary, which is available 
in electronicfrom for the first time in history.
The motivation for having this type of Forth available follows from its
characteristics. It is available as an assembler source, and it is an
indirect threaded Forth. 
An assembler source has distinct advantages for getting started from
nothing. An engineer might balk at the description of how to use a meta
compiler, but feels at ease with a (much larger) assembler manual.
Although speed is currently in fashion, using subroutine threaded Forth's
with optimisers, indirect threading is the preferred choice for some
applications. I did this work, because I needed it. 
I have also the firm belief that an optimiser on an indirect threaded system
has more information to work with and can ultimately outperform any
other system in speed.

@section                         Source
In practice the GPL 
 means (note: this is an explanation and has no legal value!)

They may be
further reproduced and distributed subject to the following conditions:

The three file comprising it must be kept together and in particular 
the reference section with the World Wide Web sites.


This Forth builts on figforth.
It is based on the work of Charlie Krajewski and Thomas Newman, Hayward, Ca.
that is available via taygeta.

You still can obtain the original version
 that is public domain according to the following statement:

All publications of the Forth Interest Group are public domain. They may be
further reproduced and distributed by inclusion of this credit notice: 

This publication has been made available by the Forth Interest Group, 

              P. O. Box 1105,  San Carlos, Ca 94070

albert@@spenarnc.xs4all.nl     http://home.hccnet.nl/a.w.m.van.der.horst

@section Generic Configuration Manual

This information will in due time be removed to a separate 
manual.
A ciforth user will not normally be interested in this.
The source and executable of this ciforth was generated, out of at
least dozen's of possibilities, by a generic system. An important goal
was to generate exactly fitting documentation, that contains only
relevant information. 
The original system can be obtained via
http://home.hccnet.nl/a.w.m.van.der.horst/figforth.html


@subsection Introduction

What you find here is a Forth for the Intel 86. It is a FIG Forth as of old.
Complying in detail with the Fig glossary, which is available in electronic
from for the first time in history.
The motivation for having this type of Forth available follows from its
characteristics. It is available as an assembler source, and it is an
indirect threaded Forth. 
An assembler source has distinct advantages for getting started from
nothing. An engineer might balk at the description of how to use a meta
compiler, but feels at ease with a (much larger) assembler manual.
Although speed is currently in fashion, using subroutine threaded Forth's
with optimisers, indirect threading is the preferred choice for some
applications. I did this work, because I needed it. 
It is based on the work of Charlie Krajewski and Thomas Newman, Hayward, Ca.
that is available via taygeta. And of course kudo's to FIG.
The original is public domain. My extensions are GPL-ed or libary GPL-ed.
I transferred the copyright to the Dutch Forth Workshop, a foundation that
supports Forth and defends the GPL.

@subsection 32 bits
It is unusual for a figforth to be 32 bit.
It turned out that the addition of CELL+ goes a long way toward allowing
utilities like a decompiler to be 16/32 bit clean. In the FIG documentation
about the user variables and +ORIGIN you may read cells where appropriate
and the documentation applies. 

@subsection System requirements

This generic version -if suitably built- runs on industry standard hardware
("PC's") : standalone, under Linux and under MSDOS/MSWINDOWS. 
To build, you need a version of nasm, TASM or MASM on your system. I
recomment nasm, it is an open source assembler and available on different
platforms, at least MSDOS and Unix. It solves a lot of the design errors I
find in the Intel ways of MASM.EXE. It generates a binary without a linker. 
On the opposite side, e.g. Borland's TASM you can buy nowaday's only as part
of a giant C++ package. 
If you want to use the generic possibilities you will need a Unix system
with all of its tools. I use GNU-Linux (RedHat) and do the makes and version
control on that. If you want your bootable floppies made from linux to be
MSDOS-compatible you need mtools. 

@subsection Assembler sources

The following two assembly sources generated are supplied as a service.
These are in fact just examples. You can generate different ones (see next
section.) 
The file alone.asm can be assembled using NASM. It includes a boot
sector such that it can boot from a standard floppy on a industry standard
Intel PC. If you have the mtools set (most Linux'es have it) the Makefile
shows you how to make the floppy. On MSDOS you can use DEBUG. 
If you run on Linux with
mtools, "make boot" will do it. 
The resulting floppy will even be recognized by
MSDOS, such that you can copy block sources to it. 
Make "moreboot" will do this from Linux, then you will have BLOCKS.BLK
available. Make "allboot" will do it all, but it needs a working forth
on Linux for doing some calculations.
Otherwise on MSDOS (I recommended version 3.3, the most stable MSDOS ever)
adapt the example genboot.asm. 
The file msdos.msm can be assembled using TASM and MASM. The resulting Forth
executable can be run off hard disk and respects the file system on it.
It uses the file BLOCKS.BLK.

@subsection A generic Forth
This version has one single source file: the generic I86 figForth.
All advantages of assembler source would be gone, if an engineer were
confronted with conditional compilation and lots of code for other systems
he doesn't want to learn or assemblers he doesn't want to use.
So we proceed in two steps. First a clean assembler source is generated from
the generic Forth using configuration files. Then the assembler source is
processed in one of a number of ways, each way familiar to one brand of
engineers. 

You can customize at a number of levels.
forthenumerate
forthitem
Configuration files have extension .cfg , these are files with m4
commands. They are intended to use at the highest and easiest level of
configuration and contain their own simple usage instructions. 
forthitem
m4 files have extension m4, and control one aspect of genericity, such
as the header layout or the protection mode. You definitely need to know m4
to use these.
forthitem
Assembler files can be customised in the traditional way by adopting
constants, or commenting in source lines. The assembler files are distinct
from the one generic source. No m4, you need only cope with the directives
of your assembler, and will not see any code applicable to other operating
systems or I/O systems. (It is not commented out, it is just not there.) 
forthitem
You can adapt the generic source. This is difficult, but gratifying.
If you manage to ANSI-fy it, the result is multiplied.
forthendenumerate

@subsection Level 1 customization.

This is assuming you run on Unix.

By specifying what you want in a configuration file you can generate a host
of assembler listings. This is as simple as replacing "yes" with "no" in
configuration files.
See the examples forthfile({msdos.cfg}) and forthfile({alone.cfg}) and the Makefile. 
You can find out what the options are by inspecting forthfile({prelude.m4}) . 

With respect to the assembler you can choose between NASM and MASM, with
file extension forthfile({.asm}) and forthfile({.msm}) respectively. The forthvar({.msm}) are acceptable by
TASM.EXE too. You can generate an equivalent forthfile({.s}) file, but this is 
experimental and doesn't lead to a working forth.

With respect to the I/O (words like forthcode({EXPECT}) forthcode({R/W}) ) you can choose between
three on MSDOS.
You can use dos ({_CLASSIC_}) in the classic way as with the original. This
means that the floppy is used directly without regard for directory
structures. This uses calls that are declared obsolete.
You can use dos in a modern way. ({_MODERN_}). This allocates block in the
file with name forthfile({BLOCKS.BLK}) . This name is available in the string forthcode({BLOCK-FILE}) 
for you to change, also at run time. No (as of 2000 ) obsolete MSDOS calls
are used (Checked against MS-DOS programmers reference "covers through
version 6" ISBN 1-55615-546-8) 
You can use the BIOS ({_USEBIOS_}) No MSDOS interrupts are required. 

With repect to I/O on linux you can choose between c-based and native.
The c-based version may be portable to other I86 unices. The native version
of course not. All linux versions have their blocks in a file. (Accessing
a floppy in the classic way is perfectly possible -- and implementing it would
be a perfectly pointless exercise.)

With respect to the hosting you can choose between {_HOSTED_} ({_HOSTED_LINUX_} or
{_HOSTED_MSDOS_}) and {_BOOTED_}. ({_BOOTDF_} or {_BOOTHD_}). A hosted version relies on
MSDOS or Linux to get the program started. (It may or may not use MSDOS for
I/O, once started.). A {_BOOTED_} version contains a boot sector, such that
you you can make a standalone version that boots from floppy or hard disk. 
A {_BOOTED_} version may very well be startable from plain DOS and its files 
visible from DOS.

Of course a {BOOTED_} version that tries to use MSDOS I/O (or Linux) crashes
immediately, so not all versions are useful. 

You have a choice between 16 or 32 protected mode and real mode.
Of course on Linux real mode is not an option, (but you could run the
MSDOS emulator). Protected mode Forths on MSDOS cannot be started from
virtual real mode, e.g. they will not run in a "DOS box" in Windows.

If you manage to specify conflicting options the preprocessor (m4) breaks
off and you can find the exit code in forthfile({postlude.m4}) . Than you can reason back
why this is a conflict. For example error 1000 indicates floppy and hard
disk i/o at the same time. From forthfile({postlude.m4}) you see that {_RWFD_} and {_RWHD_} are
on at the same time. {_RWHD_} is turned on because you wanted to boot from hard
disk or you specified it yourself in the first place. Etc. 

 forthvar({postlude.m4}) does you another favor. It derives logical consequences, such
as once you decide for a {_REAL_} mode Forth, it must be {_BITS16_} and you need
not specify that. In particular {_LINUX_N_} or {_LINUX_C_} says it all.    

@subsection Level 2 customization.
You are on your own here.

@subsection Level 3 customization.

The usual customisation in assembler files is possible. 
If you use other than 3" floppy disks you have to specify the disk
parameters. Parameters for a 5" HD floppy are present and can be commented
in. 
If you do not need a DOS-compatible floppy, you can put the image
immediately after the boot sector. A bootable hard disk version always works
like that. 
You can change the default name of the BLOCK-FILE at run time.
If you want to change the header layout, you will find that the way headers
are done via MACRO's make it more pleasant to use the generic listing. 
If you may want you can use this as a starting point for generating a whole
other Forth (like me).   
If you want to boot into your 20 Gbyte disk (like me), you probably have a
version 3.0 super modern LBA BIOS. There is no file system, just 20,000,000
blocks (and yes a 16 bit system would be inconvenient). If you want to use
an older system you must experiment by using the BIOS word. (You need not
resort to assembler for experimenting.) Then you can adapt your assembler 
listing.
There is a description in the history section about bringing up an assembler
system.

@subsection Level 4 customization.
Contact me if you want to contribute to the wider usability of this package.

@subsection Programs
In the file BLOCKS.BLK is available a screen editor, assembler, decompiler
and tools like DUMP. Beware! Some of the tools handle hards disks. There are
example programs and benchmarks. Everything under screen 100 you will find
more or less working, but maybe not on your system.
Everything loaded from 8 is used by me on a regular basis and is 16/32 bits
clean. Beware! The full screen editor doesnot work under Linux (protection).
The program `wc' is an example of how to use lina as a scripting language.

@subsection Deviations

Some non-substantial deviation of the original FIG source have been made
for good reasons. They are described in figdocadd.txt.

The assumption in using OFFSET was that you have two identical floppy drives
and no hard disk. That is nowadays extremely unlikely. Instead I put OFFSET
to good use to screen off a part of the floppy that must not be used (such
as an MSDOS directory or the hard disk part that contains the forth system.)

The FIG filosofy is that sectors, blocks and screens must be compatible, but
may be all different. The original 8086 FIG had one sector for a block. I
changed that in having one block for a screen. This is a boon for those
wanting to ANSI-fy the sources.

The way I coded the character I/O points ahead to vectoring forthcode({TYPE}) and forthcode({EXPECT}) 
rather than forthcode({EMIT}) and forthcode({KEY}) . This way I can have the host system handle the rub
out key. 

I added generic words forthcode({BIOS}) , forthcode({BDOS}) and forthcode({LINOS}) . These allow to have high level
words to handle about all forthcode({BIOS}) and interrupt 21 calls. Linux is better.
 forthcode({LINOS}) handles all Linux system calls. 

@subsection The joy of genericity

Genericity is acomplished by the Unix tools m4. I use GNU m4. This is a weird
tool but powerful. Forthers probably like it.
Some implementation details are hidden in the file header.m4. In particular
the way headers are built. I maybe 
want to get rid of the forthcode({WIDTH}) and forthcode({TRAVERSE
peculiarities}) and you may want to have the headers alligned at word bounds.
This is easily done by changes to forthfile({header.m4}) .
This kind of possibilities were in fact the motivation for this undertaking. 

@subsection Web sites.
A newer or improved version may be gotten from
http://home.hccnet.nl/a.w.m.van.der.horst
Nasm is found at 

The FIG source this is based on is at 

MASM.EXE is available 

The original fig documentation is at 
http://home.hccnet.nl/a.w.m.van.der.horst/figforth.html
This include the pictures.

@subsection Linux application notes figforth version
The linux forth called figforth has its i/o based on c. This may seem more
portable but it isn't. Where c is very portable on Linux, the way assembler
is linked with forth is not documented (as far as I can tell, in my version.
Linux improves overnight, so this may no longer be true.) 
The "break key" is implemented as the "any key". This key is lost, as is
perfectly allowed in the fig model. The forthcode({EXPECT}) has not the " return if
maximum reached property", so it is not strictly conforming. This can be
done at the expense of handling each character separately. (Use forthcode({KEY}) to
implement forthcode({EXPECT}) as in the CLASSIC I/O model). This results in loosing
interruptability. Moreover Linux knows better what the forthcode({RUBOUT}) key should be,
although for your convenenience it is already placed in a user variable and
can be easily changed. 
The c-approach allows signals to be handled in a familiar way.
By using quit, a loop can be interrupted. So ^\ results in a warm start.
A segmentation fault also results in a warm start. ^C immediately leaves.
^S/^Q can be used to hold up output and are not interpreted as a break
in e.g. VLIST.

@subsection Linux application notes lina version
The lina version is based on a single assembler source, built without
trickery and binary-portable accross Linux Intel (all systems were it has
been tried work : 1.2.13 .. 2.0.13). No run time c-libraries, no compile time
c-libraries, no libraries at all. It is built directly on the solid rock
of the system calls by ignoring a taboo c-programmers suffer from.
forthexample({
    nasm -felf lina.asm 
    ld lina.o -s -o lina
    strip lina
})
It is less than 12 K and the dictionary space is set at 64 Mbyte. 

Blocks are allocated in a file called forthfile({BLOCKS.BLK}) This name can be changed in
listing and also during run time. 
 forthfile({BLOCKS.BLK}) can be changed into an editable file and back by
forthsamp({cat BLOCKS.BLK | fromblocks > blocks.frt
cat blocks.frt | toblocks > BLOCKS.BLK})

The user variable forthvar({EM}) still is the end of the memory. 
The forthvar({M4_EM}) in the configuration files is such that it designates the relative
size, from the relocatable start. 
Consequently it is not the same as the user variable. 
(The relocatable start is some 128 Mbyte into the memory space.).
@subsection Bugs
See the separate test report for an indication of which and how far 
versions have been tested.
forthenumerate
forthitem
Linux version.
Once you have used a SIGQUIT to interrupt a loop, forthcode({BYE}) no longer works.
You can exit the program by "0 0 0 1 LINOS", which is exit(0) in
c-parlance or by pressing ^C, or by killing it from some other terminal,
or by just closing the window. 
You will not encounter this bug in version 2.148,
because that version crashes immediately, 
due to build problems.
forthitem
forthcode({OUT}) may not be observed in all I/O models. Needs examination.
forthitem
   More a misfeature. The negative error numbers of Linux system calls
   can be handled by negative offset's from screen 4. Now an offset
   of 64 is added. (The messages have not been filled in anyway.).
forthitem
Since I installed a new Red Hat (6.2) figforth crashes. 
forthendenumerate

@section                  History                                               
     
From the introduction to the figforth installation manual:
forthquotation
The figforth implementation project occurred because a key group of Forth
fanciers wished to make this valuable tool available on a personal computing
level. In June of 1978, we gathered a team of nine systems level
programmers, each with a particular target computer. The charter of the
group was to translate a common model of Forth into assembly language
listings for each computer. It was agreed that the group's work would be
distributed in the public domain by FIG. 

We intend that our primary recipients of the Implementation Project be
computer users groups, libraries, and commercial vendors. 
We expect that each will further customize for particular computers and
redistribute. No restrictions are placed on cost, but we expect faithfulness
to the model. FIG does not intend to distribute machine readable versions,
as that entails customization, revision, and customer support better
reserved for commercial vendors. 

Of course, another broad group of recipients of the work is the community of
personal computer users. We hope that our publications will aid in the use
of Forth and increase the user expectation of the performance of high level
computer languages. 
forthendquotation

@section                 Deviations of the FIG model

This version complies faithfully to the fig model, at least as
faithfully as is customary. 

The rigid subdivision in 7 area's was never adhered to. 
In particular the bootup parameters
are not up front as CP/M and MSDOS require a 100H byte reserved
area there. 
There is mention of forthvar({(KEY)}) being ``implementation dependant code''
but these were not often present in 
fig implementations. Here the implementation dependant code 
becomes part of the code definitions, or even of the high level definitions.

All documentation is now accurate but only claims to describe
ciforth. 
The forthcode({RUBOUT}) key is a bonafide forthcode({USER}) variable
and now has a name.

DR0 and DR1 are removed. There is only one consecutive mass storage area, be
it a disk or a file. 
forthvar({MOVE MON BLOCK-READ BLOCK-WRITE DLIST}) are not present.
Altering OUT to influence formatting doesn't work here, nor on 
any figforth I know off.

Some real errors were fixed 

@section                 Must go to the generic information

 Installation Dependent Code

You may want to use the assembly code of this ciforth to 
base a new Forth on. If this adversely affects the documentation
I urge you not to do that but to use the generic system.

The  following words 
are traditionally 
the only portion that need change between different
installations of the same computer cpu. They cannot come close to the capabilities
of the generic system, and should be used for minor modifications only.

There are five words that need adaptation:

KEY 
    Push the next ascii value (7 bits) from the terminal keystroke to the
    computation stack and execute NEXT. High 9 bits are zero. Do not echo
    this character, especially a control character. 


EMIT 
    Pop the computation stack (16 bit value). Display the low 7 bits on the
    terminal device, then execute NEXT. Control characters have their
    natural functions. 

?TERMINAL 
    For terminals with a break key, wait till released and push to the
    computation stack 0001 if it was found depressed; otherwise 0000.
    Execute NEXT. If no break key is available, sense any key depression as
    a break (sense but don't wait for a key). If both the above are
    unavailable, simply push 0000 and execute NEXT. 

CR 
    Execute a terminal carriage return and line feed. Execute NEXT. 

R/W 
This colon-definition is the standard linkage to your disc. It requests
the read or write of a disc block, be it raw disk or allocated in a file.

On primitive systems these may be jumps to ROM-code. But generally on i86
facilities like this are available using forthdefi({INT})'s a kind of traps.
These observe operating system protocols and are available as high level forth
code.

@section              Ram disc simulation

If disc is not available, a simulation of BLOCK and BUFFER may be made in
RAM. The following definitions setup high memory as mass storage. Referenced
``screens'' are then brought to the ``disc buffer'' area. This is a good method
to test the start-up program even if disc may be available. 

forthexample({
HEX  
4000 CONSTANT LO ( START OF BUFFER AREA ) 
6800 CONSTANT HI ( 10 SCREEN EQUIVALENT ) 
: R/W >R ( save boolean ) 
    B/BUF * LO + DUP 
    HI > 6 ?ERROR ( range check ) 
    R> IF ( read ) SWAP ENDIF 
    B/BUF CMOVE ;
})   

Insert the code field address of R/W into BLOCK and BUFFER and proceed as if
testing disc. R/W simulates screens 0 thru 9 when B/BUF is 128, in the
memory area $4000 thru $6BFF. 


             DEBUGGUBG AND INSTALLATION

Let us assume we have an system based on an assembler listing 
and we want to debug it. 

Here are the sequential steps: 
forthenumerate
forthitem
Familiarize yourself with the model written in Forth, the glossary, and
specific assembly listings. 
forthitem
Edit the assembly listings into your system. Set the fifth
boot-up parameters (WARNING) to 0000 (warning messages are shown as 
simple numbers).
forthitem
Alter the terminal support code (KEY, EMIT, etc,) to match your system. 
Observe register protocol specific to your  implementation!
forthitem
Place a break in your debugger at the end of NEXT, just before indirectly
jumping via register W to execution. W is the Forth name for the register
holding a code field address, and may be differently referenced in your
listings. 
forthitem
Enter the cold start at the origin. Upon the break, check that the
interpretive pointer IP points within ABORT and W points to SP!. 
If COLD is a colon-definition, then the IP has been initialized on the way
to NEXT and your testing will begin in COLD. The purpose of COLD is to
initialize IP, SP, RP, VP, and some user variables from the start-up
parameters at the origin. 
forthitem
Continue execution one word at a time. 
Clever individuals could write a simple trace routine to print IP, W, SP, RP
and the top of the stacks. Run in this single step mode until the greeting
message is printed. Note that the interpretation is several hundred cycles
to this stage! 
forthitem
Execution errors may be localized by observing the above pointers when a
crash occurs. 
forthitem
After the word QUIT is executed (incrementally), and you can input a
"return" key and get OK printed, remove the break. 
You may have some remaining errors, but a reset and examination of the above registers will again localize problems.
forthitem
When the system is interpreting from the keyboard, execute EMPTY-BUFFERS
to clear the disc buffer area. 
forthitem
If your disc driver differs from the assembly version, you must create
your own R/W .
You may test the disc access by typing: 0
BLOCK 64 TYPE This should bring block zero from the disc to a buffer and
type the first 64 characters. 
If BLOCK (and R/W) doesn't function--happy hunting! 
forthendenumerate

MULTI-USER

The name USER reflects that more than one user could use the dictionary
and users could share the background storage, provided certain precautions
are taken. 
These precautions are
forthenumerate
forthitem 
Variables that can be different for different users, 
must be defined as an offset to an area, that is different for
each user.
forthitem
Provisions that maintains the integrity of the dictionary
forthitem
Different stacks for each user.
forthitem
A means to switch applications.
forthitem 
Different scratchpads for each user.
forthendenumerate

Almost nothing from this is realised in the figforth model.
In fact only 1, but there is only one area.

Still USER variables seem to serve a useful purpose. 
They are initialised during start up, 
by changing it one could modify the system.
This however is only seemingly.
Because the initialised memory is saved anyway,
the initial values would be stored even if they
were ordinary variables.
So we are left with the disadvantage that we have to store them
back before saving the system.
Remains the advantage that they can be restored by typing forthcode({COLD}) .
This too is hardly an advantage because with the fast mass storage you would 
rather type forthcode({BYE}) and forthsamp({forth}) as a much safer way 
to restart your Forth.
                                    


