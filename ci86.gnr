;{               HCC FIG generic 8086 FORTH}
;{ $Id$}
;{ Copyright (2000): Albert van der Horst, HCC FIG Holland by GNU Public License}
;
        PAGE  66,106
 TITLE   GENERIC FORTH FOR 8086 $Revision$
 _HEADER_ASM
_COMMENT
        A generic version of FIG-FORTH for IBM type standard PC's
                Albert van der Horst
                HCC Forth user group
                The Netherlands
                www.forth.hccnet.nl

              based on
              FIG-FORTH
   implemented by:  Charlie Krajewski
                    205 ( BIG ) Blue Rd.
                    Middletown, CT  06457

  This implementation supports only one 64k segment

  The listing has been made possible by the
  prior work of:
               Thomas Newman, Hayward, Ca.

 : other_acknowledgements
         John_Cassidy
         Kim_Harris
         George_Flammer
         Robert_D._Villwock ;
 To upgrade, modify, and understand Fig Forth, the
 value of the following book cannot be overstated:
         Systems Guide to FIG Forth
         C. H. Ting, PhD
 It is available through MVP.  See any recent issue
 of FORTH Dimensions for their ad. (DIXIT AD MDCCCCLXXX)

No one who programs with FORTH can afford to be without:
  Starting Forth
  Leo Brodie
Get it.  Available through FORTH Interest Group.
Can also be found in many book stores.
Chapter 3 serves as a guide for the EDITOR that you
will probably type in from the FIG-Forth installation
manual.

Although there is much to be said for typing in your own
listing and getting it running, there is much to be said
not typing in your own listing.  If you feel that 100+
pages of plinking is nutty, contact me for availability
of a disc with source & executable files.  Obtainable at
a bargain basement price, prepare yourself for bargain
basement support.

All publications of the FORTH Interest Group are public domain.
They may be further distributed by the inclusion of this
credit notice:
               This publication has been made available by:

               FORTH Interest Group
               P.O. Box 1105
               San Carlos, Ca.  94070
_ENDCOMMENT
        PAGE
; ########################################################################################
;                       PREPARATION (no code)
; ########################################################################################
FIGREL  EQU     2       ;{ FIG RELEASE #}
FIGREV  EQU     0       ;{ FIG REVISION #}
USRVER  EQU     34      ;{ USER VERSION NUMBER, a digit now}
;
;{       PROTECTION}
CW      EQU     M4_CELLWIDTH       ;{ I.e. for the mode used in Forth, not in the bootcode.}
_FEWBLOCKS_({PMASK   EQU     0FFH    ;{ Allow to access only 256 blocks from OFFSET}})
;
;{      ASCII CHARACTER EQUIVALENTS}
;
ABL     EQU     20H     ;{ SPACE}
ACR     EQU     0DH     ;{ CR}
ADOT    EQU     2EH     ;{ PERIOD}
BELL    EQU     07H     ;{ ^G}
BSIN    EQU     08H     ;{ INPUT DELETE CHARACTER}
BSOUT   EQU     08H     ;{ OUTPUT BACKSPACE ( ^H )}
LF      EQU     0AH     ;{ LINE FEED, USED INTERNALLY AS}
                        ;{ LINE ENDER}
FF      EQU     0CH     ;{ FORM FEED}
;
;{      HEADER RELATED EQUATES}
B_DUMMY   EQU     01H     ;{ dea is dummy, from vocabulary link}
B_INVIS   EQU     02H     ;{ dea is invisible, "smudged".}
B_IMMED   EQU     04H     ;{ dea is a immediate.}
B_DENOT   EQU     08H     ;{ dea is a denotation.}
C_HOFFSET EQU     3       ;{ Offsets of code field in cells, w.r.t. dea}
F_HOFFSET EQU     1       ;{ Same for flag field}
L_HOFFSET EQU     2       ;{ Same for link field}
N_HOFFSET EQU     0       ;{ Same for name field}
P_HOFFSET EQU     4       ;{ Same for parameter field}
D_HOFFSET EQU     5       ;{ Start of data area for DOES> word.}
;
;{      MEMORY + I/O CONSTANTS}
;
NBUF    EQU     8      ;{ NO. OF BUFFERS AKA SCREENS }
KBBUF   EQU     1024    ;{DATA BYTES PER DISK BUFFER}
US      EQU     100H     ;{ USER VARIABLE SPACE}
_BITS16_({ RTS     EQU     0A0H    ;{ RETURN STACK & TERM BUFFER} })
_BITS32_({ RTS     EQU  10000H    ;{ RETURN STACK & TERM BUFFER} })
;
_EQULAYOUT_({
EM      EQU     M4_EM   ;{ END OF MEMORY + 1}
_HIGH_BUF_({
BUF1    EQU     EM-(KBBUF+2*M4_CELLWIDTH)*NBUF      ;{ FIRST DISK BUFFER}
STRUSA  EQU     BUF1-US         ;{ User area}
});_END_({ _HIGH_BUF_})
_LOW_BUF_({
STRUSA  EQU     EM-US         ;{ User area at end }
});_END_({ _LOW_BUF_})

STRTIB  EQU     STRUSA-RTS      ;{ Start return stack area}
                                ;{ Under this : data stack}
INITR0  EQU     STRUSA         ;{ Grows down}
INITS0  EQU     STRTIB          ;{ Growns down}
});_END_({ _EQULAYOUT_})

_CLASSIC_({
DRIVE   EQU     0       ;{ Use floppy A for blocks.}
});_END_({_CLASSIC_})

BPS     EQU     512             ;{Bytes/sector, common to all of MSDOS}
SPB     EQU     KBBUF/BPS
;
;{ PHYSICAL DISK PARAMETERS}
;{ (not needed for MODERN)}
;{ (not needed for BOOTHD)}
;
;{ Disk parameters: }
;{ HD drive 3" }
TRKS    EQU     80    ;{Number of tracks}
SPT     EQU     18    ;{Sectors/track}
HEADS   EQU     2     ;{Number of heads }
NFAT    EQU     2     ;{ Number of FATS}
SECROOT EQU     0EH   ;{ Sectors for root directory entry.}
SECFAT  EQU     9     ;{ Sectors per FAT}
MEDIA   EQU    0F0H   ;{ Descriptor byte. Anachronism.}

_COMMENT
;{ HD drive 5" }
TRKS    EQU     80      ;{Number of tracks}
SPT     EQU     15      ;{Sectors/track}
HEADS   EQU     2       ;{Number of heads }
NFAT    EQU     2       ;{ Number of FATS}
SECROOT EQU     ?       ;{ Sectors for root directory entry.}
SECFAT  EQU     ?       ;{ Sectors per FAT}
MEDIA   EQU    F0H      ;{ Descriptor byte. Anachronism.}
_ENDCOMMENT

;{ Bios specific equates.}
BOOTADDRESS     EQU     M4_BIOSBOOT ;{ PC jumps to 0:7C00 to boot}
SPDRV   EQU     HEADS*TRKS*SPT    ;{ sectors/drive}
        ;{ Skip boot sector,fats and root dir and first sector of file.}
SECSTRT EQU     1+NFAT*SECFAT + SECROOT + 1
_COMMENT
;{ Alternative if the disk need not be recognized by MSDOS}
;{ Usable for generating a bootable floppy simple.}
SECSTRT EQU     1
_ENDCOMMENT
;{ END  OF PHYSICAL DISK PARAMETERS}

_SWITCH_({
;{ Segments   @ Valid in real mode % Valid in protected mode }
;{ Names starting in A_ are linear, physical (32 bit), absolute addresses }
RSTSIZE     EQU     10000H  ;{ For real mode stack. }
GDTSIZE         EQU     8000H   ;{ For GDT-table.}
IDTSIZE         EQU     0800H   ;{ For IDT-table. Not yet used. }
A_FORTH0     EQU     M4_LOADADDRESS - M4_ORG ; { Physical address of Forth's CS:0 = SS:0 = ES:0 . }

A_SWITCH        EQU     M4_SWITCHORG
A_RST       EQU     A_SWITCH + 10000H
A_GDT             EQU     A_RST + RSTSIZE
A_IDT             EQU     A_GDT + GDTSIZE  ; { reserved but not yet used. }
;A_LOWDP         EQU     A_IDT + IDTSIZE ; { Must become this. }
 A_LOWDP         EQU     A_GDT + IDTSIZE

;{ @ Real mode place for the stack.}
;{ This is such that after switching to real mode an isolated }
;{ Stack is available }
SS_RST      EQU     A_RST/10H ;
SWITCHSEGMENT     EQU     A_SWITCH/10H ;{ @ DS and CS for real code }
; {Add this to go from GDT_CS addresses to GDT_SWITCH addresses.}
M4_SWITCHOFFSET EQU  ( A_FORTH0 - M4_SWITCHORG)

;{ The GDT_.. are offsets in the GDT table. They can be arbitrarily choosen }
;{ as far as the GDT goes as long as they are a multiple of 08H }
;{ Switching sometimes restricts these to a particular value.}
GDT_SWITCH       EQU    SWITCHSEGMENT  ;{ % Switching segment, must be same for switching to work! }
GDT_CS EQU 10H  ;{ % The protected mode code segment }
GDT_SS16 EQU 10H  ;{ % To access the real mode stack segment from protected. }
; { In fact we set the DS immediately after switching.}
GDT_SS         EQU     SS_RST ;{ % The protected mode data segment}
GDT_DS         EQU     SS_RST ;{ % The protected mode data segment}
GDT_SEGMENT    EQU     A_GDT/10H       ;{ @ General descriptor table.}

IDENTIFY_16 EQU 008FH   ;{ Identification of 16 bit data segment, byte 6}
IDENTIFY_32 EQU 00CFH   ;{ Identification of 32 bit data segment, byte 6}
IDENTIFY_INT EQU 8E00H  ;{ Identification of an interrupt descriptor, byte 5}
IDENTIFY_XR  EQU 9A00H  ;{ Identification of a code segment, execute read, byte 5}
IDENTIFY_RW  EQU 9200H  ;{ Identification of a data segment, read write, byte 5}

GDTLEN EQU GDTSIZE-1      ; {Intel peculiarity.}
BOOTOFFSET EQU 0
});_END_({ _SWITCH_})

_LINUX_N_({
include(constant.m4)
SIZE_TERMIO     EQU     60      ; sizeof(termio) also captured from c.
RAWIO           EQU     (ECHO | ICANON)
        global  _start        ; Entry point
});_END_({_LINUX_N_})

_LINUX_C_({
        extern  c_type,c_expec,c_key,c_qterm
        extern  c_rslw, c_block_exit, c_block_init, c_debug
        global  figforth,_start        ; Called from c. Remainder c-routines to be called from here.
});_END_({_LINUX_C_})

_HOSTED_LINUX_({
        section forth progbits write exec alloc
});_END_({ _HOSTED_LINUX_})

        PAGE
; ########################################################################################
;                      BOOTCODE    (optional, always real mode)
; ########################################################################################

; {All bootcode must be relocatable and its memory references absolute.}
; {Not for the sake of booting, but to allow MSDOS to start the program too. }

        CSEG    SEGMENT PARA PUBLIC 'CODE'
        ASSUME CS:CSEG,DS:CSEG,SS:CSEG,ES:CSEG
    _ABSOLUTELOAD_({ ORG     M4_ORG})
ORG0:

_BOOTFD_({
        JMP     SHORT BOOT
        NOP
        ;{ MSDOS programmers reference (thru 6, 3.9)}
        DB    "DFW--EXP"
LBPS    DW         BPS
        DB         1
RESSECTORS  DW     01H
        DB         NFAT
        DW BPS*SECROOT/32
        DW         SPDRV
        DB         MEDIA
        DB         SECFAT, 0H
LSPT    DW         SPT
LHEADS  DW       HEADS
HIDDENSECS    DD        0H
HUGESECS      DD         000H
      ;{ BIOS parameter block ends here}
        DB 000H, 000H, 029H                  ;{ Required magic.}
        DB         004H, 01CH, 040H,  00BH
        DB    "           "
        DB    "FAT12   "

;{       Read the sector with number in CX (Counting from 0) to ES:BX.}
;{       Keep BX, CX  }
READSECTOR:
        PUSH    CX
        PUSH    BX
        MOV     AX,CX
        MOV     CL,SPT
        DIV     CL
        MOV     CL,AH
        INC     CL      ;{ Sectors counting from 1!}
        XOR     AH,AH   ; {Rid of remainder}
        MOV     CH,HEADS
        DIV     CH
        MOV     DH,AH   ;{ Head number}
        MOV     CH,AL   ;{ Only small disks <256 cylinders}
        MOV     DL,00            ;{Drive 0 (floppy 1)}
        MOV     AX,0201H   ;{ Read absolute one sector}
        INT(13H)                 ;{BIOS disk read function}
        POP     BX
        POP     CX
        RET

RETRY:
        CALL    DISPLAYW
        XOR     AX,AX   ;{ Reset}
        MOV     AL,' '
        MOV     DL,00            ;{Drive 0 (floppy 1)}
        INT(13H)                 ;{BIOS disk read function}
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
        MOV     AX,CX
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
BOOT:
        MOV     AL,'D'
        CALL    DISPLAY
        MOV AX,CS
        AND AX,AX       ;{ Z = BOOTING ?}
        JNZ  ELSE3

        MOV     AL,'F'
        CALL    DISPLAY
        MOV     AH,00   ;{ Reset}
        MOV     DL,00            ;{Drive 0 (floppy 1)}
        INT(13H)                 ;{BIOS disk read function}
        JB      RETRY

        ;{ The first file copied to a freshly formatted floppy will}
        ;{ be at SECSTRT (See also genboot.bat)}
        MOV     CX,SECSTRT      ; {Counting from zero}
        MOV     AX,BOOTADDRESS/10H ; {Bootsegment}
        MOV     ES,AX
        MOV     BX,BPS
BEGIN1: CALL    READSECTOR
        INC     CX
        ADD     BX,BPS
        JB      RETRY
        CMP     BX,RELATIVE_WRT_ORIG(TEXTEND)
        JB      BEGIN1

        MOV     AL,'W'
        CALL    DISPLAY
        CALL    DISPLAYCR
        JMP     ENDBOOT
});_END_({ _BOOTFD_})

_BOOTHD_({
        JMP     SHORT BOOT
        NOP
        ;{ MSDOS programmers reference (thru 6, 3.9)}
        DB    "DFW---HD"
LBPS    DW         BPS
        DB         1
RESSECTORS  DW     01H
        DB         NFAT
        DW BPS*SECROOT/32
        DW         SPDRV
        DB         MEDIA
        DB         SECFAT, 0H
        DW         SPT
        DW       HEADS
HIDDENSECS    DD        0H
HUGESECS      DD         000H
      ;{ BIOS parameter block ends here}
        DB 000H, 000H, 029H                  ;{ Required magic.}
        DB         004H, 01CH, 040H,  00BH
        DB    "           "
        DB    "RAW     "

BOOTLBA:  DB      10H, 0
        DW      (RELATIVE_WRT_ORIG(TEXTEND))/BPS      ;{ ROUNDS DOWN, BUT WE ALREADY HAVE 1 SEC.}
        DW      BPS             ;{ OFFSET AND SEGMENT}
        DW      SWITCHSEGMENT
        ;{ At a hard disk we just read sector from sector 1        }
        DD      1       ;{ Start}
        DD      0       ;{ M.S. 32 BITS}

HDREAD:
        MOV     AX,SWITCHSEGMENT
        MOV     DS,AX
        MOV     SI,RELATIVE_WRT_ORIG(BOOTLBA) ; {DS:SI absolute address of lba.}
        MOV     AX,4200H  ;{   Read extended                                }
        MOV     DX,0080H  ;{   Disk C                                 }
        INT     13H
        RET
RETRY:
        CALL    DISPLAYW
        MOV     AL,' '
        MOV     AH,00   ;{ Reset}
        MOV     DL,80            ;{Drive 80 (hd C:)}
        INT(13H)                 ;{BIOS disk read function}
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
        MOV     AX,CX
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
BOOT:
        MOV     AL,'D'
        CALL    DISPLAY
        MOV AX,CS
        AND AX,AX       ;{ Z = BOOTING ?}
        JNZ  ELSE3
        MOV     AL,'F'
        CALL    DISPLAY
        MOV     AH,00   ;{ Reset}
        MOV     DL,80            ;{Drive 80 (hd C:)}
        INT(13H)                 ;{BIOS disk read function}
        JB      RETRY
        CALL    HDREAD
        JB      RETRY
        MOV     AL,'W'
        CALL    DISPLAY
        CALL    DISPLAYCR
        JMP     ENDBOOT
});_END_({ _BOOTHD_})

ELSE3:
_ABSOLUTELOAD_({
;{ Apparently we may have to move the code, e.g. if started from MSDOS.}
;{ Prepare return to MSDOS using the original code segment.}
        MOV     AX,CS
        MOV     DS,AX
        CALL    HERE1
HERE1:  POP     BX
        MOV     CX,BX
        ADD     BX,RETDOSV-HERE1+1        ;{ Independant of load address.}
        ADD     CX,RETDOS-HERE1
        MOV     [BX],CX
        INC     BX
        INC     BX
        MOV     [BX],AX
        JMP ENDBOOT     ; {Skip booting }
});_END_({ _ABSOLUTELOAD_})

_BOOTED_({
; Debug code, could be dispensed with in an ideal world.
DISPLAYCR:
        MOV     AL,ACR
        CALL    DISPLAY
        MOV     AL,LF
        JMP DISPLAY

DISPLAYPC:      POP     AX
        PUSH    AX
DISPLAYW:       PUSH    AX              ;{ Display AX in hex }
        MOV     AL,AH
        CALL    DISPLAYHEX
        POP     AX
        ;{ CALL DISPLAYHEX ; RET}
DISPLAYHEX:     PUSH    AX              ;{ Display AL in hex }
        MOV     CL,4
        SAR     AL,CL
        CALL    DISPLAYHD
        POP     AX
        ;{ CALL DISPLAYHD ; RET}
DISPLAYHD:      AND     AL,0FH          ;{ Display AL as one hex digit}
        DAA
        MOV     AH,AL
        MOV     CL,5
        SHR     AH,CL
        ADC     AL,30H
        ;{ CALL DISPLAY ; RET}
DISPLAY:XOR     BH,BH           ;{ Display AL as an ASCII char}
        MOV     AH,0EH
        INT(10H)
        RET
});_END_({ _BOOTED_})

_ABSOLUTELOAD_({
;{ Returns to DOS, provided we started from dos as a .COM.}
;{ Use far jump restoring CS to .COM value. }
RETDOS:
        MOV     AX,CS
        MOV     DS,AX
        MOV     ES,AX
        MOV     SS,AX
        MOV     AH,4CH
        INT     21H    ;{ Only works if cs is the same as while starting.}
});_END_({ _ABSOLUTELOAD_})

ENDBOOT:

; ########################################################################################
;                       ADJUST CODE SEGMENT REGISTER (still real mode)
; ########################################################################################
;{ Required start of .COM program.}
    _HOSTED_MSDOS_(_REAL_({ORG     100H
ORIG:                         ; {Accommodate also .exe files} }))

; ########################################################################################
;                       MOVE CODE TO ITS PLACE (still real mode)
; ########################################################################################

_ABSOLUTELOAD_({
; {  Take care of the situation where booting code is actually started up by  }
; {  MSDOS. This is no problem as long as the code is moved to where it would }
; {  be if booted. If the code is at its place, nothing really happens here.  }
; {  Furthermore all protected code started by MSDOS must be at an absolute address.}
        STD     ; Start at the end going back.
        MOV     CX,TEXTEND-HERE5 ; Amount to move
        CALL  HERE6
HERE6:  POP     AX                 ; { Calculate address of the first byte to move}
        ADD     AX,TEXTEND-HERE6-1
        MOV     SI,AX           ; {Relocatable address, w.r.t code segment.}
        MOV     AX,CS
        MOV     DS,AX
        MOV     AX, A_FORTH0/10H ; Destination segment
        MOV     ES, AX
        MOV     DI, TEXTEND-1
        REPNZ
        MOVSB
        PUSH    ES    ; {Corrected code segment}
        MOV BX, HERE5
        PUSH BX     ; {Correct program counter}
        RETF        ; {Returning to here5 now}
HERE5:
        MOV     AX,CS
        MOV     DS,AX
        MOV     ES,AX
        MOV     SS,AX
        CLD     ; {Reset direction to going up.}
});_END_({_ABSOLUTELOAD_})

; ########################################################################################
;                       FILL GDT AND SWITCH TO PROTECTED MODE/32 BITS (optional)
; ########################################################################################
_SWITCH_({
        JMP    PROTECT
GDTLOAD DW     GDTLEN
        DD     A_GDT
PROTECT:
;{Prepare. Remember STOSW uses ES:DI                              }
        MOV     AX,GDT_SEGMENT ;{ GDT segment}
        MOV     ES,AX
        MOV     DI,0
        MOV     AX,GDTLEN
        STOSW
;{ The switch segment.         }
;{ Switch between real and (16-bit) protected mode is done,}
;{ while using this segment (Relocatable code only).}
;{ GDT_SWITCH can to an extent be choosen arbitraryly,}
;{ as long as here we ensure that the real mode address  }
;{ is equal to the protected mode address. }
;{ You can only switch while staying at the same physical address}
;{ when you are currently executing in the range GDT_SWITCH:[0:FFFFH] }
        MOV     BX,GDT_SWITCH
        MOV     DI,BX
        MOV     AX,0FFFFH
        STOSW
        SHL     BX,4     ; { Turn segment register into IP}
        MOV     AX,BX
        STOSW
        MOV     AX,IDENTIFY_XR
        STOSW
        MOV     AX,IDENTIFY_16
        STOSW
_COMMENT
;{ The protected mode view of the real stack segment. }
;{ GDT_SS16 is arbitrary.}
        MOV     BX,GDT_SS16
        MOV     DI,BX
        MOV     AX,0FFFFH
        STOSW
        MOV     EAX,A_RST
        STOSW           ; {Only 16 bits}
        SHR     EAX,8
        ADD     AX,IDENTIFY_RW
        STOSW
        MOV     AX,IDENTIFY_16
        STOSW
_ENDCOMMENT
;{ GDT_DS/GDT_SS to an extent be choosen arbitraryly,}
;{ The real mode view of GDT_SS is valid, isolated and reserved for real stack.}
;{ DS is reset after switching anyway.}
;{ Accomodate a 24 bit start address, a maximal limit, large pages. }
        MOV     DI,GDT_SS ;{Identical to GDT_DS}
        MOV     AX,0FFFFH
        STOSW
        MOV     EAX,A_FORTH0
        STOSW           ; {Only 16 bits}
        SHR     EAX,8
        ADD     AX,IDENTIFY_RW
        STOSW
        MOV     AX,IDENTIFY_PROT
        STOSW
;{ PREPARE-CS 16/32 BITS                                                   }
        MOV     DI,GDT_CS
        MOV     AX,0FFFFH
        STOSW
        MOV     EAX,A_FORTH0
        STOSW           ; {Only 16 bits}
        SHR     EAX,8
        ADD     AX,IDENTIFY_XR
        STOSW
        MOV     AX,IDENTIFY_PROT
        STOSW

        LGDT    [GDTLOAD]
});_END_({ _SWITCH_})

_BOOTED_({
        JMP     ENDREADJUST
        _NEW_ORG(01FEH)
        ;{ Signature. Last piece of boot sector. }
        DB         055H, 0AAH
ENDREADJUST:
});_END_({ _BOOTED_})

_SWITCH_({
;{ Remember: we are now in the real mode for a protected model.}
;{ Make sure we are in the switch segment, such that we can switch.}
        MOV   BX,CS      ;{ Reality.}
        MOV AX, GDT_SWITCH ;{ Dream.}
        PUSH AX     ; {Correct code segment}
        SUB AX,BX      ;{ Discrepancy between dream and reality}
        MOV CX,10h     ;{ How much units would that be for the IP?}
        CWD
        MUL CX
        CALL  HERE3
HERE3:  POP   BX         ;{ Reality.}
        SUB BX,AX    ;
        ADD BX,THERE4-HERE3
        PUSH BX     ; {Corrected program counter}
        RETF        ; {Returning to THERE4 now}

_BITS16_({THERE4:})

_BITS32_({
;{ 32 bit protected mode is no good unless the A20 address line works.}
;{ The following tedious code is copied from the nuni startup code}
;{ for linux. }
KB_WAIT:
        IN AL,64H
        AND AL,2
        JNZ KB_WAIT
        RET
THERE4:
        CALL KB_WAIT
        MOV AL,0D1H
        OUT 064H,AL            ;{ Enable a20}
        CALL KB_WAIT
        MOV AL,0DFH
        OUT 060H,AL
});_END_({ _BITS32_})
});_END_({ _SWITCH_})


;{************************}
_BITS32_({include(width32.m4) })
;{************************}
;{ The following had to wait until width32.m4 had been included.}
BMASK   EQU     BLOCKS_IN_USE_MASK

_SWITCH_({
        CLI     ;{ Wait for stacks to be setup.}
        JMPHERE_FROM_REAL
        MOV     AX,GDT_SS
        MOV     SS,AX
REP1:
_BITS32_({
        INC AX                  ;{ Wait until a20 works(!)}
        MOV [M4_LOADADDRESS],AX
        CMP AX,[100000H + M4_LOADADDRESS] ; { 2^20 beyond}
        JE REP1
});_END_({ _BITS32_})
});_END_({ _SWITCH_})

; ########################################################################################
;                       FORTH GLUE CODE (optional, except for the jump)
; ########################################################################################

_LINUX_C_({
SAVE_LINUX:     DD      0,0,0,0,0 ; SP, BP, SI, DI, BX
RETURN_LINUX:
        MOV     ESP,_CELL_PTR[SAVE_LINUX+CELLS(0)]
        MOV     EBP,_CELL_PTR[SAVE_LINUX+CELLS(1)]
        MOV     ESI,_CELL_PTR[SAVE_LINUX+CELLS(2)]
        MOV     EDI,_CELL_PTR[SAVE_LINUX+CELLS(3)]
        MOV     EBX,_CELL_PTR[SAVE_LINUX+CELLS(4)]
        RET     ; Assuming the old stack has not been disturbed.It shouldn't.
figforth:
        MOV     _CELL_PTR[SAVE_LINUX+CELLS(0)],ESP
        MOV     _CELL_PTR[SAVE_LINUX+CELLS(1)],EBP
        MOV     _CELL_PTR[SAVE_LINUX+CELLS(2)],ESI
        MOV     _CELL_PTR[SAVE_LINUX+CELLS(3)],EDI
        MOV     _CELL_PTR[SAVE_LINUX+CELLS(4)],EBX
        LEA     ECX,[ESP+CELLS(1)]
        XOR     EAX,EAX
        CMP     EAX,_CELL_PTR[ECX]
        JZ     ENDIF1
        JMP     BOOTUP+CELLS(2)         ; Warm start
ENDIF1:

});_END_({_LINUX_C_})

_LINUX_N_({
figforth:
_start:
});_END_({_LINUX_N_})

        JMP     BOOTUP                  ; Cold start

; ########################################################################################
;                       FORTH ITSELF (entry point : BOOTUP)
; ########################################################################################
;
_COMMENT
   FORTH REGISTERS

   FORTH   8088     FORTH PRESERVATION RULES
   -----   ----     ----- ------------ -----
    IP      SI      Interpreter pointer.  Must be preserved
                    across FORTH words.

     W      BX      Working register.  When entering a word
                    via its code field the CFA is passed in BX.

    SP      SP      Parameter stack pointer.  Must be preserved
                    across FORTH words.

    RP      BP      Return stack.  Must be preserved across
                    FORTH words.

            AX      General register.  Used to pass data from
                    FORTH words, see label APUSH.

            DX      General register.  Used to pass more data from
                    FORTH words, see label DPUSH.

            BX      General purpose register.

            CX      General purpose register.

            CS      Segment register.  Must be preserved
                    across FORTH words.

            DS      ditto

            SS      ibid

            ES      Temporary segment register only used by
                    a few words. However it MUST remain equal to
                    DS, such that string primitives can be used
                    with impunity.

----------------------------------------------------------
_ENDCOMMENT
        PAGE
_COMMENT
---------------------------------------------

   COMMENT CONVENTIONS
   ------- -----------

   =       IS EQUAL TO
   <-      ASSIGNMENT

  NAME        =  Address of name
  (NAME)      =  Contents of name

  CFA         =  CODE FIELD: a pointer
  LFA         =  LINK FIELD: a pointer
  NFA         =  NAME FIELD: a pointer to a variable number of chars
  FFA         =  FLAG FIELD: contains flags
  PFA         =  PARAMETER FIELD: a variable nuber of au

  S1          =  Parameter stack - 1st cell
  S2          =  Parameter stack - 2nd cell
  R1          =  Return stack    - 1st cell
  R2          =  Return stack    - 2nd cell

  LSB         =  Least significant bit
  MSB         =  Most  significant bit
  LB          =  Low byte
  HB          =  High byte
  LW          =  Low  cell

------------------------------------------------------------
_ENDCOMMENT
_OLDDEBUG_({
        PAGE
_COMMENT
             DEBUG SUPPORT

THIS ROUTINE WILL ALLOW YOU TO STEP THRU FORTH PROGRAMS
EVERY TIME 'NEXT' IS EXECUTED.

IN ORDER TO USE THE STEP FEATURE YOU MUST DO THE FOLLOWING:

        1.  PATCH THE INSTRUCTION IN 'NEXT' WITH A JUMP
            TO 'TNEXT'

        2.  PATCH YOUR BREAKPOINT ROUTINE AT
            LABEL   'BREAK'

        3.  SET VARIABLES, `BIP' & `BIPE' TO THE
            ADDRESSES YOU WANT TO STEP THRU.

THE CONTENTS OF THE 2 VARIABLES 'BIP` AND `BIPE'
ARE INTERPRETED AS FOLLOWS:

BIP     BIPE    DEBUG-CONDITION
---     ----    ---------------

  0        X    OFF
 -1        X    TRACE ALL `NEXT' CALLS
ADDR1      0    TRACE `ADDR1' ONLY
ADDR1  ADDR2    TRACE `ADDR1' TO `ADDR1'

NOTE:   THE ABOVE ADDRESSES CAN'T POINT TO A
        `CODE FIELD ADDRESS'.
        X = DON'T CARE

-----------------------------------------------------
_ENDCOMMENT

BIP     DC      0       ;{ BREAKPOINT START ADDRESS}
BIPE    DC      0       ;{ BREAKPOINT END ADDR}
        PAGE
;{      THIS IS THE `NEXT' WITH DEBUG SUPPORT}

TNEXT:  PUSHF           ;{SAVE REGISTER}
        PUSH    AX
        MOV     AX,[BIP]  ;{ BREAKPOINT START ADDR}
        OR      AX,AX   ;{ ZERO?}
        JZ      TNEXT2  ;{ NO BREAKPOINT}
        CMP     AX,-1
        JZ      TNEXT1  ;{ STEP ALL POINTS}
        CMP     AX,SI   ;{ IN BREAKPOINT RANGE?}
        JZ      TNEXT1  ;{ STEP THIS LOCATION}
        JA      TNEXT2  ;{ NO}
        MOV     AX,[BIPE] ;{ BREAKPOINT END ADDR}
        OR      AX,AX   ;{ ZERO?}
        JZ      TNEXT2  ;{ ONLY 1 LOCATION}
        CMP     AX,SI   ;{ IN RANGE STILL?}
        JB      TNEXT2  ;{ NO}

;{      PAUSE ON ADDRESS}
;
TNEXT1: POPF
;
;{********  ADD YOUR BREAKPOINT HERE  **********}
;
BREAK:  JMP     SHORT   TNEXT3  ;{CONT WITH PROGRAM}
;
;{      NO BREAKPOINT PAUSE - RESTORE REGISTERS}
;
TNEXT2: POP     AX
        POPF
TNEXT3: LODSW           ;{ AX <- (IP)}
        MOV     BX,AX
        JMP     SHORT   NEXT1
});_END_({_OLDDEBUG_ })
        PAGE
_NEWDEBUG_({
DISPLAYSI:
        _SWITCH_({JMPHERE_FROM_FORTH})
        SET_16_BIT_MODE
        PUSH    SI
        PUSH    BP
        PUSH    BX
        MOV     AX,BX
        CALL    DISPLAYW
        MOV     AX,' '
        CALL    DISPLAY
        MOV     AX,SI
        CALL    DISPLAYW
        CALL    DISPLAYCR
        _BITS32_({SET_32_BIT_MODE})
        MOV     AH,10H
        INT     16H
        _SWITCH_({JMPHERE_FROM_OS})
        POP    BX
        POP    BP
        POP    SI
        RET
;
});_END_({_NEWDEBUG_ })
;
_OLDDEBUG_({ _COMMENT
    Patch the code from NEXT:  ( using a debugger ) with a
    `JMP TNEXT' for tracing through high level FORTH words.
_ENDCOMMENT });_END_({_OLDDEBUG_ })
;{ In 32 bit versions there may be no jumps to NEXT at all }
;{ The label NEXT1 is rarely relevant (for _OLDDEBUG_) }
DPUSH:  PUSH    DX      ;{ Fall through.}
APUSH:  PUSH    AX
NEXT:
;        PUSH    SI
;        CALL    c_debug
;        POP     SI
        LODSW           ;{AX <- (IP)}
NEXT1:  MOV     BX,AX   ;{ (W) <- (IP)}
_NEWDEBUG_({ CALL    DISPLAYSI})
        JMP     _CELL_PTR[BX]    ;{ TO `CFA'}
;
;{       Dictionary starts here.}

DP0:
worddoc({DENOTATIONS},{&},{char_follows}, {--- c},{CI},
{Leave forthvar({c}) the non blank char that follows.
Skip remaining non-blank characters.},
{{}},
{{& HELL HEX .},{48 },
{& X  HEX .},{58 }},
{{: GS1 & HELLO ; GS1 HEX .] },{48 },
{: GS1 & X ; GS1 HEX .},{58 }})
HEADER({&},{DCHAR},{DOCOL}, B_IMMED + B_DENOT)
        DC      INBRS, DROP, DROP
        DC      INBRS
        DC      SWAP, DROP
        DC      LDUP, QBL
        DC      LIT, 10, QERR
        DC      LITER
        DC      INBRS
        DC      QBL, ZEQU, LIT, 10, QERR
        DC      DROP
        DC      SEMIS
;
HEADER({0},{DEN0},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({1},{DEN1},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({2},{DEN2},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({3},{DEN3},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({4},{DEN4},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({5},{DEN5},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({6},{DEN6},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({7},{DEN7},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({8},{DEN8},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({9},{DEN9},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({A},{DENA},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
;
HEADER({B},{DENB},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
;
HEADER({C},{DENC},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
;
HEADER({D},{DEND},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
;
HEADER({E},{DENE},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
;
HEADER({F},{DENF},{DOCOL}, B_IMMED + B_DENOT)
        DC      NUMB, SEMIS
;
HEADER({-},{DENM},{DOCOL}, B_IMMED + B_DENOT)
        DC      ONE, LIN, PSTOR
        DC      PNUMB, DMINU, SDLITE
        DC      SEMIS
;
HEADER({+},{DENP},{DOCOL}, B_IMMED + B_DENOT)
        DC      ONE, LIN, PSTOR
        DC      NUMB, SEMIS
;
dnl Remember the top of the denotation chain.
define({_ENDOFDENOTATIONS_},_LINKOLD)dnl
dnl Reset the link chain at this point to keep denotations
dnl out of the normal search.
define({_LINKOLD},0)dnl
worddoc({VOCABULARIES},{DENOTATIONS},{DENOTATIONS},{},{CI},
{The name of the DENOTATIONS vocabulary.
This vocabulary contains one-letter words, called
 forthdefi({denotation}) definitions.
If a word is not found in the current search order,
the word containing its first letter is looked up in this
vocabulary.
If found the parse pointer is moved back to the start
of the word, and the corresponding denotation definition
executed.
This vocabulary is not intended to be used as a forthcode({CONTEXT})
vocabulary; and only as a forthcode({CURRENT}) whenever you want
to add a denotation.},
{{VOCABULARY}})
HEADER({DENOTATIONS},{DENOT},{DODOE},B_IMMED)
        DC      DOVOC
        DC      0       ;{ END OF VOCABULARY LIST}
        DC      0       ;{ Dummy name field}
        DC      B_DUMMY ;{ Dummy flag field}
        DC      _ENDOFDENOTATIONS_
;
worddoc({MISC},{NOOP},{no_operation},{},{},
{Do nothing. Primarily useful as a placeholder.
},{})
CODE_HEADER({NOOP},{NOOP})
       _NEXT
;
_OLDDEBUG_({ ;{ Rather unclear what this is supposed to.}
NOP0:   DC      $+CELLS(1)
        JMP SHORT NEXT
NOP1:   DC      $+CELLS(1)
        JMP SHORT NEXT
NOP2:   DC      $+CELLS(1)
        JMP SHORT NEXT
});_END_({_OLDDEBUG_ })
;
worddoc({COMPILING},{LIT},{lit},{--- n},{FIG,C2,L0},
{Within a colon-definition, forthcode({LIT}) is compiled followed by a
_BITS_ bit literal number given during compilation. Later execution of
forthcode({LIT}) causes the contents of this next dictionary address to be pushed
to the stack.},{{}},
{{: TL LIT [ 123 , ] ; TL .},{123}})
;
CODE_HEADER({LIT},{LIT})
        LODSW           ;{ AX <- LITERAL}
        _PUSH          ;{ TO TOP OF STACK}
;
worddoc({MISC},{EXECUTE},{execute},{addr -},{},
{Execute the definition whose forthdefi({dictionary entry address})
is given by forthvar({addr}) .
_VERBOSE_({The DEA serves as an execution token.})
},{{'},{>CFA}},
{{ ' BL >CFA EXECUTE .},{32}})
CODE_HEADER({EXECUTE},{EXEC})
        POP     BX      ;{ GET CFA}
        JMP     _CELL_PTR[BX]
;
worddoc({CONTROL},{BRANCH},{branch},{},{C2,L0},
{The run-time proceedure to unconditionally branch. An in-line offset
is added to the interpretive pointer forthcode({IP}) to branch ahead or back.
forthcode({BRANCH}) is compiled by forthcode({ELSE}) , forthcode({AGAIN}) , forthcode({REPEAT}) .},{})
CODE_HEADER({BRANCH},{BRAN})
BRAN1:  ADD     SI,[SI]
        _NEXT    ;{ JUMP TO OFFSET}
;
worddoc({CONTROL},{0BRANCH},{zero_branch},{f ---},{C2},
{The run-time proceedure to conditionally branch. If forthvar({f}) is false
(zero), the following in-line parameter is added to the interpretive
pointer to branch ahead or back. Compiled by forthcode({IF}) , forthcode({UNTIL}) , and forthcode({WHILE}) .
},{})
CODE_HEADER({0BRANCH},{ZBRAN})
        POP     AX      ;{ GET STACK VALUE}
        OR      AX,AX   ;{ ZERO?}
        JZ      BRAN1   ;{ YES, BRANCH}
        LEA     SI,[SI+CELLS(1)]
        _NEXT
;
worddocsafe({CONTROL},{(LOOP)},{paren_loop},{},{C2},
{The run-time proceedure compiled by LOOP which increments the loop
index and tests for loop completion.
},{{LOOP}})
CODE_HEADER({(LOOP)},{XLOOP})
        MOV     BX,1    ;{ INCREMENT}
XLOO1:  ADD     [BP],BX ;{ INDEX = INDEX + INCR}
        MOV     AX,[BP] ;{ GET NEW INDEX}
        SUB     AX,[BP+CELLS(1)]        ;{ COMPARE WITH LIMIT}
        XOR     AX,BX   ;{ TEST SIGN}
        JS      BRAN1   ;{ KEEP LOOPING}
;
;{  END OF `DO' LOOP}
        ADD     BP,_BYTE CELLS(2)  ;{ ADJ RETURN STACK}
        LEA     SI,[SI+CELLS(1)]       ;{ BYPASS BRANCH OFFSET}
        _NEXT
;
worddoc({CONTROL},{+LOOP},{plus_loop},{n1 --- (run)  addr n2 --- (compile)},{P,C2,L0},
{Used in a colon-definition in the form:
forthsamp({DO ... n1 +LOOP})
At run-time, forthcode({+LOOP}) selectively controls branching
back to the corresponding forthcode({DO}) based on forthvar({n1}) , the loop index and the
loop limit. The signed increment forthvar({n1}) is added to the index and the
total compared to the limit.
The branch back to forthcode({DO}) occurs until the new index is equal to or
greater than the limit (forthvar({n1>0})), or until the new index is equal to or
less than the limit (forthvar({n1<0})). Upon exiting the loop, the parameters
are discarded and execution continues ahead.

At compile time, forthcode({+LOOP}) compiles the run-time word forthcode({(+LOOP)}) and the
branch offset computed from forthcode({HERE}) to the address left on the stack by
forthcode({DO}) . forthvar({n2}) is used for compile tine error checking.},{})
CODE_HEADER({(+LOOP)},{XPLOO})
        POP     BX      ;{ GET LOOP VALUE}
        JMP SHORT     XLOO1
;
worddocsafe({CONTROL},{(DO)},{paren_do},{},{C},
{The run-time proceedure compiled by forthcode({DO}) which moves the loop control
parameters to the return stack.},{{DO}})
CODE_HEADER({(DO)},{XDO})
        POP     DX      ;{ INITIAL INDEX VALUE}
        POP     AX      ;{ LIMIT VALUE}
        XCHG    BP,STACKPOINTER   ;{ GET RETURN STACK}
        PUSH    AX
        PUSH    DX
        XCHG    BP,STACKPOINTER   ;{ GET PARAMETER STACK}
        _NEXT
;
worddoc({CONTROL},{I},{i},{--- n},{C,L0},
{Used within a do-loop to copy the loop index to the stack. Other use
is implementation dependent.},{{R}})
CODE_HEADER({I},{IDO})
        MOV     AX,[BP] ;{ GET INDEX VALUE}
        _PUSH          ;{ TO PARAMETER STACK}
;
worddoc({INIT},{+ORIGIN},{plus_origin},{n --- addr},{},
{Leave the memory address relative by forthvar({n}) bytes
to the area from which the user variables are initialised,
so one can access or modify the boot-up parameters.
A user variable addresses with an offset from the
initialisation for forthvar({U0}), which is at forthsamp({0 CELL+ +ORIGIN }).
This can be swapped to get a fresh set of user variables.
One can access or modify the boot-up parameters, prior to saving a
customised boot image, or to change the initialisation by forthcode({COLD}).
},
{{(ABORT)},{USER}})
HEADER({+ORIGIN},{PORIG},{DOCOL})
        DC      LIT
        DC      USINI
        DC      PLUS
        DC      SEMIS
;
;
;{      Initialisation block for user variables through VOC-LINK}
;{       <<<<< must be in same order as user variables >>>>>}
;
BOOTUP:
        NOP                    ; Fills jump to 4 bytes (for 16 bits code)
        _BITS32_({NOP         ; or to 8 bytes for 32 bits code  })
        _BITS32_({NOP })
        JMP     LCLD     ;{VECTOR TO COLD START}
        NOP                    ; Fills jump to 4 bytes (for 16 bits code)
        _BITS32_({NOP         ; or to 8 bytes for 32 bits code  })
        _BITS32_({NOP })
        JMP     WRM     ;{ VECTOR TO WARM START}
        DB      FIGREL  ;{ FIG RELEASE #}
        DB      FIGREV  ;{ FIG REVISION #}
        DB      USRVER  ;{ USER REVISION #}
        DB      0EH     ;{ VERSION ATTRIBUTES}
        _BITS32_({DC 0   ; Fill version info up to two cells. })
USINI:
        DC      _DEA(TASK) ;{ FIRST DEFINITION 0 }
        DC      STRUSA  ;{ INIT (U0) USER AREA POINTER 1}
        DC      BSIN    ;{ RUBOUT: get rid of latest char 2}
        DC      INITS0  ;{ INIT (S0)         3}
        DC      INITR0  ;{ INIT (R0)         4}
        DC      STRTIB  ;{ INIT (TIB)        5}
        DC      0       ;{ AVAILABLE         6}
        DC      0       ;{ INIT (WARNING)      7}
        DC      INITDP  ;{      INIT (FENCE)  8}
        DC      INITDP  ;{      INIT (DP)     9}
        DC      _DEA(FORTH) ;{       INIT (VOC-LINK) 10}
_LINUX_C_({
        DC      0       ;{ INIT (OFFSET) }
});_END_({_LINUX_C_})
_LINUX_N_({
        DC      0       ;{ INIT (OFFSET) }
});_END_({_LINUX_N_})
_RWFILE_({
        DC      0       ;{ INIT (OFFSET) }
});_END_({_RWFILE_})
_CLASSIC_({
_COMMENT
;{ This will steer clear of a forth executable, provided it is}
;{ the first file on the floppy. }
;{ (X-1)/S+1 rounds up to whole `S', this is used several times. }
;{ The 2 is rounding plus the extra sector in .EXE files.}
;{ However it deviates much from the classic model and requires}
;{ that the disk parameters are available (not only for USEBIOS)}
        DC      (RELATIVE_WRT_ORIG(TEXTEND)-1)/KBBUF+1 ; +1 for EXE
_ENDCOMMENT
;{ So for now just the classic, swap disk after booting.}
        DC      0       ;{ INIT (OFFSET) }
});_END_({_CLASSIC_})
_RWFD_({
;{ This will reserve place for dos information, such that the floppy}
;{ can be accessed from DOS and makes sure blocks are not allocated}
;{ within the forth system itself. }
;{ BPS subtracted because SECSTRT corresponds with one sector into source. }
;{ Round up both parts separately.}
;       You need a filler file of one sector,
;       if this  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv even (for a 3" drive).
        DC      (SECSTRT+((RELATIVE_WRT_ORIG(TEXTEND)-1-BPS)/BPS+1)-1)/SPB+1     ;{ INIT (OFFSET) }
});_END_({_RWFD_})
_RWHD_({
;{ This will reserve place for the system itself, on the first part of a }
;{ hard disk. No problem to just reserve whole memory.}
        DC      64      ;{ Kbyte.}
});_END_({_RWHD_})
;
;
;{      The following is the CPU's name, printed}
;{       during cold start.}
;{       The name is 32 bits in base 36.}
;
_SWITCH_({
; We either switch to prot, run linux (always prot) or run real mode
; Be careful that these classes are mutually exclusive and cover all.
CPUNM:  DC      0CDH,1856H       ;{ '80386'     12 13 }
});_END_({ _SWITCH_})
_HOSTED_LINUX_({
CPUNM:  DC      0CDH,1856H       ;{ '80386'     12 13 }
});_END_({ _HOSTED_LINUX_})
_REAL_({
CPUNM:  DC      5H,0B328H       ;{ '8088'     12 13 }
});_END_({ _REAL_})
_SWITCH_({
; {Swap the following with DP to allocate in conventional memory.}
         DC     A_LOWDP ; {LOW-DP        14}
; {Leave space to start conventional programs}
         DC     80000H          ; {LOW-EM        15}
});_END_({ _SWITCH_})
;{      <<<<< end of data used by cold start >>>>>}
        _RESB(US-($ - USINI))        ;{ All user can be initialised.}
;
worddoc({FORMATTING},{DIGIT},{digit},{c n1 --- n2 tf (ok) c n1 --- ff (bad)},{},
{Converts the ascii character forthvar({c}) (using base forthvar({n1}) ) to its binary
equivalent forthvar({n2}) , accompanied by a true flag. If the conversion is
invalid, leaves only a false flag.},{})
CODE_HEADER({DIGIT},{DIGIT})
        POP     DX      ;{NUMBER BASE}
        POP     AX      ;{ASCII DIGIT}
        SUB     AL,'0'
        JB      DIGI2   ;{NUMBER ERROR}
        CMP     AL,9
        JBE     DIGI1   ;{NUMBER = 0 THRU 9}
        SUB     AL,7
        CMP     AL,10   ;{NUMBER 'A' THRU 'Z'?}
        JB      DIGI2   ;{NO}
DIGI1:  CMP     AL,DL   ;{ COMPARE NUMBER TO BASE}
        JAE     DIGI2   ;{NUMBER ERROR}
        SUB     DX,DX   ;{ZERO}
        MOV     DL,AL   ;{NEW BINARY NUMBER}
        MOV     AL,1    ;{TRUE FLAG}
        _2PUSH          ;{ADD TO STACK}
;{   NUMBER ERROR}
DIGI2:  SUB     AX,AX   ;{FALSE FLAG}
        _PUSH
;
worddoc({STORAGE},{RESULT},{result},{--- addr},{},
{A variable containing the address of the result of searching
in one vocabulary chain.},{{BLOCK}})
HEADER({RESULT},{RESULT},{DOVAR})
        DC 0
;
worddocsafe({DICTIONARY},{MATCHING-WORDS},{matching_words},{addr1 addr2 --- addr1 )}, {},
{Intended to cooperate with forthcode({FOR-WORDS}) .
Compares the string variable forthsamp({addr1}) with the dea forthvar({addr2}).
If it is a match, it
returns into forthcode({RESULT}) this forthdefi({dea}) and it exits prematurely
from forthcode({FOR-WORDS}).},
{{FIND}})
HEADER({MATCHING-WORDS},{MATCHING},{DOCOL})
        DC      TOR
        DC      RR, TFFA, FETCH
        DC      LIT, B_INVIS | B_DUMMY
        DC      LAND, ZEQU
        _0BRANCH(MATS2)
        DC      LDUP
        DC      RR, TNFA, FETCH, FETCH
        DC      EQUAL   ;{ Compare counts.}
        _0BRANCH(MATS2)
        DC      OVER
        DC      RR, TNFA, FETCH, SFET
        DC      CORA, ZEQU  ;{ Compare equals.}
        _0BRANCH(MATS2)
        DC      FROMR, FROMR, FROMR, DROP, ZERO, TOR, TOR, TOR ;{FORCE END}
        DC      RR, RESULT, STORE
MATS2:  DC      FROMR, DROP
        DC      SEMIS
;
worddoc({PARSING},{?BLANK)},{query_blank},{ch --- f },{},
{For the character forthsamp({ch}) return whether this is
considered to be white space into the flag forthsamp({f}) .
At least the space, ascii null, the tab and the carriage return and line
feed characters are white space.},
{{BL},{SPACE}},
{{HEX 20 ?BLANK . 41 ?BLANK .},{1 0}})
HEADER({?BLANK},{QBL},{DOCOL})
        DC      LBL, ONEP, LESS
        DC      SEMIS
;
worddoc({PARSING},{IN[]},{in_next},{ ---addr chr},{CI L0},
{Parse the forthdefi({current input stream})
for a character and leave the its address.
Advance the input pointer to the next character.
If at the end of the end of the input stream,
leave the end and a zero.
_VERBOSE_({If the streaAs it goes with string constants, you may not
alter its content, nor assume anything is appended.})},
{{BLK},{WORD},{IN}},
{{},{},
{},{}})
HEADER({IN[]},{INBRS},{DOCOL})
        DC      SOURC, CELLP, TFET
        DC      OVER, EQUAL
        _0BRANCH(INBRS1)
        DC      ZERO
        _BRANCH(INBRS2)
INBRS1:
        DC      LDUP, CFET
        DC      ONE, LIN, PSTOR
INBRS2:
        DC      SEMIS
;
worddoc({PARSING},{MY-PARSE},{m_parse},{del ---sc},{CI L0},
{Parse the forthdefi({current input stream})
for a word, i.e. observing forthcode({?BLANK}) .
Skip leading delimiters then advance the input pointer to
past the next delimiter or past the end of the input stream.
Leave the word found as a string constant.
_VERBOSE_({As it goes with string constants, you may not
alter its content, nor assume anything is appended.})},
{{BLK},{WORD},{IN}},
{{: GS2 MWORD COUNT . C@ EMIT ; GS3 CELLO . .},{5 C},
{HEX : GS1 MWORD COUNT . C@ EMIT ; GS1   QQ},{2 Q}})
HEADER({(WORD)},{PWORD},{DOCOL})
PWORD1: DC INBRS
        DC OVER, SOURC, CELLP, FETCH, LSUB
        _0BRANCH(PWORD1B)
        DC QBL
        _0BRANCH(PWORD1A)
        DC DROP
        _BRANCH(PWORD1)
PWORD1B:
        DC DROP
PWORD1A:
PWORD2: DC INBRS, QBL, ZEQU
        _0BRANCH(PWORD2A)
        DC DROP
        _BRANCH(PWORD2)
PWORD2A:
        DC OVER, LSUB
        DC      SEMIS
;
worddoc({PARSING},{MY-PARSE},{m_parse},{del ---sc},{CI L0},
{Parse the forthdefi({current input stream})
with forthsamp({del}) for a delimiter.
Skip leading delimiters then advance the input pointer to
past the next delimiter or past the end of the input stream.
Leave the word found as a string constant.
_VERBOSE_({As it goes with string constants, you may not
alter its content, nor assume anything is appended.})},
{{BLK},{WORD},{IN}},
{{: GS2 MWORD COUNT . C@ EMIT ; GS3 CELLO . .},{5 C},
{HEX : GS1 MWORD COUNT . C@ EMIT ; GS1   QQ},{2 Q}})
HEADER({MY-PARSE},{MPARS},{DOCOL})
        DC      TOR
MPARS1: DC INBRS, RR, EQUAL
        _0BRANCH(MPARS1A)
        DC DROP
        _BRANCH(MPARS1)
MPARS1A:

MPARS2: DC INBRS
        DC LDUP
        _0BRANCH(MPARS3A)
        DC RR, LSUB
        _0BRANCH(MPARS2A)
        DC DROP
        _BRANCH(MPARS2)
MPARS3A: DC DROP
MPARS2A: DC FROMR, DROP
        DC OVER, LSUB
        DC      SEMIS
;
worddocsafe({PARSING},{(PARSE)},{paren_word},{ch addr1 addr2 --- addr3 },{},
{Scan the area between forthsamp({addr1}) and
forthsamp({addr2}) (non-inclusive) for the character forthsamp({ch}) .
Return forthsamp({addr3}): the address of the first such character
at or after forthsamp({addr2}), but not past forthvar({addr2}) .
_VERBOSE_({So if forthsamp({addr2}) equals forthvar({addr3})
the characer is not present.})},
{{WORD}},
{{ HEX 20 C, 41 C, 20 C, 41 HERE 3 - HERE (PARSE) HERE - . },{-2 }})
HEADER({(PARSE)},{PPARS},{DOCOL})
        DC      SOURC, CELLP, TFET
        DC TOR
PPARS1: DC LDUP, RR, LSUB
        _0BRANCH(PPARS2)
        DC OVER, OVER, CFET, LSUB
        _0BRANCH(PPARS2)
        DC ONEP
        _BRANCH(PPARS1)
PPARS2: DC SWAP, DROP
        DC FROMR, DROP
        DC      LIN, FETCH
        DC      SWAP
        DC      LDUP, ONEP, LIN, STORE
        DC      OVER, LSUB
        DC SEMIS
;
worddocsafe({PARSING},{SOURCE},{source},{addr --- },{},
{Return the address forthsamp({addr})
of the current scan specification, allocated in the user area.
It consists of three cells:
the lowest and non-inclusive highest address of the parse area
and a pointer to the next character to be parsed.
Changing forthsamp({SOURCE}) takes immediate effect,
and must be atomic, by using forthsamp({RESTORE-INPUT}),
or changing only the third cell.
The third cell has the alias forthsamp({IN}) .
_VERBOSE_({Words like forthsamp({BLK}) and
forthsamp({SOURCE-ID}) are secondary,
and return their output by ``second-guessing'' forthsamp({SOURCE}) .})},
{{BLK},{SOURCE-ID}},
{{ 9 2 SOURCE +! 8 9 . .},{9 9 }})
HEADER({SOURCE},{SOURC},{DOUSE})
        DC      CELLS(27)       ;{ And 28 and 29.}
;
worddoc({OUTPUT},{CR},{cr},{},{L0},
{Transmit a carriage return and line feed to the selected output
device.},{{OUT}})
HEADER({CR},{CR},{DOCOL})
        DC      LIT,LF
        DC      EMIT
        DC      SEMIS
;
worddoc({MEMORY},{CMOVE},{cmove},{from to count --},{},
{Move the specified quantity of bytes beginning at address from forthvar({to})
address forthvar({to}) . The contents of address from is moved first proceeding
toward high memory. As the Pentintel 86-family is byte-addressing there are
no restrictions. },{})
CODE_HEADER({CMOVE},{LCMOVE})
        CLD             ;{INC DIRECTION}
        MOV     BX,SI   ;{SAVE IF}
        POP     CX      ;{COUNT}
        POP     DI      ;{DEST}
        POP     SI      ;{SOURCE}
;{       MOV    AX,DS}
;{       MOV    ES,AX   ;ES <- DS}
        REP     MOVSB   ;{THAT'S THE MOVE}
        MOV     SI,BX   ;{GET BACK IP}
        _NEXT
;
worddoc({MULTIPLYING},{U*},{u_start},{u1 u2 --- ud},{},
{A mixed magnitude math operation which leaves the double number
 forthvar({d}) : the unsigned product of two unsigned numbers
 forthvar({n1}) and forthvar({n2}) .},{{U/}, {M*}.{*}})
CODE_HEADER({U*},{USTAR})
        POP     AX
        POP     BX
        MUL     BX      ;{UNSIGNED}
        XCHG    AX,DX   ;{AX NOW = MSW}
        _2PUSH          ;{STORE DOUBLE CELL}
;
worddoc({MULTIPLYING},{U/},{u_slash},{ud u1 --- u2 u3},{},
{Leave the unsigned remainder forthvar({u2}) and unsigned quotient forthvar({u3}) from the
unsigned double dividend forthvar({ud}) and unsigned divisor forthvar({u1}) .},{{U*},{M/},{/}})
CODE_HEADER({U/},{USLAS})
        POP     BX      ;{DIVISOR}
        POP     DX      ;{MSW OF DIVIDEND}
        POP     AX      ;{LSW OF DIVIDEND}
        CMP     DX,BX   ;{DICIDE BY 0?}
        JNB     DZERO   ;{ ERROR - ZERO DIVIDE}
        DIV     BX      ;{16 BIT DIVIDE}
        _2PUSH          ;{STORE QUOT/REM}
;
;{      DIVIDE BY ZERO ERROR - SHOW MAX NUMBERS}
DZERO:  MOV     AX,-1
        MOV     DX,AX
        _2PUSH          ;{STORE QUOT/REM}
;
worddoc({LOGIC},{AND},{and},{n1 n2 --- n2},{L0},
{Leave the bitwise logical and of forthvar({n1}) and forthvar({n2}) as forthvar({n3}) .},{{XOR},{OR}})
CODE_HEADER({AND},{LAND})
        POP     AX
        POP     BX
        AND     AX,BX
        _PUSH
;
worddoc({LOGIC},{OR},{or},{n1 n2 --- or},{L0},
{Leave the bit-wise logical or of two _BITS_ bit values.},{{AND},{XOR}})
CODE_HEADER({OR},{LOR})
        POP     AX      ;{ (S1) <- (S1) OR (S2)}
        POP     BX
        OR      AX,BX
        _PUSH
;
worddoc({LOGIC},{XOR},{xor},{nl n2 --- xor},{L1},
{Leave the bitwise logical exclusive or of two values.},{{AND},{OR}})
CODE_HEADER({XOR},{LXOR})
        POP     AX      ;{ (S1) <- (S1) XOR (S2)}
        POP     BX
        XOR     AX,BX
        _PUSH
;
worddocsafe({STACKS},{SP@},{s_p_fetch},{--- addr},{},
{Return the address forthvar({addr}) of the stack position,
as it was before forthcode({SP@}) was executed.
  (e.g.  forthsamp({1  2  SP@  @  ...})     would
   type forthsamp({2  2   1}) )},{{S0},{SP!}})
CODE_HEADER({SP@},{SPFET})
        MOV     AX,STACKPOINTER   ;{ (S1) <- (SP)}
        _PUSH
;
worddoc({STACKS},{SP!},{s_p_store},{},{},
{Initialize the stack pointer from forthcode({S0}) .},{})
CODE_HEADER({SP!},{SPSTO})
        MOV     BX,_CELL_PTR[USINI+CELLS(1)]   ;{USER VAR BASE ADDR}
        MOV     STACKPOINTER,[BX+CELLS(3)]        ;{RESET PARAM STACK POINTER}
        _NEXT
;
worddocsafe({STACKS},{RP@},{r_p_fetch},{--- addr},{},
{Return the address forthvar({addr}) of the current return
stack position, i.e. pointing the current topmost value.
  (e.g.  forthsamp({1 >R  RP@  @  . R>})     would
   type forthsamp({1}) )},{{S0},{SP!}})
CODE_HEADER({RP@},{RPFET})      ;{(S1) <- (RP)}
        MOV     AX,BP   ;{RETURN STACK ADDR}
        _PUSH
;
worddoc({STACKS},{RP!},{r_p_store},{},{},
{Initialize the return stack
pointer from user variable forthcode({R0}) .},{})
CODE_HEADER({RP!},{RPSTO})
        MOV     BX,_CELL_PTR[USINI+CELLS(1)]   ;{(AX) <- USR VAR BASE}
        MOV     BP,[BX+CELLS(4)]        ;{RESET RETURN STACK PTR}
        _NEXT
;
worddoc({SCREEN},{;S},{semicolon_s},{},{P,L0},
{Stop interpretation of a screen.
forthcode({;S}) is also the run-time word compiled at the end of a
colon-definition which returns execution to the calling proceedure.},{})
CODE_HEADER({;S},{SEMIS})
        MOV     SI,[BP] ;{(IP) <- (R1)}
        LEA     BP,[BP+CELLS(1)]
        _NEXT
;
worddoc({CONTROL},{LEAVE},{leave},{},{C,L0},
{Force termination of a do-loop at the next opportunity by setting
the loop limit equal to the current value of the index. The index
itself remains unchanged, and execution proceeds normally until forthcode({LOOP})
or forthcode({+LOOP}) is encountered.},{})
CODE_HEADER({LEAVE},{LLEAV})  ;{LIMIT <- INDEX}
        MOV     AX,[BP] ;{GET INDEX}
        MOV     [BP+CELLS(1)],AX        ;{STORE IT AT LIMIT}
        _NEXT
        PAGE
;
worddoc({STACKS},{>R},{to_r},{n ---},{C,L0},
{Remove a number from the computation stack and place as the most
accessable on the return stack. Use should be balanced with forthcode({R>}) in
the same definition.},{{R}})
CODE_HEADER({>R},{TOR})        ;{ (R1) <- (S1)}
        POP     BX      ;{GET STACK PARAMETER}
        LEA     BP,[BP-CELLS(1)]    ;{MOVE RETURN STACK DOWN}
        MOV     [BP],BX ;{ADD TO RETURN STACK}
        _NEXT
;
worddoc({STACKS},{R>},{r_from},{--- n},{L0},
{Remove the top value from the return stack and leave it on the
computation stack. },{{>R},{R}})
CODE_HEADER({R>},{FROMR})      ;{(S1) <- (R1)}
        MOV     AX,[BP] ;{ GET RETURN STACK VALUE}
        LEA     BP,[BP+CELLS(1)]
        _PUSH
;
worddoc({STACKS},{R},{r},{--- n},{},
{Copy the top of the return stack to the computation stack.},{{>R}})
HEADER({R},{RR},{IDO+CELLS(1)})
;
worddoc({LOGIC},{0=},{zero_equals},{n --- f},{L0},
{Leave a true flag forthvar({f}) is the number forthvar({n}) is equal to zero, otherwise leave a
false flag.},{{=}})
CODE_HEADER({0=},{ZEQU})
        POP     AX
        OR      AX,AX   ;{DO TEST}
        MOV     AX,1    ;{TRUE}
        JZ      ZEQU1   ;{IT'S 0}
        DEC     AX      ;{FALSE}
ZEQU1:  _PUSH
;
worddoc({LOGIC},{0<},{zero_less},{n --- f},{L0},
{Leave a true flag if the number is less than zero (negative),
otherwise leave a false flag.},{{<}})
CODE_HEADER({0<},{ZLESS})
        POP     AX
        OR      AX,AX   ;{SET FLAGS}
        MOV     AX,1    ;{TRUE}
        JS      ZLESS1
        DEC     AX      ;{FALSE}
ZLESS1: _PUSH
;
worddoc({OPERATOR},{+},{plus},{n1 n2 --- sum},{L0},
{Leave the sum of forthvar({n1+n2}) .},{{-},{*},{/},{MOD}})
CODE_HEADER({+},{PLUS})
        POP     AX      ;{(S1) <- (S1) + (S2)}
        POP     BX
        ADD     AX,BX
        _PUSH
;
worddoc({DOUBLE},{D+},{d_plus},{d1 d2 --- dsum},{},
{Leave the double number sum of two double numbers.},{{DMINUS},{+}})
CODE_HEADER({D+},{DPLUS})
        POP     AX      ;{ YHW}
        POP     DX      ;{ YLW}
        POP     BX      ;{ XHW}
        POP     CX      ;{ XLW}
        ADD     DX,CX   ;{ SLW}
        ADC     AX,BX   ;{ SHW}
        _2PUSH
;
worddoc({OPERATOR},{MINUS},{minus},{n1 --- n2},{L0},
{Leave the two's complement of a number, i.e.
 forthvar({n2}) is forthvar({-n1})
},{{-}})
CODE_HEADER({MINUS},{MINUS})
        POP     AX
        NEG     AX
        _PUSH
;
worddoc({DOUBLE},{DMINUS},{d_minus},{d1 --- d2},{},
{Leave the double number two's complement of a double number, i.e.
 forthvar({d2}) is forthvar({-d1}) },{{D+}})
CODE_HEADER({DMINUS},{DMINU})
        POP     BX
        POP     CX
        SUB     AX,AX
        MOV     DX,AX
        SUB     DX,CX   ;{ MAKE 2'S COMPLEMENT}
        SBB     AX,BX   ;{ HIGH CELL}
        _2PUSH
        PAGE
;
worddoc({JUGGLING},{OVER},{over},{nl n2 --- nl n2 n1},{L0},
{Copy the second stack value, placing it as the new top.},{{DUP}})
CODE_HEADER({OVER},{OVER})
        POP     DX
        POP     AX
        PUSH    AX
        _2PUSH
;
worddoc({JUGGLING},{DROP},{drop},{n ---},{L0},
{Drop the number from the stack.},{{DUP}})
CODE_HEADER({DROP},{DROP})
        POP     AX
        _NEXT
;
worddoc({JUGGLING},{SWAP},{swap},{nl n2 --- n2 n1},{L0},
{Exchange the top two values on the stack.},{{ROT}})
CODE_HEADER({SWAP},{SWAP})
        POP     DX
        POP     AX
        _2PUSH
;
worddoc({JUGGLING},{DUP},{dup},{n --- n n},{L0},
{Duplicate the value on the stack.},{{OVER}})
CODE_HEADER({DUP},{LDUP})
        POP     AX
        PUSH    AX
        _PUSH
;
worddoc({JUGGLING},{2DUP},{two_dup},{d --- d d},{L0},
{Duplicate the double number on the stack.},{{OVER}})
CODE_HEADER({2DUP},{TDUP})
        POP     AX
        POP     DX
        PUSH    DX
        PUSH    AX
        _2PUSH
;
worddoc({MEMORY},{+!},{plus_store},{n addr ---},{L0},
{ Add
forthvar({n}) to the value at the address.},{{TOGGLE},{!}} )
CODE_HEADER({+!},{PSTOR})
        POP     BX      ;{ADDRESS}
        POP     AX      ;{INCREMENT}
        ADD     [BX],AX
        _NEXT
;
worddoc({MEMORY},{TOGGLE},{toggle},{addr b --},{},
{Complement the contents of forthvar({addr}) by the bit pattern forthvar({b}) .},{{XOR},{+!} })
CODE_HEADER({TOGGLE},{TOGGL})
        POP     AX      ;{BIT PATTERN}
        POP     BX      ;{ADDR}
        XOR     [BX],AX ;
        _NEXT
;
worddocsafe({MEMORY},{@},{fetch},{addr --- n},{ISO L0},
{Leave the _BITS_ bit contents forthvar({n})
of forthvar({addr}) .},{{!},{C@},{2@},{P@},{PC@},{L@}})
CODE_HEADER({@},{FETCH})
        POP     BX
        MOV     AX,[BX]
        _PUSH
;
worddocsafe({MEMORY},{C@},{c_fetch},{addr --- b},{ISO},
{Leave the 8 bit contents of memory address. On the Intel architectures
there are no restrictions regarding byte
addressing.},{{C!},{@},{2@}})
CODE_HEADER({C@},{CFET})
        POP     BX
        XOR     AX,AX
        MOV     AL,[BX]
        _PUSH
;
worddocsafe({MEMORY},{2@},{two_fetch},{addr--- x1 x2},{ISO},
{Leave a pair of _32_ bits values forthvar({x1}) forthvar({x2}) from
consequitive cells at forthvar({addr}) . forthvar({x2}) is fetched from
the lowest address. },{{2!},{@},{C@}})
CODE_HEADER({2@},{TFET})
        POP     BX      ;{ADDR}
        MOV     AX,[BX] ;{MSW}
        MOV     DX,[BX+CELLS(1)]        ;{LSW}
        _2PUSH
;
worddoc({MEMORY},{!},{store},{n addr ---},{ISO L0},
{Store 16 bits of n at address.},{{@},{C!},{2!},{L!},{P!},{PC!}})
CODE_HEADER({!},{STORE})
        POP     BX      ;{ADDR}
        POP     AX      ;{DATA}
        MOV     [BX],AX
        _NEXT
;
worddoc({MEMORY},{C!},{c_store},{b addr ---},{ISO},
{Store 8 bits at forthvar({addr}) . On word addressing computers, further
specification is necessary regarding byte addressing.},{{C@},{!}})
CODE_HEADER({C!},{CSTOR})
        POP     BX      ;{ADDR}
        POP     AX      ;{DATA}
        MOV     [BX],AL
        _NEXT
;
worddoc({MEMORY},{2!},{two_store},{addr--- x1 x2},{ISO},
{Store a pair of _32_ bits values forthvar({x1}) forthvar({x2}) to
consecutive cells at forthvar({addr}) . forthvar({x2}) is stored at
the lowest address. },{{2@},{!},{C!}})
CODE_HEADER({2!},{TSTOR})
        POP     BX      ;{ADDR}
        POP     AX      ;{MSW}
        MOV     [BX],AX
        POP     AX      ;{LSW}
        MOV     [BX+CELLS(1)],AX
        _NEXT
;
worddoc({MEMORY},{WITHIN},{within},{n1 n2 n3 --- f},{ISO},
{Return a flag indicating that forthsamp({n1}) is in
the range forthsamp({n2}) (inclusive)
to forthsamp({n3}) (non-inclusive).
This works for signed as well as unsigned numbers.
Shorthand for: forthsamp({OVER - >R - R> U<}) },
{{<},{U<}},
{{ 1 1 3 WITHIN .},{1}},
{ 2 1 3 WITHIN .},{1},
{ 3 1 3 WITHIN .},{0},
{ 4 1 3 WITHIN .},{0})
HEADER({WITHIN},{WITHIN}, {DOCOL})
        DC      OVER, LSUB, TOR
        DC      LSUB, FROMR
        DC      ULESS
        DC      SEMIS
;
CODE_HEADER({L@},{LFET})
_BITS32_({
worddocsafe({MEMORY},{L@},{long_fetch},{rseg addr --- n},{},
{Leave the _BITS_ bit contents of forthvar({rseg:addr}),
interpreted as if it was a real mode segment plus offset addres.
This only works if the data segment is mapped directly (not paged) from
physical address 0H . },{{L!},{@},{C@},{2@}})
        POP     BX      ;MEM LOC
        POP     AX      ;SEG REG VAL
        MOV     DX,10H
        MUL     DX
        ADD     AX,BX
        MOV     AX,[AX]
        _PUSH
});_END_({ _BITS32_})
_BITS16_({
worddocsafe({MEMORY},{L@},{long_fetch},{rseg addr --- n},{},
{Leave the _BITS_ bit contents of forthvar({rseg:addr}),
the real mode segment plus offset addres.},
{{L!},{@},{C@},{2@}})
        POP     BX      ;MEM LOC
        POP     CX      ;SEG REG VAL
        _SWITCH_({JMPHERE_FROM_PROT})
        MOV     DX,DS   ;{ Leave this for real mode code.}
        MOV     DS,CX
        MOV     BX,[BX]
        MOV     DS,DX
        _SWITCH_({JMPHERE_FROM_REAL})
        PUSH    BX
        _NEXT
});_END_({ _BITS16_})
;
CODE_HEADER({L!},{LSTORE})
_BITS32_({
worddoc({MEMORY},{L!},{long_store},{n nseg addr --- },{},
{Store _BITS_ bits of forthvar({n}) at address
forthvar({rseg:addr}),
interpreted as if it was a real mode segment plus offset addres.
This only works if the data segment is mapped directly (not paged) from
physical address 0H . },{{L@},{!},{C!},{2!}})
        POP     BX      ;MEM LOC
        POP     AX      ;SEG REG VAL
        MOV     DX,10H
        MUL     DX
        ADD     AX,BX
        POP     BX
        MOV     [AX],BX
        _NEXT
});_END_({ _BITS32_})
_BITS16_({
worddoc({MEMORY},{L!},{long_store},{n nseg addr --- },{},
{Store _BITS_ bits of forthvar({n}) at address
forthvar({rseg:addr}),
a real mode segment plus offset addres.
},{{L@},{!},{C!},{2!}})
        POP     BX
        POP     CX
        POP     DX
        _SWITCH_({JMPHERE_FROM_PROT})
        MOV     AX,DS
        MOV     DS,CX
        MOV     [BX],DX
        MOV     DS,AX
        _SWITCH_({JMPHERE_FROM_REAL})
        _NEXT
});_END_({ _BITS16_})
;
worddoc({DEFINING},{:},{colon},{},{P,E,L0},
{Used in the form called a colon-definition:
forthexample({: cccc     ...     ;})
Creates a dictionary entry defining forthvar({cccc}) as equivalent to the
following sequence of Forth word definitions '...' until the next
forthcode({';'}) or forthcode({';CODE'}) .
The compiling process is done by the text interpreter as long as
forthcode({STATE}) is non-zero. Other details are that the forthcode({CONTEXT}) vocabulary is
set to the forthcode({CURRENT}) vocabulary and that words with the precedence bit
set (P) are executed rather than being compiled.},{})
HEADER({:},{COLON},{DOCOL},B_IMMED)
        DC      QEXEC
        DC      SCSP
        DC      CURR
        DC      FETCH
        DC      CONT
        DC      STORE
        DC      CREAT
        DC      RBRAC
        DC      PSCOD
DOCOL:  LEA     BP,[BP-CELLS(1)]
        MOV     [BP],SI ;{R1 <- (IP)}
        LEA     SI,[BX+CELLS(1)]  ;{(IP) <- (PFA)}
;        CALL    DISPLAYSI
_SWITCH_({
        _SWITCH_({JMPHERE_FROM_FORTH})
        ;{ Allow interrupts to happen.}
        _SWITCH_({JMPHERE_FROM_OS})
});_END_({ _SWITCH_})
        _NEXT
;
worddoc({DEFINING},{;},{semicolon},{},{P,C,L0},
{Terminate a colon-definition and stop further compilation. Compiles
the run-time forthcode({;S}) .},{})
HEADER({;},{SEMI},{DOCOL},B_IMMED)
        DC      QCSP
        DC      COMP
        DC      SEMIS
        DC      SMUDG
        DC      LBRAC
        DC      SEMIS
;
worddoc({DEFINING},{CONSTANT},{constant},{n ---},{L0},
{A defining word used in the form:
    forthvar({n}) forthcode({CONSTANT}) forthvar({cccc})
to create word forthvar({cccc}) , with its parameter field containing forthcode({n}) . When
forthvar({cccc}) is later executed, it will push the value of forthcode({n}) to the stack.},{{VARIABLE}})
HEADER({CONSTANT},{CON},{DOCOL})
        DC      CREAT
        DC      SMUDG
        DC      COMMA
        DC      PSCOD
DOCON:  MOV     AX,[BX+CELLS((P_HOFFSET-C_HOFFSET))] ;{GET DATA FROM PFA}
        _PUSH
;
worddoc({DEFINING},{VARIABLE},{variable},{},{NISO,E,LU},
{A defining word used in the form:
                 forthsamp({n VARIABLE cccc})
When forthcode({VARIABLE}) is executed, it creates the definition forthvar({cccc}) with its
parameter field initialized to forthvar({n}) . When forthvar({cccc}) is later executed, the
address of its parameter field (containing forthvar({n}) ) is left on the stack,
so that a fetch or store may access this location.},{{USER},{CONSTANT}})
HEADER({VARIABLE},{VAR},{DOCOL})
        DC      CON
        DC      PSCOD
DOVAR:  LEA     AX,[BX+CELLS((P_HOFFSET-C_HOFFSET))] ;{(AX) <- PFA}
        _PUSH
;
worddoc({DEFINING},{USER},{user},{n ---},{L0},
{A defining word used in the form:
               forthsamp({n USER cccc})
which creates a user variable forthvar({cccc}) .
The parameter field of forthvar({cccc}) contains forthvar({n}) as a fixed offset relative to
the user pointer register forthsamp({UP}) for this user variable. When forthvar({cccc}) is
later executed, it places the sum of its offset and the user area
base address on the stack as the storage address of that
particular variable. In ciforth the forthsamp({UP}) is fixed.
},{{VARIABLE},{+ORIGIN}})
HEADER({USER},{USER},{DOCOL})
        DC      CON
        DC      PSCOD
DOUSE:  MOV     BX,[BX+CELLS((P_HOFFSET-C_HOFFSET))] ;{PFA  }
        MOV     DI,_CELL_PTR[USINI+CELLS(1)]   ;{USER VAR ADDRESS}
        LEA     AX,[BX+DI]      ;{ADDR OF VARIABLE}
        _PUSH
;
worddoc({SUPERFLUOUS},{0},{zero},{--- 0},{},
{Leave the number 0. },{{CONSTANT}})
CODE_HEADER({0},{ZERO})
        XOR     AX,AX
        _PUSH
;
worddoc({SUPERFLUOUS},{1},{one},{--- 1},{},
{Leave the number 1. },{{CONSTANT}})
CODE_HEADER({1},{ONE})
        MOV     AX,1
        _PUSH
;
worddoc({SUPERFLUOUS},{2},{two},{--- 2},{},
{Leave the number 2. },{{CONSTANT}})
CODE_HEADER({2},{TWO})
        MOV     AX,2
        _PUSH
;
worddoc({SUPERFLUOUS},{3},{three},{--- 3},{},
{Leave the number 3. },{{CONSTANT}})
CODE_HEADER({3},{THREE})
        MOV     AX,3
        _PUSH
;
worddoc({STRING},{BL},{BL},{--- c},{},
{ A constant that leaves the
   ascii value for "blank".},{})
HEADER({BL},{LBL},{DOCON})
;{ THIS IS ONLY A SPAC}
    DC 20H
;
worddoc({STRING},{$@},{string_fetch},{addr --- sc},{},
{ From address forthsamp({addr}) fetch a string constant forthsamp({sc}) .},
{{$@},{$!},{$+!},{$C+}},
{{ HEX 4 , 41 C, 39 C, 45 C, 30 C, HERE 4 CELL+ - $@ TYPE},{A9E0}})
HEADER({$@},{SFET},{DOCOL})
        DC LDUP, CELLP, SWAP, FETCH
        DC SEMIS
;
worddoc({STRING},{$!},{string_store},{sc addr --- },{},
{Store a string constant forthsamp({sc})
in the string variable at address forthsamp({addr}).},
{{$@},{$+!},{$C+}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - $@ PAD $! PAD $@ TYPE},{A9}})
HEADER({$!},{SSTOR},{DOCOL})
        DC TDUP, STORE, CELLP, SWAP, LCMOVE
        DC SEMIS
;
worddoc({STRING},{$!-BD},{string_store},{sc addr --- },{},
{Store a string constant forthsamp({sc})
in the brain damaged
string variable at address forthsamp({addr}).},
{{COUNT},{$!}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - $@ PAD $! PAD $@ TYPE},{A9}})
HEADER({$!-BD},{SSTORBD},{DOCOL})
        DC TDUP, CSTOR, ONEP, SWAP, LCMOVE
        DC SEMIS
;
worddoc({STRING},{$+!},{string_append},{sc addr --- },{},
{Append a string constant forthsamp({sc})
to the string variable at address forthsamp({addr}).},
{{$@},{$!},{$C+}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ -
$@ 2DUP PAD $! PAD $+! PAD $@ TYPE},{A9A9}})
HEADER({$+!},{SPTOR},{DOCOL})
        DC   LDUP, FETCH, TOR ;{ Remember old count.}
        DC   TDUP, PSTOR
        DC   CELLP, FROMR, PLUS, SWAP, LCMOVE
        DC SEMIS
;
worddoc({STRING},{$C+},{char_append},{ch addr --- },{},
{Append a char forthsamp({ch})
to the string variable at address forthsamp({addr}).},
{{$@},{$!},{$+!}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ -
$@ PAD $! HERE 1 - C@ PAD $C+ PAD $@ TYPE},{A99}})
HEADER({$C+},{SCPLUS},{DOCOL})
        DC   LDUP, TOR
        DC   LDUP, FETCH, PLUS, CELLP, CSTOR
        DC   ONE, FROMR, PSTOR
        DC SEMIS
;
worddoc({STRING},{$,},{string_comma},{sc --- addr},{},
{Allocate and store a string constant forthsamp({sc})
in the vocabulary and leave its address forthsamp({addr}).},
{{$@},{$!},{}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - $@ $, $@ TYPE},{A9}})
HEADER({$,},{SCOMMA},{DOCOL})
        DC HERE, TOR
        DC LDUP, CELLP, ALLOT
        DC RR, SSTOR, FROMR
        DC SEMIS
;
worddoc({SCREEN},{C/L},{char_per_line},{--- c},{},
{A constant that leaves the number of characters on a line of a
standard screen. },
{{LIST},{LINE}})
HEADER({C/L},{CSLL},{DOCON})
        DC      64
;
_HIGH_BUF_({
worddoc({STORAGE},{FIRST},{first},{--- n},{},
{A constant that leaves the address of the first (lowest) block
buffer.
},{{BLOCK},{LIMIT}})
HEADER({FIRST},{FIRST},{DOCON})
        DC      BUF1
});_END_({ _HIGH_BUF_})
;
_LOW_BUF_({
        _ALIGN  2       ; Otherwise INT 13 hangs when filling
        ; in into the lba block as a buffer address.
worddoc({STORAGE},{FIRST},{first},{--- n},{},
{A constant that leaves the address of the first (lowest) block
buffer.
This is allocated in the lowest 1 Megabyte of memory,
to allow the BIOS to access it.
},{{BLOCK},{LIMIT}})
HEADER({FIRST},{FIRST},{DOVAR})
BUF1:    EQU     FIRST+CW     ; Must be even!
        _RESB    (KBBUF+2*CW)*NBUF
});_END_({ _LOW_BUF_})
;
worddoc({STORAGE},{LIMIT},{limit},{---- n},{},
{A constant leaving the address just above the highest memory
available for a disc buffer.
_HIGH_BUF_({Actually this is the highest system memory.})
},{{BLOCK},{FIRST}})
HEADER({LIMIT},{LIMIT},{DOCON})
        DC      BUF1+(KBBUF+2*CW)*NBUF
;{ THE END  OF THE MEMORY }
worddoc({MEMORY},{EM},{end_memory},{---- addr},{},
{A constant leaving the address just above the highest memory
in use by Forth.
},{{DP},{BM}})
HEADER({EM},{LEM},{DOCON})
        DC      EM
;
worddoc({MEMORY},{BM},{begin_memory},{---- addr},{},
{A constant leaving the address of the lowest memory
in use by Forth.
},{{DP},{EM}})
HEADER({BM},{LBM},{DOCON})
        DC      ORG0
;
worddoc({STORAGE},{B/BUF},{bytes_per_buf},{--- n},{},
{This constant leaves the number of bytes per disc buffer, the byte
count read from disc by forthcode({BLOCK}) .},{{B/SCR}})
HEADER({B/BUF},{BBUF},{DOCON})
        DC      KBBUF
;
;{ All user variables are initialised }
;{ with the values from USINI.}
;{ The implementation relies on the initialisation of }
;{ those with numbers (1..11), so change in concord with USINI.}
worddoc({MISC},{U0},{u_zero},{--- addr},{},
{A user variable, leaving the start address of the user area. This is
for reference only. What is taken into account by user variables is
the corresponding initialisation variable.
},{{USER},{+ORIGIN}})
HEADER({U0},{UZERO},{DOUSE})
        DC      CELLS(1)
;
worddoc({INPUT},{RUBOUT},{rub_out},{--- c},{},
{A user variable, leaving the key code that must delete the
last character from the input buffer.
_HOSTED_(In this ciforth it is not used, as the terminal input
editing is left to the host operating system.)
},{{USER}})
HEADER({RUBOUT},{RUBOUT},{DOUSE})
        DC      CELLS(2)
;
worddoc({STACKS},{S0},{s_zero},{--- addr},{U},
{A user variable that contains the initial value for the data stack
pointer.},{{SP!}})
HEADER({S0},{SZERO},{DOUSE})
        DC      CELLS(3)
;
worddoc({STACKS},{R0},{r_zero},{--- addr},{U},
{A user variable containing the initial location of the return stack. },{{RP!}})
HEADER({R0},{RZERO},{DOUSE})
        DC      CELLS(4)
;
worddoc({INPUT},{TIB},{t_i_b},{--- addr},{U},
{A user variable containing the address of the terminal input buffer.},{})
HEADER({TIB},{TIB},{DOUSE})
        DC      CELLS(5)
;
worddoc({ERRORS},{WARNING},{warning},{--- addr},{U},
{A user variable containing a value controlling messages. If = 1 disc
is present, and screen 4 of drive 0 is the base location for
messages. If = 0, no disc is present and messages will be presented
by number. If = -1, execute forthcode({(ABORT)}) for a user specified proceedure.
},{{MESSAGE},{ERROR}})
HEADER({WARNING},{WARN},{DOUSE})
        DC      CELLS(7)
;
worddoc({DICTIONARY},{FENCE},{fence},{---  addr},{U},
{A user variable containing an address below which forthcode({FORGET}) ting is
trapped. To forget below this point the user must alter the contents
of forthcode({FENCE}) .},{})
HEADER({FENCE},{FENCE},{DOUSE})
        DC      CELLS(8)
;
worddoc({DICTIONARY},{DP},{d_P},{---- addr},{U,L},
{A user variable, the dictionary pointer, which contains the address
of the next free memory above the dictionary. The value may be read
by forthcode({HERE}) and altered by forthcode({ALLOT}) .},{})
HEADER({DP},{LDP},{DOUSE})
        DC      CELLS(9)
;
worddoc({VOCABULARIES},{VOC-LINK},{voc_link},{--- addr},{U},
{A user variable containing the address of the VLFA in the word
most recently created by forthcode({VOCABULARY}) . _VERBOSE_({All vocabulary names are
linked by these fields to allow control for forthcode({FORGET}) ting thru multiple
vocabularies.})},{{VOCABULARY}})
HEADER({VOC-LINK},{VOCL},{DOUSE})
        DC      CELLS(10)
;
worddoc({STORAGE},{OFFSET},{offset},{--- addr},{U},
{A user variable which may contain a block offset to disc drives,
such as to free part of it for boot-code.
_HOSTED_MSDOS_({As blocks are allocated in a file on the host operating system it is 0.})
_HOSTED_LINUX_({As blocks are allocated in a file on the host operating system it is 0.})
The
contents of forthcode({OFFSET}) is added to the stack number by forthcode({BLOCK}) before calling
 forthvar({R/W}) .
Messages by forthcode({MESSAGE}) are independent of forthcode({OFFSET}) .},
{{BLOCK},{MESSAGE} })
HEADER({OFFSET},{OFSET},{DOUSE})
        DC      CELLS(11)
;
;{ End of user variables with fixed place.}
;
worddoc({SCREEN},{SCR},{s_c_r},{--- addr},{U},
{A user variable containing the screen number most recently reference
by forthcode({LIST}) .},{{BLOCK}})
HEADER({SCR},{SCR},{DOUSE})
        DC      CELLS(14)
;
worddoc({VOCABULARIES},{CONTEXT},{context},{--- addr},{U,L0},
{A user variable containing a pointer into the data of
a vocabulary that contains a dummy dea with which the
dictionary searches will first begin.},{{VOCABULARY},{CURRENT}})
HEADER({CONTEXT},{CONT},{DOUSE})
        DC      CELLS(16)
;
worddoc({VOCABULARIES},{CURRENT},{current},{--- addr},{U,L0},
{A user variable containing a pointer to data field of
a vocabulary to
new words will be added.
This is done by linking them in between the link field of the
dummy dea and the next definition.},{{VOCABULARY},{CONTEXT}})
HEADER({CURRENT},{CURR},{DOUSE})
        DC      CELLS(17)
;
worddoc({PARSING},{STATE},{state},{--- addr},{L0,U},
{A user variable containing the compilation state. A non-zero value
indicates compilation. The value itself may be implementation
dependent.},{})
HEADER({STATE},{STATE},{DOUSE})
        DC      CELLS(18)
;
worddoc({FORMATTING},{BASE},{base},{--- addr},{U,L0},
{A user variable containing the current number base used for input
and output conversion.},{{DECIMAL},{HEX},{<#}})
HEADER({BASE},{BASE},{DOUSE})
        DC      CELLS(19)
;
worddoc({FORMATTING},{DPL},{d_p_l},{---- addr},{U,L0},
{A user variable containing the number of digits to the right of the
decimal on double integer input. It may also be used hold output
column location of a decimal point, in user generated formating. The
default value on single number input is -1.},{{<#},{FLD},{HLD}})
HEADER({DPL},{DPL},{DOUSE})
        DC      CELLS(20)
;
worddoc({FORMATTING},{FLD},{f_l_d},{--- addr},{U},
{A user variable for control of number output field width. Presently
unused in fig-FORTH.},{})
HEADER({FLD},{LFLD},{DOUSE})
        DC      CELLS(21)
;
worddoc({SECURITY},{CSP},{c_s_p},{---- addr},{U},
{A user variable temporarily storing the stack pointer position, for
compilation error checking.},{})
HEADER({CSP},{LCSP},{DOUSE})
        DC      CELLS(22)
;
worddoc({SCREEN},{R#},{r_hash},{--- addr},{U},
{A user variable which may contain the location of an editing cursor,
or other file related function.},{})
HEADER({R#},{RNUM},{DOUSE})
        DC      CELLS(23)
;
worddoc({FORMATTING},{HLD},{hld},{--- addr},{L0},
{A user variable that holds the address of the latest character of
text during numeric output conversion.},{{<#},{DPL},{FLD}})
HEADER({HLD},{HLD},{DOUSE})
        DC      CELLS(24)
;
worddoc({OUTPUT},{OUT},{OUT},{--- addr},{U},
{A user variable that reflects the position at the current line of the output
device where the next character transmitted will appear.
The first position is zero. },{{EMIT},{TYPE},{CR}})
HEADER({OUT},{LOUT},{DOUSE})
        DC      CELLS(25)
;
worddoc({STORAGE},{BLK},{blk},{--- addr},{U,L0},
{A user variable containing the block number being interpreted. If
zero, input is being taken from the terminal input buffer.},{{BLOCK},{TIB}})
HEADER({BLK},{BLK},{DOUSE})
        DC      CELLS(26)
;
worddoc({INPUT},{IN},{in},{--- addr},{L0},
{A user variable containing the byte offset within the current input
text buffer (terminal or disc) from which the next text will be
accepted. forthcode({WORD}) uses and moves the value of forthcode({IN}) .},{})
HEADER({IN},{LIN},{DOUSE})
        DC      CELLS(29)
;
;{========== END USER VARIABLES =============;}
;
worddoc({SUPERFLUOUS},{1+},{one_plus},{n1 --- n2},{L1},
{Shorthand for ``forthvar({1}) forthcode({+})''.},{})
CODE_HEADER({1+},{ONEP})
        POP     AX
        INC     AX
        _PUSH
;
worddoc({SUPERFLUOUS},{2+},{two_plus},{n1 --- n2},{},
{Shorthand for ``forthvar({2}) forthcode({+})''.},{})
CODE_HEADER({2+},{TWOP})
        POP     AX
        ADD     AX,2
        _PUSH
;
worddoc({MEMORY},{CELL+},{cell_plus},{n1 --- n2},{},
{Advance the memory pointer forthvar({n1}) by one _BITS_ cel to
forthvar({n2}). _VERBOSE_({This is invaluable for writing portable
code. Many of the screens of ciforth run on both 16 and 32 bits
systems, thanks to this.})
},{})
CODE_HEADER({CELL+},{CELLP})
        POP     AX
        ADD     AX,CW
        _PUSH
;
worddoc({DICTIONARY},{HERE},{here},{--- addr},{L0},
{Leave the address of the next available dictionary location.},{{DP}})
HEADER({HERE},{HERE},{DOCOL})
        DC      LDP
        DC      FETCH
        DC      SEMIS
;
worddoc({DICTIONARY},{ALLOT},{allot},{n ---},{L0},
{Add the signed number to the dictionary pointer forthcode({DP}) . May be used to
reserve dictionary space or re-origin memory. As the Pentium is a byte-addressable
machine forthvar({n}) counts bytes. },{{CELL+}})
HEADER({ALLOT},{ALLOT},{DOCOL})
        DC      LDP
        DC      PSTOR
        DC      SEMIS
;
worddocsafe({DICTIONARY},{,},{comma},{n ---},{L0},
{Store forthvar({n}) into the next available dictionary memory cell, advancing
the dictionary pointer.},{{DP},{C,}})
HEADER({,},{COMMA},{DOCOL})
        DC      HERE
        DC      STORE
        DC      LCELL
        DC      ALLOT
        DC      SEMIS
;
worddocsafe({DICTIONARY},{C,},{c_comma},{b ---},{},
{Store 8 bits of forthcode({b}) into the next available dictionary byte, advancing
the dictionary pointer. },{{DP},{,}})
HEADER({C,},{CCOMM},{DOCOL})
        DC      HERE
        DC      CSTOR
        DC      ONE
        DC      ALLOT
        DC      SEMIS
;
worddoc({OPERATOR},{-},{minus_sign},{n1 n2 --- diff},{L0},
{Leave the difference of forthvar({n1-n2}) .},{{MINUS},{+},{*},{/},{MOD}})
CODE_HEADER({-},{LSUB})
        POP     DX      ;{S1}
        POP     AX
        SUB     AX,DX
        _PUSH   ;{S1 = S2 - S1}
;
worddoc({LOGIC},{=},{equals},{n1 n2 --- f},{L0},
{Leave a true flag if forthvar({n1=n2}) ; otherwise leave a false flag.},{{<},{>},{0=},{-}})
HEADER({=},{EQUAL},{DOCOL})
        DC      LSUB
        DC      ZEQU
        DC      SEMIS
;
worddoc({LOGIC},{<},{less_than},{n1 n2 --- f},{L0},
{Leave a true flag if forthvar({n1}) is less than forthvar({n2}) ;otherwise leave a false
flag.},{{=},{>},{0<}})
CODE_HEADER({<},{LESS})
        POP     DX      ;{S1}
        POP     AX      ;{S2}
        MOV     BX,DX
        XOR     BX,AX   ;{TEST FOR EQUAL SIGNS}
        JS      LES1    ;{SIGNS ARE NOT THE SAME}
        SUB     AX,DX
LES1:   OR      AX,AX   ;{TEST SIGN BIT}
        MOV     AX,0    ;{ASSUME FALSE}
        JNS     LES2    ;{NOT LESS THAN}
        INC     AX      ;{TRUE (1)}
LES2:   _PUSH
;
worddoc({LOGIC},{U<},{u_less_than},{u1 u2 --- f},{L0},
{Leave a true flag if forthvar({u1}) is less than forthvar({u2}) ; otherwise leave a false
flag.(Interpreted as unsigned numbers).},{{<}})
HEADER({U<},{ULESS},{DOCOL})
        DC      TDUP
        DC      LXOR,ZLESS
        _0BRANCH(ULES1) ;{IF}
        DC      DROP,ZLESS
        DC      ZEQU
        _BRANCH(ULES2)
ULES1:  DC      LSUB,ZLESS      ;{ELSE}
ULES2:  DC      SEMIS           ;{ENDIF}
;
worddoc({LOGIC},{>},{greater_than},{n1 n2 --- f},{L0},
{Leave a true flag if forthvar({n1}) is greater than forthvar({n2}) ; otherwise a false flag.},{{>},{=},{0<}})
HEADER({>},{GREAT},{DOCOL})
        DC      SWAP
        DC      LESS
        DC      SEMIS
;
worddoc({JUGGLING},{ROT},{rot},{nl n2 n3 --- n2 n3 nl},{L0},
{Rotate the top three values on the stack, bringing the third to the
top.},{{SWAP}})
CODE_HEADER({ROT},{ROT})
        POP     DX      ;{S1}
        POP     BX      ;{S2}
        POP     AX      ;{S3}
        PUSH    BX
        _2PUSH
;
worddoc({OUTPUT},{SPACE},{space},{},{L0},
{Transmit an ascii blank to the output device.},{{EMIT},{OUT}})
HEADER({SPACE},{SPACE},{DOCOL})
        DC      LBL
        DC      EMIT
        DC      SEMIS
;
worddoc({JUGGLING},{-DUP},{minus_dup},{n1 --- n1 (if zero) / n1 --- n1 n1 (non-zero)},{L0},
{Reproduce forthvar({n1}) only if it is non-zero.
This is usually used to copy a value just before forthcode({IF}) , to eliminate
the need for an forthcode({ELSE}) part to drop it.},{{DUP}})
HEADER({-DUP},{DDUP},{DOCOL})
        DC      LDUP
        _0BRANCH(DDUP1) ;{ IF}
        DC      LDUP    ;{ENDIF}
DDUP1:  DC      SEMIS
;
worddoc({VOCABULARIES},{LATEST},{latest},{--- addr},{},
{Leave the dictionary entry address ( forthsamp({dea}) )
of the topmost word in the forthcode({CURRENT})
vocabulary.},{{VOCABULARY}})
HEADER({LATEST},{LATES},{DOCOL})
        DC      CURR
        DC      FETCH
        DC      TLFA
        DC      FETCH
        DC      SEMIS
;
worddoc({DICTIONARY},{BODY>},{body_from},{addr --- dea},{},
{Convert the data field forthsamp({addr})
of a definition created with a forthcode({DOES>})
construct to it dea.},{{'},{>CFA},{>LFA},{>NFA}})
HEADER({BODY>},{BODYF},{DOCOL})
        DC      LIT,CELLS(5)
        DC      LSUB
        DC      SEMIS
;
worddoc({DICTIONARY},{>BODY},{to_body},{dea --- addr},{},
{Given the dictionary entry addres
of a definition created with a forthcode({DOES>})
construct return its  data field forthsamp({addr}).},
{{'},{>CFA},{>LFA},{>NFA}})
HEADER({>BODY},{TOBODY},{DOCOL})
        DC      LIT,CELLS(5)
        DC      PLUS
        DC      SEMIS
;
worddoc({DICTIONARY},{C>D},{parameter_field_address},{cfa --- dea},{},
{Convert the code field address of a compiled definition to its
dea address.},{{'},{>CFA},{>LFA},{>NFA}})
HEADER({C>D},{CTOD},{DOCOL})
        DC      LIT,CELLS(C_HOFFSET)
        DC      LSUB
        DC      SEMIS
;
worddoc({DICTIONARY},{>NFA},{to_name_field_address},{dea --- nfa},{},
{Given a dictionary entry addres return the
name field.},{{'},{>CFA}})
HEADER({>NFA},{TNFA},{DOCOL})
        DC      LIT,CELLS(N_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc({DICTIONARY},{>FFA},{to_flag_field_address},{dea --- ffa},{},
{Given a dictionary entry addres return the
flag field.},{{'},{>NFA}})
HEADER({>FFA},{TFFA},{DOCOL})
        DC      LIT, CELLS(F_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc({DICTIONARY},{>LFA},{to_link_field_address},{dea --- lfa},{},
{Given a dictionary entry addres return the
link field address.},{{'},{>LFA}})
HEADER({>LFA},{TLFA},{DOCOL})
        DC      LIT, CELLS(L_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc({DICTIONARY},{>CFA},{cfa},{dea --- cfa},{},
{Given a dictionary entry addres return the
code field address.},{{'},{>CFA}})
HEADER({>CFA},{TCFA},{DOCOL})
        DC      LIT, CELLS(C_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc({DICTIONARY},{>PFA},{to_parameter_field_address},{dea --- pfa},{},
{Given a dictionary entry addres return the
parameter field address.},{{'},{>CFA},{>LFA},{>NFA}})
HEADER({>PFA},{TPFA},{DOCOL})
        DC      LIT, CELLS(P_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc({DICTIONARY},{>DFA},{cfa},{dea --- cfa},{},
{Given the dictionary entry addres of a vocabulary
return the address of the dummy dea.
},{{VOCABULARY},{>CFA}})
HEADER({>DFA},{TDFA},{DOCOL})
        DC      TOBODY
        DC      CELLP ; {Skip vfa link.}
        DC      SEMIS
;
worddoc({DICTIONARY},{>VFA},{cfa},{dea --- cfa},{},
{Given the dictionary entry addres of a vocabulary
return the address of the link to the next vocabulary.
},{{VOCABULARY},{>CFA}})
HEADER({>VFA},{TVFA},{DOCOL})
        DC      TOBODY
        DC      SEMIS
;
worddoc({SECURITY},{!CSP},{store_c_s_p},{},{},
{Save the stack position in forthcode({CSP}). Used as part of the compiler
security.},{})
HEADER({!CSP},{SCSP},{DOCOL})
        DC      SPFET
        DC      LCSP
        DC      STORE
        DC      SEMIS
;
worddoc({ERRORS},{?ERROR},{question_error},{f n --},{},
{  Issue an error message number forthcode({n}) , if the boolean flag is true.},{ERROR})
HEADER({?ERROR},{QERR},{DOCOL})
        DC      SWAP
        _0BRANCH(QERR1) ;{IF}
        DC      ERROR
        _BRANCH(QERR2)  ;{ELSE}
QERR1:  DC      DROP    ;{ENDIF}
QERR2:  DC      SEMIS
;
worddoc({SECURITY},{?COMP},{question_compile},{},{},
{Issue error message if not compiling.},{{?ERROR}})
HEADER({?COMP},{QCOMP},{DOCOL})
        DC      STATE
        DC      FETCH
        DC      ZEQU
        DC      LIT,11H
        DC      QERR
        DC      SEMIS
;
worddoc({SECURITY},{?EXEC},{question_exec},{},{},
{Issue an error message if not executing.},{{?ERROR}})
HEADER({?EXEC},{QEXEC},{DOCOL})
        DC      STATE
        DC      FETCH
        DC      LIT,12H
        DC      QERR
        DC      SEMIS
;
worddoc({SECURITY},{?PAIRS},{question_pairs},{n1 n2 --},{},
{Issue an error message if forthvar({n1}) does not equal forthvar({n2}) . The message
indicates that compiled conditionals do not match.},{{?ERROR}})
HEADER({?PAIRS},{QPAIR},{DOCOL})
        DC      LSUB
        DC      LIT,13H
        DC      QERR
        DC      SEMIS
;
worddoc({SECURITY},{?CSP},{question_c_s_p},{},{},
{Issue error message if stack position differs from value saved in
forthvar({CSP}) .},{})
HEADER({?CSP},{QCSP},{DOCOL})
        DC      SPFET
        DC      LCSP
        DC      FETCH
        DC      LSUB
        DC      LIT,14H
        DC      QERR
        DC      SEMIS
;
worddoc({SECURITY},{?LOADING},{question_loading},{},{},
{Issue an error message if not loading},{{?ERROR}})
HEADER({?LOADING},{QLOAD},{DOCOL})
        DC      BLK
        DC      FETCH
        DC      ZEQU
        DC      LIT,16H
        DC      QERR
        DC      SEMIS
;
worddoc({COMPILING},{COMPILE},{compile},{},{C2},
{When the word containing forthcode({COMPILE}) executes, the execution address of
the word following forthcode({COMPILE}) is copied (compiled) into the dictionary.
This allows specific compilation situations to be handled in
addition to simply compiling an execution address (which the
interpreter already does).},{[COMPILE]})
HEADER({COMPILE},{COMP},{DOCOL})
        DC      QCOMP
        DC      FROMR
        DC      LDUP
        DC      CELLP
        DC      TOR
        DC      FETCH
        DC      COMMA
        DC      SEMIS
;
worddoc({PARSING},{[},{left_bracket},{},{P,L1},
{Used in a colon-definition in form:
forthexample({:  xxx    [  words   ]    more   ;})
Suspend compilation. The words after forthcode({[}) are executed, not compiled.
This allows calculation or compilation exceptions before resuming
compilation with forthcode({]})},{{LITERAL} ,{]}})
HEADER({[},{LBRAC},{DOCOL},B_IMMED)
        DC      ZERO
        DC      STATE
        DC      STORE
        DC      SEMIS
;
worddoc({PARSING},{]},{righ_bracket},{},{L1},
{Resume compilation, to the completion of a colon-definition.},
{{[}})
HEADER({]},{RBRAC},{DOCOL})
        DC      ONE
        DC      STATE
        DC      STORE
        DC      SEMIS
;
worddoc({DICTIONARY},{SMUDGE},{smudge},{},{},
{Used during word definition to toggle the "smudge bit" in a
definitions' name field. This prevents an uncompleted definition
from being found during dictionary searches, until compiling is
completed without error.},{{IMMEDIATE}})
HEADER({SMUDGE},{SMUDG},{DOCOL})
        DC      LATES
        DC      TFFA
        DC      LIT,20H
        DC      TOGGL
        DC      SEMIS
;
worddoc({FORMATTING},{HEX},{hex},{},{L0},
{Set the numeric conversion forthcode({BASE}) for hexadecimal (base 16) input-output.},
{{DECIMAL}})
HEADER({HEX},{HEX},{DOCOL})
        DC      LIT,16
        DC      BASE
        DC      STORE
        DC      SEMIS
;
worddoc({FORMATTING},{DECIMAL},{decimal},{},{L0},
{Set the numeric conversion forthcode({BASE}) for decimal input-output.},{{HEX}})
HEADER({DECIMAL},{DECA},{DOCOL})
        DC      LIT,10
        DC      BASE
        DC      STORE
        DC      SEMIS
;
worddocsafe({DEFINING},{(;CODE)},{paren_semicolon_code},{},{C},
{The run-time proceedure, compiled by forthcode({;CODE}), that rewrites the code
field of the most recently defined word to point to the following
machine code sequence.},{{;CODE}})
HEADER({(;CODE)},{PSCOD},{DOCOL})
        DC      FROMR
        DC      LATES
        DC      TCFA
        DC      STORE
        DC      SEMIS
;
worddoc({DEFINING},{;CODE},{semicolon_code},{},{P,C,L0},
{Used in the form:
  forthsamp({: cccc .... ;CODE})
assembly mnemonics Stop compilation and terminate a new defining
word forthvar({cccc}) by compiling forthcode({(;CODE)}). Set the forthcode({CONTEXT}) vocabulary to
forthcode({ASSEMBLER}) , assembling to machine code the following mnemonics.

When forthvar({cccc}) later executes in the form:
                     forthsamp({cccc nnnn})
the word forthvar({nnnn}) will be created with its execution proceedure given by
the machine code following forthvar({cccc}) .
That is, when forthvar({nnnn}) is executed, it does so by jumping to the code
after forthvar({nnnn}) . An existing defining word must exist in forthvar({cc}) prior to
forthcode({;CODE}) .},{(;CODE)})
;{ The word ;CODE has been moved to BLOCKS.BLK>}
;
worddoc({DEFINING},{<BUILDS},{builds},{},{C,L0},
{Used within a colon-definition:
         forthexample({: cccc  <BUILDS  ... DOES>     ...    ;})
Each time forthvar({cccc}) is executed, forthcode({<BUILDS}) defines a new word with a
high-level execution proceedure. Executing forthvar({cccc}) in the form:
            forthsamp({cccc nnnn})
uses forthcode({<BUILDS}) to create a dictionary entry for forthvar({nnnn}) with a call to
the forthcode({DOES>}) part for forthvar({nnnn}) . When forthvar({nnnn}) is later executed, it has the
address of its parameter area on the stack and executes the words
after forthcode({DOES>}) in forthvar({cccc}) . forthcode({<BUILDS}) and forthcode({DOES>}) allow runtime proceedures to
written in high-level rather than in assembler code (as required by
forthcode({;CODE}) ). },{})
HEADER({<BUILDS},{BUILD},{DOCOL})
        DC      ZERO
        DC      CON
        DC      SEMIS
;
worddoc({DEFINING},{DOES>},{does},{},{L0},
{A word which defines the run-time action within a high-level
defining word. forthcode({DOES>}) alters the code field and first parameter of
the new word to execute the sequence of compiled word addresses
following forthcode({DOES>}) . Used in combination with forthcode({<BUILDS}) . When the forthcode({DOES>})
part executes it begins with the address of the first parameter of
the new word on the stack. This allows interpretation using this
area or its contents. Typical uses include the Forth assembler,
multidimensional arrays, and compiler generation.},{})
HEADER({DOES>},{DOES},{DOCOL})
        DC      FROMR
        DC      LATES
        DC      TPFA
        DC      STORE
        DC      PSCOD
DODOE:  LEA     BP,[BP-CELLS(1)]
        MOV     [BP],SI ;{R1 <- (IP)}
        MOV     SI,[BX+CELLS((P_HOFFSET-C_HOFFSET))] ;{NEW IP }
        LEA     AX,[BX+CELLS((P_HOFFSET-C_HOFFSET+1))]
        _PUSH
;
worddoc({STRING},{COUNT},{count},{addr1 --- addr2 n},{L0},
{Leave the byte address forthvar({addr2}) and byte count forthvar({n}) of a message text
beginning at address forthvar({addr1}) . It is presumed that the first byte at
forthvar({addr1}) contains the text byte count and the actual text starts with
the second byte. Alternatively stated, fetch a string constant forthsamp({addr n})
from the brain damaged string variable at forthsamp({addr1}) .
},{{TYPE}})
HEADER({COUNT},{COUNT},{DOCOL})
        DC      LDUP
        DC      ONEP
        DC      SWAP
        DC      CFET
        DC      SEMIS
;
worddoc({STRING},{-TRAILING},{dash_trailing},{addr n1 --- addr n2},{},
{Adjusts the character count forthvar({n1}) of a text string beginning at
address forthvar({addr}) so as not to contain trailing blanks. },{})
HEADER({-TRAILING},{DTRAI},{DOCOL})
        DC      LDUP
        DC      ZERO
        DC      XDO     ;{DO}
DTRA1:  DC      OVER
        DC      OVER
        DC      PLUS
        DC      ONE
        DC      LSUB
        DC      CFET
        DC      LBL
        DC      LSUB
        _0BRANCH(DTRA2) ;{IF}
        DC      LLEAV
        _BRANCH(DTRA3)  ;{ ELSE}
DTRA2:  DC      ONE
        DC      LSUB    ;{ ENDIF}
DTRA3:  _LOOP(DTRA1)    ;{ LOOP}
        DC      SEMIS
        PAGE
        ;{ At line     LINE ~2000}
worddocsafe({PARSING},{(.")},{paren_dot_quote},{},{C+},
{The run-time proceedure, compiled by forthcode({."}) which transmits the
following in-line text to the selected output device.},{{."}})
HEADER({(.")},{PDOTQ},{DOCOL})
        DC      RR
        DC      SFET
        DC      LDUP
        DC      CELLP
        DC      FROMR
        DC      PLUS
        DC      TOR
        DC      LTYPE
        DC      SEMIS
;
worddocsafe({OUTPUT},{."},{dot_quote},{},{P,L0},
{Used in the form:
  forthsamp({." cccc"})
Compiles an in-line string forthsamp({cccc}) (delimited by the trailing ") with
an execution proceedure to transmit the text to the selected output
device.
If executed outside a definition, forthcode({."}) will immediately print the text
until the final ". The maximum number of characters may be an
installation dependent value.},{{OUT},{(.")}})
HEADER({."},{DOTQ},{DOCOL},B_IMMED)
        DC      LIT,22H
        DC      STATE
        DC      FETCH
        _0BRANCH(DOTQ1) ;{ IF}
        DC      COMP
        DC      PDOTQ
        DC      PPARS
        DC      SCOMMA, DROP
        _BRANCH(DOTQ2)  ;{ ELSE}
DOTQ1:  DC      PPARS
        DC      LTYPE   ;{ ENDIF}
DOTQ2:  DC      SEMIS
;
worddoc({PARSING},{QUERY},{query},{},{},
{Input 80 characters of text (or until a "return") from the operators
terminal. Text is positioned at the address contained in forthcode({TIB}) with forthcode({IN})
set to zero.
},{})
HEADER({QUERY},{QUERY},{DOCOL})
        DC      TIB
        DC      FETCH
        DC      LIT,RTS/2
        DC      ACCEP
; Keep the next line in for debugging ACCEPT for MSDOS.
;        DC      LIT, 41H, EMIT, TDUP, LTYPE, LIT, 41H, EMIT
        DC      LDUP
        DC      TIB
        DC      FETCH
        DC      PLUS, ZERO, SWAP, CSTOR ; {Delimiting zero.}
        DC      ZERO, LIN, STORE
        DC      TIB, FETCH
        DC      LDUP, SOURC, STORE
        DC      LDUP, SOURC, CELLP, CELLP, STORE ; { IN}
        DC      PLUS, SOURC, CELLP, STORE
;        DC      DOTS
        DC      SEMIS
;
worddoc({MEMORY},{FILL},{fill},{addr quan b --},{},
{Fill memory at the address with the specified quantity of bytes forthvar({b}) .},{})
CODE_HEADER({FILL},{FILL})
        POP     AX      ;{ FILL CHAR}
        POP     CX      ;{ FILL COUNT}
        POP     DI      ;{ BEGIN ADDR}
;{       MOV    BX,DS}
;{       MOV    ES,BX   ; ES <- DS}
        CLD             ;{ INC DIRECTION}
        REP     STOSB   ;{STORE BYTE}
        _NEXT
;
worddoc({MEMORY},{CORA},{CORA},{addr1 addr2 len  -- n},{},
{Compare the memory areas at forthsamp({addr1}) and forthsamp({addr2})
over a length forthsamp({len}) .
For the first bytes that differ, return the difference between the byte
from forthsamp({addr1}) and the one from forthsamp({addr2}),
or zero if all forthsamp({len}) bytes are equal.
_VERBOSE_({This is an abbreviation of forthcode({COMPARE-AREA}).
It should have been named forthsamp({COMPARE}) ,
but that is taken by ISO.})
},
{},
{{ HEX 41 C, 42 C, 43 C, HERE 3 - DUP 3 CORA .},{0 },
{HERE 2 - HERE 3 - 2 CORRA . },{1 },
{HERE 3 - HERE 2 - 2 CORA .},{-1 }}
)
CODE_HEADER({CORA},{CORA})
;{       MOV    ES,BX   ; ES <- DS}
;{       MOV    BX,DS}
        MOV     DX,SI
        XOR     AX,AX   ;{ Result}
        POP     CX      ;{ count}
        POP     DI      ;{ addr2}
        POP     SI      ;{ addr1}
        CLD             ;{ INC DIRECTION}
        REP     CMPSB   ;{ Compare BYTE}
        JZ      CORA3
        MOV     AL,1    ;{Remainder is already 0}
        JNC     CORA3
        NEG     AX
CORA3:
        MOV     SI,DX
        _PUSH
;
worddoc({MEMORY},{ERASE},{erase},{addr n --},{},
{Shorthand for ``forthvar({0}) forthcode({FILL})''.},{})
HEADER({ERASE},{LERASE},{DOCOL})
        DC      ZERO
        DC      FILL
        DC      SEMIS
;
worddoc({MEMORY},{BLANKS},{blanks},{addr count --},{},
{Shorthand for ``forthcode({BL}) forthcode({FILL})''.},{})
HEADER({BLANKS},{BLANK},{DOCOL})
        DC      LBL
        DC      FILL
        DC      SEMIS
;
worddoc({FORMATTING},{HOLD},{hold},{c ---},{ISO FIG},
{Add the character forthvar({c}) to the beginning of the output string.
It must be executed for numeric formatting inside a forthcode({<#})
and forthcode({#>}) construct .
},{{#},{DIGIT}})
HEADER({HOLD},{HOLD},{DOCOL})
        DC      LIT,-1
        DC      HLD
        DC      PSTOR
        DC      HLD
        DC      FETCH
        DC      CSTOR
        DC      SEMIS
;
worddoc({DICTIONARY},{PAD},{pad},{--- addr},{L0},
{Leave the address of the text output buffer, which is a fixed offset
above forthcode({HERE}) .},{})
HEADER({PAD},{PAD},{DOCOL})
        DC      HERE
        DC      LIT,84
        DC      PLUS
        DC      SEMIS
;
worddoc({PARSING},{AWORD},{newword},{c ---addr},{ISO L0},
{Parse the forthsamp({current input stream}) using forthsamp({c}) for a delimiter.
Skip leading delimiters then advance the input pointer to past
the next delimiter or past the end of the input stream.
Leave at forthsamp({addr}) as a counted string a copy of the string,
that was surrounded by forthsamp({c}) in the input stream.
In ciforth the character string is positioned
at the dictionary buffer forthcode({HERE}) .
forthcode({WORD})
leaves the character count in the first byte, the characters, and
ends with two or more blanks.
If forthcode({BLK}) is zero text is taken from the terminal input buffer,
otherwise from the disc block stored in forthcode({BLK}) .},
{{BLK} ,{IN}},
{{: GS2 BL WORD COUNT . C@ EMIT ; GS3 CELLO . .},{5 C},
{HEX : GS1 5A WORD COUNT . C@ EMIT ; GS1 ZZZQQZ},{2 Q}})
HEADER({WORD},{AWORD},{DOCOL})
        DC      LDUP, LBL, EQUAL
        _0BRANCH(AWORD1)
         DC      DROP
         DC      PWORD
        _BRANCH(AWORD2)
AWORD1:
        DC      PPARS
;        DC      DOTS
AWORD2:
        DC      HERE
        DC      LIT,22H
        DC      BLANK
        DC      HERE
        DC      SSTORBD     ; {FIXME}
        DC      HERE
;        DC      DOTS
        DC      SEMIS
;
worddoc({PARSING},{&:},{char_follows}, {--- c},{CI},
{Leave forthvar({c}) the non blank char that follows.
Skip remaining non-blank characters.},
{{}},
{{&: HELL HEX .},{48 },
{&: X  HEX .},{58 }},
{{: GS1 &: HELLO ; GS1 HEX .] },{48 },
{: GS1 &: X ; GS1 HEX .},{58 }})
HEADER({&:},{CHF},{DOCOL}, B_IMMED)
        DC      PWORD, DROP, CFET, LITER
        DC      SEMIS
;
worddoc({PARSING},{^:},{control_follows}, {--- c},{CI},
{Leave forthvar({c}) the control version of the non blank char that follows.
Skip remaining non-blank characters.},
{{}},
{{^: HELL HEX .},{8 },
{^: X  HEX .},{18 }},
{{: GS1 ^: HELLO ; GS1 HEX .] },{8 },
{: GS1 ^: X ; GS1 HEX .},{18 }})
HEADER({^:},{CTF},{DOCOL}, B_IMMED)
        DC       PWORD, DROP, CFET, LIT, 40H, LSUB, LITER
        DC      SEMIS
;
worddoc({PARSING},{CHAR},{char}, {--- c},{ISO},
{Parse a word and
leave forthvar({c}) the first non blank char of that word
input stream.},
{{}},
{{CHAR HELLO HEX .},{48 },
{CHAR X  HEX .},{58 }})
HEADER({CHAR},{LCHAR},{DOCOL})
        DC      CHF
        DC      SEMIS
;
worddocsafe({PARSING},{[CHAR]},{ bracket_char_bracket}, {--- c},{ISO I},
{A compiling word. Parse a word.  Add the run time behaviour:
leave forthvar({c}), the first non blank char of that word in the
input stream.},
{{}},
{{: GS1 [CHAR] HELLO ; GS1 HEX .] },{48 },
{: GS1 [CHAR] X ; GS1 HEX .},{58 }})
HEADER({[CHAR]},{BCHAR},{DOCOL},B_IMMED)
        DC      CHF
        DC      SEMIS
;
worddocsafe({FORMATTING},{(NUMBER)},{paren_number},{ --- d1},{},
{Convert the ascii text at the current input stream with regard to forthcode({BASE}) .
The
new value is accumulated into double number forthvar({d1}) , being left.
The only non-digit acceptable is a decimal point, that signifies that
the input is to be considered as a double.
If the first unconvertable digit is not a blank, this is an error. },
{{NUMBER},{?BLANK}})
HEADER({(NUMBER)},{PNUMB},{DOCOL})
        DC      ZERO, ZERO
        DC      ZERO, DPL, STORE
NPNUM1:  DC      INBRS   ;{ BEGIN}
        DC      LDUP, LIT, ADOT, EQUAL
        _0BRANCH(NPNUM2) ;{ IF}
        DC      DROP, DPL, STORE, ZERO
        _BRANCH(NPNUM3) ;{ ELSE}
NPNUM2:
        DC      LDUP, QBL
        _0BRANCH(NPNUM4) ;{ IF}
        DC      DROP, DROP, ONE
        _BRANCH(NPNUM3) ;{ ELSE}
NPNUM4:
        DC      SWAP, DROP
        DC      BASE, FETCH, DIGIT
        DC      ZEQU, ZERO, QERR

        DC      SWAP
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DROP
        DC      ROT
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DPLUS
        DC      ZERO
NPNUM3:                 ; {THEN THEN}
        _0BRANCH(NPNUM1)
        DC      SEMIS
;

worddoc({FORMATTING},{NUMBER},{number},{ ---  s/d},{},
{Convert characters from the current input stream
into a number, and compile or execute this number.
If the string contains a 
decimal point it is a double else a single integer number.
If numeric conversion is
not possible, an error message will be given.},{{BASE},{(NUMBER)}})
HEADER({NUMBER},{NUMB},{DOCOL})
        DC      PNUMB, SDLITE
        DC      SEMIS
;
;
worddoc({DICTIONARY},{FIND:},{paren_find},{"name" --- dea},{},
{Parse a blank-delimited string from the current input stream and
look the string up according to forthcode({(FIND)}) .
If found, and it is not a denotation, 
leave the dictionary entry
address forthsamp({dea}) of the first entry found, else leave a
nil pointer.},
{})
HEADER({FIND:},{DDFIND},{DOCOL})
        DC      PWORD, PFIND
        DC      LDUP, TFFA, FETCH,
        DC      LIT, B_DENOT, LAND
        _0BRANCH(DDFIND1) ;{IF}
        DC      DROP, ZERO
DDFIND1:               ;{ENDIF}
        DC SEMIS
;
worddoc({DICTIONARY},{(FIND)},{paren_find},{sc --- dea)},{},
{For the string constant forthsamp({sc}) search the
forthcode({CONTEXT}) and then forthcode({CURRENT}) vocabularies
for a matching entry. If found, leave the dictionary entry
address forthsamp({dea}) of the first entry found, else leave a
nil pointer.},
{})
HEADER({(FIND)},{PFIND},{DOCOL})
        DC      ZERO, RESULT, STORE
        DC      CONT, FETCH
        DC      LIT, MATCHING, SWAP, FORW
        DC      RESULT, FETCH, ZEQU
        _0BRANCH(DFIN1)
        DC      CURR, FETCH
        DC      LIT, MATCHING, SWAP, FORW
        DC      RESULT, FETCH, ZEQU
        _0BRANCH(DFIN1)
        DC      DROP, ONE
        DC      LIT, _DEA(DENOT) + CELLS(D_HOFFSET  + 1)
        DC      LIT, MATCHING, SWAP, FORW
DFIN1:
        DC      DROP, DROP
        DC      RESULT,FETCH
        DC      SEMIS
;
worddocsafe({INIT},{(ABORT)},{paren_abort},{},{},
{Executes after an error when forthcode({WARNING}) is -1. This word normally
executes forthcode({ABORT}), but may be altered (with care) to a user's
alternative proceedure forthvar({AP}) as follows:
forthsamp({ 'O AP 'O (ABORT) >PFA !}).
},{})
HEADER({(ABORT)},{PABOR},{DOCOL})
        DC      ABORT
        DC      SEMIS
;
worddoc({ERRORS},{ERROR},{error},{line --- in blk},{},
{Execute error notification and restart of system. forthcode({WARNING}) is first
examined. If 1, the text of line forthvar({n}) , relative to screen 4 of drive O
is printed. This line number may be positive or negative, and beyond
just screen 4. If forthcode({WARNING}) is zero, forthvar({n}) is just printed as a message number
(non disc installation). If forthcode({WARNING}) is -l, the definition forthcode({(ABORT)}) is
executed, normally a warm start via forthcode({QUIT}) .},{QERROR})
HEADER({ERROR},{ERROR},{DOCOL})
        DC      WARN
        DC      FETCH
        DC      ZLESS
        _0BRANCH(ERRO1) ;{IF}
        DC      PABOR   ;{ENDIF}
ERRO1:  DC      HERE
        DC      COUNT
        DC      LTYPE
        DC      PDOTQ
        _STRING({? })
        DC      MESS
        DC      SPSTO
        DC      BLK,FETCH
        DC      DDUP
        _0BRANCH(ERRO2) ;{ IF}
        DC      DOT
        DC      LIN,FETCH, SOURC, FETCH, LSUB
        DC      DOT    ;{ENDIF}
ERRO2:  DC      QUIT
;
worddoc({DICTIONARY},{ID.},{i_d_dot},{dea --},{},
{Print a definition's name from its dictionary entry address.},{{'},{>PFA},{>NFA}})
HEADER({ID.},{IDDOT},{DOCOL})
        DC      TNFA
        DC      FETCH
        DC      DDUP
        _0BRANCH(IDDOT1)
        DC      SFET
        DC      LTYPE
        DC      SPACE
        DC      SPACE
        DC      SPACE
IDDOT1:
        DC      SEMIS
;
worddoc({DEFINING},{CREATE},{create},{},{},
{A defining word used in the form:
     forthcode({CREATE}) forthvar({cccc})
by such words as forthcode({CODE}) and forthcode({CONSTANT}) to create a dictionary header for
a Forth definition. The code field contains the address of the words
parameter field. },{})
HEADER({CREATE},{CREAT},{DOCOL})
        DC      PWORD
        DC      LDUP
        DC      ZEQU
        DC      LIT,5
        DC      QERR
        DC      TDUP
        DC      PFIND
        DC      LDUP
        _0BRANCH(CREA1) ;{IF}
        DC      LDUP, TFFA, FETCH,
        DC      LIT, B_DENOT, LAND, ZEQU
        _0BRANCH(CREA1) ;{IF}
        DC      IDDOT
        DC      LIT,4
        DC      MESS
        DC      SPACE   ;{ENDIF}
        DC      ZERO
CREA1:  DC      DROP
        DC      SCOMMA
        DC      HERE,TOR
        DC      COMMA   ; {Name field.}
        DC      ZERO,COMMA ; {Flag field.}
        DC      LATES
        DC      COMMA   ; {Link field.}
        DC      FROMR
        DC      CURR
        DC      FETCH
        DC      TLFA
        DC      STORE
        DC      HERE
        DC      CELLP
        DC      COMMA   ; {Code field.}
        DC      SMUDG
        DC      SEMIS
        PAGE
worddoc({COMPILING},{[COMPILE]},{bracket_compile},{},{p,C},
{Used in a colon-definition in form:
forthexample({:  xxx    [COMPILE]   FORTH   ;})
forthcode({[COMPILE]}) will force the compilation of an immediate definitions,
that would otherwise execute during compilation. The above example
will select the forthcode({FORTH}) vocabulary then forthvar({xxx}) executes, rather than at
compile time.},{COMPILE})
HEADER({[COMPILE]},{BCOMP},{DOCOL},B_IMMED)
        DC      PWORD
        DC      PFIND
        DC      LDUP
        DC      ZEQU
        DC      ZERO
        DC      QERR
        DC      TCFA
        DC      COMMA
        DC      SEMIS
;
worddoc({COMPILING},{LITERAL},{literal},{n --- (compiling)},{P,C2,L0},
{If compiling, then compile the stack value forthvar({n}) as a 16 bit literal.
This definition is immediate so that it will execute during a colon
definition. The intended use is:
     forthsamp({: xxx    [ calculate ]  LITERAL  ;})
Compilation is suspended for the compile time calculation of a
value.
Compilation is resumed and forthcode({LITERAL}) compiles this value.},{})
HEADER({LITERAL},{LITER},{DOCOL},B_IMMED)
        DC      STATE
        DC      FETCH
        _0BRANCH(LITE1) ;{IF}
        DC      COMP
        DC      LIT
        DC      COMMA   ;{ENDIF}
LITE1:  DC      SEMIS
        PAGE
;
worddoc({COMPILING},{DLITERAL},{dliteral},{d --- d (executing) d --- (compiling)},{P},
{If compiling, compile a stack double number into a literal. Later
execution of the definition containing the literal will push it to
the stack. If executing, the number will remain on the stack.},{})
HEADER({DLITERAL},{DLITE},{DOCOL},B_IMMED)
        DC      STATE
        DC      FETCH
        _0BRANCH(DLIT1) ;{ IF}
        DC      SWAP
        DC      LITER
        DC      LITER   ;{ ENDIF}
DLIT1:  DC      SEMIS
;
;
worddoc({COMPILING},{SDLITERAL},{sdliteral},{d --- s/d (executing) d --- (compiling)},{P},
{If compiling, compile a stack double number into a literal
or double literal, depending on whether forthcode({DPL}) contains a nil pointer
or points into the input.
Later
execution of the definition containing the literal will push it to
the stack. If executing, the number will remain on the stack.},{})
HEADER({SDLITERAL},{SDLITE},{DOCOL},B_IMMED)
        DC      DPL
        DC      FETCH
        _0BRANCH(SDLIT1) ;{ IF}
        DC      DLITE
        _BRANCH(SDLIT2) ;{ IF}
SDLIT1:
        DC      DROP, LITER
SDLIT2:
        DC      SEMIS
;
worddoc({SECURITY},{?STACK},{question_stack},{},{},
{Issue an error message is the stack is out of bounds.},
{{?ERROR}})
HEADER({?STACK},{QSTAC},{DOCOL})
        DC      SPFET
        DC      SZERO
        DC      FETCH
        DC      SWAP
        DC      ULESS
        DC      ONE
        DC      QERR
        DC      SPFET
        DC      HERE
        DC      LIT,80H
        DC      PLUS
        DC      ULESS
        DC      LIT,7
        DC      QERR
        DC      SEMIS
        PAGE
;
worddoc({PARSING},{INTERPRET},{interpret},{},{},
{Repeatedly fetch
the next text word in the input stream and
execute it (forthcode({STATE}) is 1)
or compile it (forthcode({STATE}) is 1).
Text from the input stream: terminal ( forthcode({BLK}) is 0 )
or disc (other value) . If
the word name cannot be found after a search of forthcode({CONTEXT}) and then
forthcode({CURRENT}) it is converted to a number according to the current base.
If a decimal point is found as part of a number, the number value that
is left is a double number, otherwise a single number. The decimal
point has no other purpose.
That also failing, an error message echoing the name with a " ?"
will be given.
},{{WORD},{NUMBER}})
HEADER({INTERPRET},{INTER},{DOCOL})
INTE1:
        DC      PWORD
        DC      LDUP      ;{ Zero length.}
        _0BRANCH(INTE8) ;{WHILE}
;        DC      DOTS
        DC      OVER, TOR
        DC      PFIND   ;{BEGIN}
        DC      LDUP
        DC      ZEQU, ZERO, QERR
;        DC      LDUP, IDDOT
        DC      LDUP, TFFA, FETCH, LIT, B_DENOT, LAND
        _0BRANCH(INTE3A) ;{IF}
        DC      FROMR, LIN, STORE
        _BRANCH(INTE4A)  ;{ELSE}
INTE3A:
        DC      FROMR, DROP
                        ;{ENDIF}
INTE4A:
        DC      LDUP, TFFA, FETCH, LIT, B_IMMED, LAND
        DC      STATE, FETCH, ZEQU, LOR
        _0BRANCH(INTE3) ;{IF}
        DC      TCFA
        DC      EXEC
        _BRANCH(INTE4) ;{IF}
INTE3:
        DC      TCFA
        DC      COMMA
                        ;{ENDIF}
INTE4:  DC      QSTAC
        _BRANCH(INTE1)  ;{AGAIN}
INTE8:  DC      DROP, DROP
        DC      SEMIS
;
worddoc({DICTIONARY},{IMMEDIATE},{immediate},{},{},
{Mark the most recently made definition so that when encountered at
compile time, it will be executed rather than being compiled, i.e.
the precedence bit in its header is set.
This method allows definitions to handle unusual compiling
situations, rather than build them into the fundamental compiler.
The user may force compilation of an immediate definition by
preceeding it with forthcode({[COMPILE]}) .},{})
HEADER({IMMEDIATE},{IMMED},{DOCOL})
        DC      LATES
        DC      TFFA
        DC      LIT, B_IMMED
        DC      TOGGL
        DC      SEMIS
;
worddoc({DEFINING},{VOCABULARY},{vocabulary},{},{E,L},
{A defining word used in the form:
            forthcode({VOCABULARY}) forthvar({cccc})
to create a vocabulary definition forthvar({cccc}) . Subsequent use of forthvar({cccc}) will
make it the forthcode({CONTEXT}) vocabulary which is searched first by forthcode({INTERPRET}) .
The sequence forthvar({cccc}) forthcode({DEFINITIONS}) also make forthvar({cccc}) the forthcode({CURRENT})
vocabulary into which new definitions are placed.

A vocabulary parameter field contains at first the dovoc pointer, then
follows its data field. This
contains a dummy dea (forthdefi({DDEA})) with a name " " (blank) ,
a dummy link field (forthcode({DLFA}))
that points to the dea
of the first word of the vocabulary.
Actually executing the vocabulary means storing its DDEA into forthcode({CONTEXT}) .
Then follows the vocabulary link field address ( forthdefi({VLFA}) )
The VLFA points to the VLFA of the next vocabulary or 0 for the end.

In fig-FORTH, cccc will be so chained as to include all definitions
of the vocabulary in which forthvar({cccc}) is itself defined. All vocabularys
ultimately chain to Forth.
By convention, vocabulary names are to be
declared forthcode({IMMEDIATE}) .},
{{VOC-LINK}})
HEADER({VOCABULARY},{VOCAB},{DOCOL})
        DC      BUILD
        DC      HERE
        DC      BODYF    ;{ Link this DEA into VOC-LINK chain.}
        DC      VOCL
        DC      FETCH
        DC      COMMA
        DC      VOCL
        DC      STORE
        DC      ZERO, COMMA   ;{ Dummy name field}
        DC      LIT, B_DUMMY, COMMA ;{ Dummy flag field}
        DC      CURR
        DC      FETCH
        DC      TLFA
        DC      FETCH
        DC      COMMA    ; { Points to DLFA of current vocabulary.}
        DC      DOES
DOVOC:
        DC      CELLP   ;{ Get dummy DEA. }
        DC      CONT
        DC      STORE
        DC      SEMIS
        PAGE
;
;{   The link to task is a cold start value only.}
;{   It is updated each time a definition is}
;{   appended to the 'FORTH' vocabulary.}
;
worddoc({VOCABULARIES},{FORTH},{forth},{},{P,L1},
{The name of the primary vocabulary.
Execution makes forthcode({FORTH}) the forthcode({CONTEXT}) vocabulary. Until additional user
vocabularies are defined, new user definitions become a part of
forthcode({FORTH}) . forthcode({FORTH}) is immediate, so it will execute during the creation of
a colon-definition, to select this vocabulary at compile time.},{{VOCABULARY}})
HEADER({FORTH},{FORTH},{DODOE},B_IMMED)
        DC      DOVOC
        DC      0       ;{ END OF VOCABULARY LIST}
        DC      0       ;{ Dummy name field}
        DC      B_DUMMY ;{ Dummy flag field}
        DC      _DEA(TASK)
;
worddoc({VOCABULARIES},{ASSEMBLER},{forth},{},{P,L1},
{The name of the primary vocabulary.
Execution makes forthcode({ASSEMBLER}) the forthcode({CONTEXT}) vocabulary.
 forthcode({ASSEMBLER}) is immediate, so it will execute during the creation of
a colon-definition, to select this vocabulary at compile time.
_VERBOSE_({It is defined in the kernel because the forthcode({;CODE}) word needs it.})},
{{VOCABULARY}})
;
worddoc({VOCABULARIES},{DEFINITIONS},{definitions},{},{L1},
{Used in the form:
           forthvar({cccc}) forthcode({DEFINITIONS})
Set the forthcode({CURRENT}) vocabulary to the forthcode({CONTEXT}) vocabulary. In the
example, executing vocabulary name forthvar({cccc}) made it the forthcode({CONTEXT})
vocabulary and executing forthcode({DEFINITIONS}) made both specify vocabulary
forthvar({cccc}) .},{{VOCABULARY}})
HEADER({DEFINITIONS},{DEFIN},{DOCOL})
        DC      CONT
        DC      FETCH
        DC      CURR
        DC      STORE
        DC      SEMIS
;
worddocsafe({PARSING},{(},{paren},{},{P,L0},
{Used in the form:
forthsamp({( cccc)})
Ignore a comment that will be delimited by a right
parenthesis on the same line. May occur during execution or in a
colon-definition. A blank after the leading parenthesis is required.},{})
HEADER({(},{PAREN},{DOCOL},B_IMMED)
        DC      LIT,')'
        DC      PPARS
        DC      DROP, DROP
        DC      SEMIS
;
worddoc({INIT},{QUIT},{quit},{},{},
{Clear the return stack, stop compilation, and return control to the
operators terminal. No message is given.},{})
HEADER({QUIT},{QUIT},{DOCOL})
        DC      ZERO
        DC      BLK
        DC      STORE
        DC      LBRAC
QUIT1:  DC      RPSTO   ;{BEGIN}
        DC      CR
        DC      QUERY
        DC      INTER
        DC      STATE
        DC      FETCH
        DC      ZEQU
        _0BRANCH(QUIT2) ;{IF}
        DC      PDOTQ
        _STRING({OK})   ;{ENDIF}
QUIT2:  _BRANCH(QUIT1)  ;{AGAIN}
;
worddoc({INIT},{ABORT},{abort},{},{FIG NISO L0},
{Clear the stacks and enter the execution state. Set BASE to
decimal._VERBOSE_({Note how this is different from COLD , where the
bootup value is reinstalled(!)}) Return control to the operators
terminal, printing a startup message with the version number.
},{{WARM}})
HEADER({ABORT},{ABORT},{DOCOL})
        DC      SPSTO
        DC      HEX
        DC      QSTAC   ;{ IT DID TO & INCL THIS}
        DC      CR
        DC      DOTCPU
        DC      PDOTQ

_COMMENT
;{       If this is there it is an official release}
        DB      22
        DB      'IBM-PC Fig-Forth'
        DB      FIGREL+30H,ADOT,FIGREV+30H,ADOT,USRVER+30H
_ENDCOMMENT
;{       If this is there it is a beta release}
        _STRING({IBM-PC $RCSfile$ $Revision$ })
        DC      FORTH
        DC      DEFIN
        DC      QUIT
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
        PAGE
;{      WARM START VECTOR COMES HERE}
;
WRM:    MOV     SI,_OFFSET WRM1
        _NEXT
;
WRM1:   DC      WARM
;
worddoc({INIT},{WARM},{warm},{},{FIG L0},
{Discard blocks; they may not be written back to mass storage.
Clear the stacks and enter the execution state. Return control to
the operators terminal, printing a startup message with the version number.
},{{ABORT}})
HEADER({WARM},{WARM},{DOCOL})
        DC      MTBUF
        DC      ABORT
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
;
;{      COLD START VECTOR COMES HERE}
;
LCLD:    MOV     SI,_OFFSET CLD1  ;{ (IP) <-}
_COMMENT
_HOSTED_MSDOS_({
        PUSH    DS
        MOV     AX,0
        MOV     DS,AX           ;{TO VECTOR AREA}
        MOV     BX,08CH
        LEA     AX,[WRM]
        MOV     [BX],AX         ;{JUMP TO WRM ON <CTRL-BREAK>}
        INC     BX
        INC     BX
        MOV     [BX],CS
        POP     DS
});_END_({ _HOSTED_MSDOS_})
_ENDCOMMENT
        CLD                     ;{ DIR = INC}
        MOV     STACKPOINTER,_CELL_PTR[USINI+CELLS(3)]    ;{PARAM. STACK}
        MOV     BP,_CELL_PTR[USINI+CELLS(4)]    ;{RETURN STACK}
        _NEXT
;
CLD1:   DC      COLD
;
worddoc({INIT},{COLD},{cold},{},{FIG},
{The cold start proceedure to adjust all user variables to their intial
values, i.a. the stacks and the dictionary pointers. Restart via
forthcode({ABORT}) . May be called from the terminal to remove
application programs and restart.
_RWFILE_({Opens the file that contains the blocks.})
_HOSTED_LINUX_({Opens the file that contains the blocks.})
},{{WARM},{BLOCK},{LIST}})
HEADER({COLD},{COLD},{DOCOL})
        DC      MTBUF
        DC      FIRST
        DC      STALEST,STORE
        DC      FIRST
        DC      PREV,STORE
        DC      LIT, USINI
        DC      LIT,USINI+CELLS(1)
        DC      FETCH
        DC      LIT,US
        DC      LCMOVE
_LINUX_N_({
        DC      ZERO, LIT, TCGETS, TERMIO
        DC      LIT, ioctl, LINOS, ZLESS
        _0BRANCH(COLD1)
        DC      LIT, STTERM_A
        DC      LIT, _PARAMETER_FIELD(STTERM)
        DC      LIT, STTERM_B-STTERM_A
        DC      LCMOVE
        DC      LIT, ACCEP_A
        DC      LIT, _PARAMETER_FIELD(ACCEP)
        DC      LIT, ACCEP_B-ACCEP_A
        DC      LCMOVE
COLD1:
});_END_({_LINUX_N_})
_BLOCKSINFILE_({
        DC      BLINI
});_END_({_BLOCKSINFILE_})
        DC      ABORT
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
;
        PAGE
worddoc({DOUBLE},{S->D},{s_to_d},{n --- d},{},
{Sign extend a single number to form a double number.},{})
CODE_HEADER({S->D},{STOD})
        POP     DX      ;{S1}
        SUB     AX,AX
        OR      DX,DX
        JNS     STOD1   ;{POS}
        DEC     AX      ;{NEG}
STOD1:  _2PUSH
;
worddoc({FORMATTING},{+-},{plus_minus},{n1 n2 --- n3},{},
{Apply the sign of forthvar({n2}) to forthvar({n1}) , which is left as forthvar({n3}) .},
{{SIGN},{#S},{<#},{D+-}})
HEADER({+-},{PM},{DOCOL})
        DC      ZLESS
        _0BRANCH(PM1)   ;{IF}
        DC      MINUS   ;{ENDIF}
PM1:    DC      SEMIS
;
worddoc({FORMATTING},{D+-},{d_plus_minus},{d1 n --- d2},{},
{Apply the sign of forthvar({n}) to the double number forthvar({d1}) , leaving it as forthvar({d2}) .}
,{{SIGN},{#S},{<#},{+-}})
HEADER({D+-},{DPM},{DOCOL})
        DC      ZLESS
        _0BRANCH(DPM1)  ;{IF}
        DC      DMINU   ;{ENDIF}
DPM1:   DC      SEMIS
;
worddoc({OPERATOR},{ABS},{abs},{n --- u},{L0},
{Leave the absolute value of forthvar({n}) as forthvar({u}) .},{})
HEADER({ABS},{LABS},{DOCOL})
        DC      LDUP
        DC      PM
        DC      SEMIS
;
worddoc({DOUBLE},{DABS},{d_abs},{d --- ud},{},
{Leave the absolute value forthvar({ud}) of a double number.},{{DMINUS}})
HEADER({DABS},{DABS},{DOCOL})
        DC      LDUP
        DC      DPM
        DC      SEMIS
;
worddoc({OPERATOR},{MIN},{min},{n1 n2 --- min},{L0},
{Leave the smaller of two numbers.},{{MAX}})
HEADER({MIN},{MIN},{DOCOL})
        DC      TDUP
        DC      GREAT
        _0BRANCH(MIN1)  ;{IF}
        DC      SWAP    ;{ENDIF}
MIN1:   DC      DROP
        DC      SEMIS
;
worddoc({OPERATOR},{MAX},{max},{n1 n2 --- max},{L0},
{Leave the greater of two numbers.},{{MIN}})
HEADER({MAX},{MAX},{DOCOL})
        DC      TDUP
        DC      LESS
        _0BRANCH(MAX1)  ;{IF}
        DC      SWAP    ;{ENDIF}
MAX1:   DC      DROP
        DC      SEMIS
;
worddoc({MULTIPLYING},{M*},{m_star},{n1 n2 --- d},{},
{A mixed magnitude math operation which leaves the double number
 forthvar({d}) : the signed product of two signed number forthvar({n1}) and forthvar({n2}) .},{{M/MOD},{M/},{*}})
HEADER({M*},{MSTAR},{DOCOL})
        DC      TDUP
        DC      LXOR
        DC      TOR
        DC      LABS
        DC      SWAP
        DC      LABS
        DC      USTAR
        DC      FROMR
        DC      DPM
        DC      SEMIS
;
worddoc({MULTIPLYING},{M/},{m_slash},{d n1 --- n2 n3},{},
{A mixed magnitude math operator which leaves the signed remainder forthvar({n2})
and signed quotient forthvar({n3}) from a double number dividend forthvar({d}) and divisor forthvar({n1}) .
The remainder takes its sign from the dividend.},{{M/MOD},{/},{M*}})
HEADER({M/},{MSLAS},{DOCOL})
        DC      OVER
        DC      TOR
        DC      TOR
        DC      DABS
        DC      RR
        DC      LABS
        DC      USLAS
        DC      FROMR
        DC      RR
        DC      LXOR
        DC      PM
        DC      SWAP
        DC      FROMR
        DC      PM
        DC      SWAP
        DC      SEMIS
;
worddocsafe({OPERATOR},{*},{star},{n1 n2 --- prod},{L0},
{Leave the signed product of two signed numbers.},{{+},{-},{/},{MOD}})
HEADER({*},{STAR},{DOCOL})
        DC      MSTAR
        DC      DROP
        DC      SEMIS
;
worddoc({OPERATOR},{/MOD},{slash_mod},{n1 n2 --- rem quot},{L0},
{Leave the remainder and signed quotient of forthvar({n1/n2}) . The remainder has
the sign of the dividend.},{{*/MOD},{*/},{M/MOD}})
HEADER({/MOD},{SLMOD},{DOCOL})
        DC      TOR
        DC      STOD
        DC      FROMR
        DC      MSLAS
        DC      SEMIS
;
worddoc({OPERATOR},{/},{slash},{n1 n2 --- quot},{L0},
{Leave the signed quotient of forthvar({n1/n2}) .
It the result is interpreted as logical value, it means forthvar({n1}) si not equal
to forthvar({n2}) },{{+},{-},{*},{MOD},{*/MOD}})
HEADER({/},{SLASH},{DOCOL})
        DC      SLMOD
        DC      SWAP
        DC      DROP
        DC      SEMIS
;
worddoc({OPERATOR},{MOD},{mod},{n1 n2 --- mod},{L0},
{Leave the remainder of forthvar({n1/n2}) , with the same sign as forthvar({n1}) .},
{{+},{-},{*},{/},MOD,{*/MOD}})
HEADER({MOD},{LMOD},{DOCOL})
        DC      SLMOD
        DC      DROP
        DC      SEMIS
;
worddoc({MULTIPLYING},{*/MOD},{start_slash_mod},{n1 n2 n3 --- n4 n5},{L0},
{Leave the quotient forthvar({n5}) and remainder forthvar({n4}) of the operation forthvar({n1*n2/n3}) A
31 bit intermediate product is used as for forthcode({*/}) .},{{*/},{/MOD}})
HEADER({*/MOD},{SSMOD},{DOCOL})
        DC      TOR
        DC      MSTAR
        DC      FROMR
        DC      MSLAS
        DC      SEMIS
;
worddoc({MULTIPLYING},{*/},{star_slash},{n1 n2 n3 --- n4},{L0},
{Leave the ratio forthvar({n4 = n1*n2/n3}) where all are signed numbers.
Retention of an intermediate 31 bit product permits greater accuracy
than would. be available with the sequence:
      forthsamp({n1 n2 * n3 /})
},{{*/MOD},{/MOD}})
HEADER({*/},{SSLA},{DOCOL})
        DC      SSMOD
        DC      SWAP
        DC      DROP
        DC      SEMIS
;
worddoc({MULTIPLYING},{M/MOD},{m_slash_mod},{ud1 u2 --- u3 ud4},{},
{An unsigned mixed magnitude math operation which leaves a double
quotient forthvar({ud4}) and remainder forthvar({u3}) , from a double dividend forthvar({ud1}) and single
divisor forthvar({u2}) .},{{/MOD},{M/},{M*}})
HEADER({M/MOD},{MSMOD},{DOCOL})
        DC      TOR
        DC      ZERO
        DC      RR
        DC      USLAS
        DC      FROMR
        DC      SWAP
        DC      TOR
        DC      USLAS
        DC      FROMR
        DC      SEMIS
;
worddocsafe({SCREEN},{(LINE)},{paren_line},{n1 n2 --- addr count},{},
{Convert the line number forthcode({n1}) and the screen forthvar({n2}) to the disc buffer
address containing the data. A count of 64 indicates the full line
text length.},{{-LINE}})
HEADER({(LINE)},{PLINE},{DOCOL})
        DC      TOR
        DC      LIT,64
        DC      BBUF
        DC      SSMOD
        DC      FROMR
        DC      PLUS
        DC      BLOCK
        DC      PLUS
        DC      LIT,64
        DC      SEMIS
;
worddoc({SCREEN},{.LINE},{dot_line},{line scr --},{},
{Print on the terminal device, a line of text from the disc by its
line and screen number. _VERBOSE_(
{Trailing blanks are suppressed,
which leads to a tremendous speed advantage on modern glass tty's.})},{{C/L}})
HEADER({.LINE},{DLINE},{DOCOL})
        DC      PLINE
        DC      DTRAI
        DC      LTYPE
        DC      SEMIS
;
worddoc({ERRORS},{MESSAGE},{message},{n --},{},
{Print on the selected output device the text of line forthvar({n}) relative to
screen 4 of drive 0. forthvar({n}) may be positive or negative. forthcode({MESSAGE}) may be
used to print incidental text such as report headers. If forthcode({WARNING}) is
zero, the message will simply be printed as a number (disc
unavailable).},{})
HEADER({MESSAGE},{MESS},{DOCOL})
        DC      WARN
        DC      FETCH
        _0BRANCH(MESS1) ;{IF}
        DC      DDUP
        _0BRANCH(MESS2) ;{IF}
        DC      LIT,4
        DC      DLINE
        DC      SPACE   ;{ENDIF}
MESS2:  _BRANCH(MESS3)  ;{ELSE}
MESS1:  DC      PDOTQ
        _STRING({MSG # })
        DC      DOT     ;{ENDIF}
MESS3:  DC      SEMIS
;
worddocsafe({MEMORY},{PC@},{port_char_fetch},{port --- b},{},
{Fetch a byte forthvar({b}) from the port address
forthvar({port}). A port address is always 16 bits .},
{{PC!},{P@},{P!},{@}})
CODE_HEADER({PC@},{PCFET})
;{ FETCH CHARACTER (BYTE) FROM PORT}
        POP     DX      ;{ PORT ADDR}
        XOR     AX,AX
        IN      AL,{DX}   ;{ BYTE INPUT}
        _PUSH
;
worddoc({MEMORY},{PC!},{port_char_store},{b port --- },{},
{Store a byte forthvar({b}) to the port address
forthvar({port}).
A port address is always 16 bits .},
{{PC@},{P!},{P@},{!}})
CODE_HEADER({PC!},{PCSTO})
        POP     DX      ;{PORT ADDR}
        POP     AX      ;{DATA}
        OUT     {DX},AL   ;{ BYTE OUTPUT}
        _NEXT
;
worddocsafe({MEMORY},{P@},{port_fetch},{port --- n},{},
{Fetch the _BITS_ bit contents forthvar({n}) from the port address
forthvar({port}). A port address is always 16 bits .},
{{P!},{PC@},{PC!},{@}})
CODE_HEADER({P@},{PFET})
        POP     DX      ;{PORT ADDR}
        IN      AX,{DX}   ;{WORD INPUT}
        _PUSH
;
worddoc({MEMORY},{P!},{port_store},{n port --- },{},
{Store the _BITS_ bit data forthvar({n}) to the port address
forthvar({port}) .},
{{P@},{PC!},{PC@},{!}})
CODE_HEADER({P!},{PSTO})
        POP     DX      ;{PORT ADDR}
        POP     AX      ;{DATA}
        OUT     {DX},AX   ;{WORD OUTPUT}
        _NEXT
;
worddoc({STORAGE},{STALEST},{stalest},{--- addr},{},
{A variable containing the address of the oldest
block buffer, the first candidate to be claimed if a new
one is needed.},{{BLOCK}})
HEADER({STALEST},{STALEST},{DOVAR})
        DC BUF1
;
worddoc({STORAGE},{PREV},{prev},{---- addr},{},
{A variable containing the address of the disc buffer most recently
referenced. The forthcode({UPDATE}) command marks this buffer to be
later written to disc.},{{BLOCK}})
HEADER({PREV},{PREV},{DOVAR})
        DC      BUF1
;
worddoc({STORAGE},{#BUFF},{hash_buf},{--- c},{},
{A constant that leaves the number of block buffers.
},
{{BLOCK}})
HEADER({#BUFF},{NOBUF},{DOCON})
        ;{NO. OF BUFFERS}
        DC      NBUF
;
worddoc({STORAGE},{+BUF},{plus_buf},{add1 --- addr2 f},{FIG},
{Advance the disc buffer address forthvar({addr1}) to the address of
the next buffer forthvar({addr2}) . Boolean forthvar({f}) is false
when forthvar({addr2}) is the buffer presently pointed to by variable
forthcode({PREV})},{{BLOCK}})
HEADER({+BUF},{PBUF},{DOCOL})
        DC      LIT,(KBBUF+2*CW)
        DC      PLUS,LDUP
        DC      LIMIT,EQUAL
        _0BRANCH(PBUF1)
        DC      DROP,FIRST
PBUF1:  DC      LDUP,PREV
        DC      FETCH,LSUB
        DC      SEMIS
;
worddoc({STORAGE},{UPDATE},{update},{},{L0},
{Marks the most recently referenced block (pointed to by
forthcode({PREV}) ) as altered. The block will subsequently be
transferred automatically to disc should its buffer be required for
storage of a different block.},{{BLOCK},{SCREEN}})
HEADER({UPDATE},{UPDAT},{DOCOL})
        DC      PREV, FETCH
        DC      LDUP, CELLP,CELLP
        DC      SWAP, FETCH
        DC      ZERO
        DC      RSLW
        DC      SEMIS
;
worddoc({STORAGE},{EMPTY-BUFFERS},{empty_buffers},{},{ISO FIG L0},
{Mark all block-buffers as empty, not necessarily affecting the
contents. Updated blocks are not written to the disc. This is also an
initialization proceedure before first use of the
disc.},{{FLUSH},{BLOCK},{SCREEN}})
HEADER({EMPTY-BUFFERS},{MTBUF},{DOCOL})
        DC      FIRST
        DC      LIMIT,OVER
        DC      LSUB,LERASE
        DC      SEMIS
        PAGE
;
worddoc({STORAGE},{BUFFER},{buffer},{n --- addr},{ISO FIG},
{Obtain the next memory buffer, assigning it to block forthvar({n}) .
In ciforth blocks can be locked, and locked buffers are skipped
in this process.
If the contents of the buffer is marked as updated, it is written to
the disc. In ciforth this is never needed, because updated blocks are
written immediately.
The block is not read from the disc.
 The address left is the
field within the buffer to be used
for data storage.},
{{BLOCK},{STALEST},{PREV}})
HEADER({BUFFER},{BUFFE},{DOCOL})
;{ NOTE: THIS WORD WON'T WORK IF ONLY USING SINGLE BUFFER}
        DC      STALEST, FETCH
        DC      LDUP, TOR
BUFF1:  DC      PBUF            ;{ Skip PREV buffer.}
        _0BRANCH(BUFF1)
        DC      LDUP, CELLP, FETCH, ZEQU ;{ Skip locked buffers.}
        _0BRANCH(BUFF1)
        DC      STALEST,STORE
        DC      RR,STORE
        DC      RR,PREV, STORE,
        DC      FROMR, CELLP, CELLP
        DC      SEMIS
;
worddoc({STORAGE},{BLOCK},{block},{n --- addr},{ISO FIG L0},
{Leave the memory address of the block buffer containing block forthvar({n}),
which is the physical disk block forthsamp({OFFSET+n}).
If the block is not already in memory, it is transferred from disc to
which ever buffer was least recently written. If the block occupying
that buffer has been marked as updated, it is rewritten to disc
before block forthvar({n}) is read into the buffer.
In ciforth this cannot happen, because updates are written
immediately.
_FEWBLOCKS_({In this experimental version forthsamp({PMASK}) restricts the number of blocks to 0FFH.})},
{{BUFFER},{R/W},{OFFSET},{UPDATE},{FLUSH}})
HEADER({BLOCK},{BLOCK},{DOCOL})
_FEWBLOCKS_({        DC      LIT, PMASK, LAND})
        DC      OFSET
        DC      FETCH,PLUS
        DC      TOR,PREV
        DC      FETCH,LDUP
        DC      FETCH,RR
        DC      LSUB
        DC      LDUP,PLUS
        _0BRANCH(BLOC1)
BLOC2:  DC      PBUF,ZEQU
        _0BRANCH(BLOC3)
        DC      DROP,RR
        DC      BUFFE,LDUP
        DC      RR,ONE
        DC      RSLW
        DC      LCELL,LSUB
        DC      LCELL,LSUB
BLOC3:  DC      LDUP,FETCH
        DC      RR,LSUB
        DC      LDUP,PLUS
        DC      ZEQU
        _0BRANCH(BLOC2)
        DC      LDUP,PREV
        DC      STORE
BLOC1:  DC      FROMR,DROP
        DC      CELLP,CELLP,SEMIS
;
worddoc({STORAGE},{FLUSH},{flush},{},{ISO FIG L0},
{Transfer the content of each UPDATE d block buffer to disk.
They are no longer associated with a block and their content is
no longer available.
},{{EMPTY-BUFFERS},{BLOCK},{SCREEN}})
HEADER({FLUSH},{FLUSH},{DOCOL})
        DC      NOBUF,ONEP
        DC      ZERO,XDO
FLUS1:  DC      ZERO,BUFFE
        DC      DROP
        _LOOP(FLUS1)
        DC      SEMIS
;
worddoc({STORAGE},{SAVE},{save},{ --- },{L0},
{Save the content of forthcode({SOURCE}) on the return stack
prior to changing the forthdefi({current input source}).
This must be balanced by a RESTORE in the same definition.}
{{RESTORE},{RESTORE-INPUT},{SAVE-INPUT}})
HEADER({SAVE},{SAVE},{DOCOL})
        DC      FROMR
        DC      SOURC, TFET
        DC      LIN, FETCH
        DC      TOR, TOR, TOR
        DC      TOR
        DC SEMIS
;
worddoc({STORAGE},{RESTORE},{restore},{ --- },{L0},
{This must follow a forthcode({SAVE}) in the same definition.
Restore the content of forthcode({SOURCE}) from the return stack
thusly restoring the forthdefi({current input source}) to what
it was when the forthcode({SAVE}) was executed.
},
{{RESTORE},{RESTORE-INPUT},{SAVE-INPUT}})
HEADER({RESTORE},{RESTO},{DOCOL})
        DC      FROMR
        DC      FROMR, FROMR, FROMR
        DC      LIN, STORE
        DC      SOURC, TSTOR
        DC      TOR
        DC SEMIS
;
worddoc({STORAGE},{SAVE-INPUT},{save_input},{ --- n1 n2 n3 3},{ISO L0},
{Get a complete specification of the input source stream.
For ciforth this is the content of forthcode({SOURCE}).
ciforth needs 3 cells, and is always able to forthcode({RESTORE}) an input
saved like this. },
{{RESTORE},{RESTORE-INPUT},{SAVE-INPUT}})
HEADER({SAVE-INPUT},{SAVEI},{DOCOL})
        DC      SOURC, TFET
        DC      LIN, FETCH
        DC      LIT, 3
        DC SEMIS
;
worddoc({STORAGE},{RESTORE-INPUT},{restore_input},{ n1 n2 n3 3--- f},{ISO L0},
{Restore the input source stream from what was saved by SAVE-INPUT .
ciforth is always able to restore the input across different
input sources, as long as the input to be restored is not exhausted.},
{{RESTORE},{RESTORE-INPUT},{SAVE-INPUT}})
HEADER({RESTORE-INPUT},{RESTOI},{DOCOL})
        DC      DROP
        DC      LIN, STORE
        DC      SOURC, TSTOR
        DC SEMIS
;
HEADER({LOCK},{LLOCK},{DOCOL})
        DC      ONE
        DC      SOURC, FETCH, LIT, CW, LSUB
        DC      STORE
        DC      SEMIS
;
HEADER({UNLOCK},{LUNLOCK},{DOCOL})
        DC      ZERO
        DC      SOURC, FETCH, LIT, CW, LSUB
        DC      STORE
        DC      SEMIS
;
worddoc({SCREEN},{LOAD},{load},{n ---},{L0},
{Interrupt the current input stream in order to
interpret screen forthvar({n}) .
At the end of the screen, barring errors or forced changes,
it continues with the interrupted input stream.},
{{-->},{QUIT},{;S}})
HEADER({LOAD},{LOAD},{DOCOL})
        DC      BLK, FETCH, TOR
        DC      SAVE
        DC      BLK,STORE       ;{BLK <- SCR * B/SCR}
        DC      BLK, FETCH, BLOCK
        DC      LDUP, SOURC, STORE
        DC      LDUP, LIN, STORE
        DC      LIT, KBBUF, PLUS, SOURC, CELLP, STORE
        DC      LLOCK
        DC      INTER   ;{INTERPRET FROM OTHER}
        DC      LUNLOCK
SCREEN: DC      RESTO
        DC      FROMR, BLK, STORE
        DC      SEMIS
;
worddocsafe({SCREEN},{-->},{next_screen},{},{P,L0},
{Continue interpretation with the next disc screen.},{{LOAD}})
HEADER({-->},{ARROW},{DOCOL},B_IMMED)
        DC      QLOAD
        DC      ONE
        DC      BLK
        DC      PSTOR
        DC      LUNLOCK
        DC      BLK, FETCH, BLOCK
        DC      LDUP, SOURC, STORE
        DC      LDUP, LIN, STORE
        DC      LIT, KBBUF, PLUS, SOURC, CELLP, STORE
        DC      LLOCK
        DC      SEMIS
        PAGE
;
_PC_({
worddoc({SYSTEM},{BIOS},{bios},{a b c d i---ar br cr dr fl},{},
{Do a call of ``BIOS'' interrupt forthvar({i}) with forthsamp({a b c d})
in registers forthsamp({AX BX CX DX}). Upon return those registers contains
forthsamp({ar br cr dr}) and forthsamp({fl}) is the content of the processors flag
register.
},{{BDOS}})
;{ Generic call on BIOS. A boon for experimenters.}
;{ Because there is no such thing as a variable interrupt:}
;{ THIS IS SELF MODIFYING CODE! NOT REENTRANT! DO NOT PUT IN ROM!}
;{ BEWARE OF THE SOFTWARE POLICE!}
CODE_HEADER({BIOS},{BIOS})
        POP     AX      ;{ Function code}
        ;{ Once we are more acknowledgable, put segment overwrite here.}
        MOV     _BYTE_PTR([RQBIOS+1]),AL ;{ Patch the code.}
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        PUSH     SI      ;{ Save Forth registers. NEEDED? }
        PUSH     BP
        XCHG    SI,AX   ;{ Save AX in (already free) SI}
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    {SI},{AX}
RQBIOS: INT(0)          ;{ Request number to be overwritten.}
        PUSHF      ;{ Save status into DI }
        POP     {DI}
        XCHG    {SI},{AX}  ;{ Save AX in (still free) SI     }
        _SWITCH_({JMPHERE_FROM_OS})
        XCHG    SI,AX
        POP     BP      ;{ Restore Forth registers. NEEDED? }
        POP     SI      ;{INTERPRETER PNTR}
        PUSH     AX
        PUSH     BX
        PUSH     CX
        PUSH     DX
        PUSH     DI     ;{ i.e. flags }
        _NEXT
_SWITCH_({SPSAVE: DC       0H})
;{ SELF MODIFYING CODE ENDS HERE! YOU HAVE BEEN WARNED!}

worddoc({SYSTEM},{BDOS},{bdos},{a b c d i---ar br cr dr fl},{},
{Do a call of ``BDOS'' interrupt (21H) with forthsamp({a b c d}) in
registers forthsamp({AX BX CX DX}). Upon return those registers
contains forthsamp({ar br cr dr}) and forthsamp({fl}) is the content
of the processors flag register. This draws upon all facilities made
available by MSDOS. _BOOTFD_({This works in this standalone Forth, but
only if it is started from MSDOS.})
},{{BIOS}})
CODE_HEADER({BDOS},{BDOS})
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        PUSH     SI      ;{ Save Forth registers. NEEDED? }
        PUSH     BP
        XCHG    SI,AX   ;{ Save AX in (already free) SI}
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    {SI},{AX}
        INT     21H
        PUSHF      ;{ Save status into DI }
        POP     {DI} ;{ Not EDI! }
        XCHG    {SI},{AX}   ;{ Save AX in (still free) SI     }
        _SWITCH_({JMPHERE_FROM_OS})
;        XCHG    {SI},{AX}   ; This is more correct actually.
        XCHG    SI,AX
        POP     BP      ;{ Restore Forth registers. NEEDED? }
        POP     SI      ;{INTERPRETER PNTR}
        PUSH     AX
        PUSH     BX
        PUSH     CX
        PUSH     DX
        PUSH     DI     ;{ i.e. flags }
        _NEXT
});_END_({ _PC_})
_HOSTED_LINUX_({
worddoc({SYSTEM},{LINOS},{linos},{p1 p2 p3 n---ret},{},
{ Do a Linux
system call (man 2) with parameters forthsamp({p1 p2 p3}).
forthvar({ret}) is the return value of the call. If it is negative, it
is mostly an error, such as known by forthvar({errno}) . This makes
available forthemph({all}) facilities present in Linux.
},{{?LINUX-ERROR}})
CODE_HEADER({LINOS},{LINOS})
        POP     AX        ; Function number
        POP     DX        ; Third parameter, if any
        POP     CX        ; Second parameter, if any
        POP     BX        ; First parameter.
        INT     80H        ;{ Generic call on LINUX }
        _PUSH     ; Positive means okay. Negative means -errno.
});_END_({ _HOSTED_LINUX_})

_PC_({
             ;{ SVGA-modus 43*132 char's}
HEADER({SMALL},{SMALL},{DOCOL})
             DC      LIT, 4F02H, LIT, 010AH, ZERO, ZERO
             DC      LIT, 0010H, BIOS
             DC      DROP, DROP, DROP, DROP, DROP, SEMIS
             ;{                          ^ MUST BE 4FH}
});_END_({_PC_})
        PAGE
;{------------------------------------}
;{       SYSTEM DEPENDANT CHAR I/O}
;{------------------------------------}
_MODERN_({
worddoc({OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit count characters from forthvar({addr}) to the output device.
All terminal I/O goes through this word. It's first word is a forthcode({NOOP}) so terminal
I/O can be redirected, by forthdefi({revectoring}) it.
In this ciforth the string must not contain embedded LF's.
forthcode({OUT}) is incremented for each character output.},{{EMIT},{OUT}})
HEADER({TYPE},{LTYPE},{DOCOL})
        DC      LDUP, LOUT, PSTOR
        DC      TOR     ; { Count.}
_BITS32_({; MSDOS cannot handle a 32 bits address: copy the buffer.})
_BITS32_({        DC      LIT, TYPEBUF, RR, LCMOVE })
_BITS32_({        DC      LIT, TYPEBUF })
        DC      TOR     ; { Buffer address.}
        DC      LIT,04000H ;{ Write file or device }
        DC      ONE     ;{ Handle}
        DC      FROMR, FROMR, SWAP
         _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS, })
        DC      BDOS, DROP ;{ ignore error }
        DC      DROP, DROP, DROP, DROP
        DC      SEMIS
_BITS32_({TYPEBUF:  _RESB    0100H })
;
worddoc({OUTPUT},{EMIT},{emit},{c ---},{ISO FIG L0},
{Transmit ascii character forthvar({c}) to the output device.
forthcode({OUT}) is incremented for each character output
and reset by a LF.
.},{{OUT}})
HEADER({EMIT},{EMIT},{DOCOL})
        DC      LDUP,LIT,LF,EQUAL
        _0BRANCH(EMIT1)
        DC      LIT,ACR,EMIT
        DC      ZERO,LOUT,STORE
EMIT1:
        DC      SPFET, ONE, LTYPE
        DC      DROP
        DC      SEMIS
;
worddoc({INPUT},{EXPECT},{expect},{addr count ---},{ISO FIG L0},
{Transfer characters from the terminal to address forthvar({addr}) , until a "return"
or a number of forthvar({count}) characters have been received.
Rely on the operating system for input editing.
One or more nulls are
added at the end of the text.}, {{KEY},{?TERMINAL}})
 HEADER({EXPECT},{EXPEC},{DOCOL})
_BITS32_({; MSDOS cannot handle a 32 bits address: use the buffer.})
_BITS32_({        DC      LIT, EXPECTBUF})
_BITS16_({        DC      OVER})
        DC      TOR, TOR
        DC      LIT,03F00H ;{ Write file or device }
        DC      ZERO     ;{ Handle}
        DC      FROMR, FROMR
         _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS, })
        DC      BDOS, DROP ;{ ignore error }
        DC      DROP, DROP, DROP ;{ Leave count}
        DC      TWO, LSUB ;{ Rid of 0D0A}
_BITS32_({; Copy the buffer.})
_BITS32_({        DC      TOR, LDUP, LIT, EXPECTBUF, SWAP, RR, LCMOVE, FROMR })
        DC      PLUS, ZERO, SWAP, CSTOR
        DC      SEMIS
_BITS32_({EXPECTBUF:  _RESB    0100H })
;
worddoc({INPUT},{KEY},{key},{--- c},{ISO FIG L0},
{Leave the ascii value of the next terminal key struck.},{EXPECT},{?TERMINAL})
HEADER({KEY},{KEY},{DOCOL})
        DC         LIT, 1000H, ZERO, ZERO, ZERO
        DC         LIT, 0016H, BIOS
        DC         DROP,DROP,DROP,DROP
        DC         LIT, 00FFH, LAND, SEMIS
;
worddoc({INPUT},{?TERMINAL},{question_terminal},{--- f},{},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },{{KEY},{EXPECT}})
HEADER({?TERMINAL},{QTERM},DOCOL)
        DC      LIT,0B00H
        DC      ZERO,ZERO,ZERO
        DC      BDOS, DROP ;{ ignore error }
        DC      DROP, DROP, DROP
        DC      LIT, 01H, LAND
        DC      SEMIS
;
});_END_({_MODERN_})
_LINUX_C_({
;{ Code fields are filled in during bootup. }
;{ Lower case labels starting with "c_.." are c-supplied facilities.}
worddoc({OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit count characters from forthvar({addr}) to the output device.
All terminal I/O goes through this word.
forthcode({OUT}) is not observed.},{{EMIT},{OUT}})
CODE_HEADER({TYPE},{LTYPE},DOCOL)
        CALL    c_type
        LEA     ESP,[ESP+CELLS(2)]    ; remove input
        _NEXT
;
worddoc({INPUT},{ACCEPT},{accept},{addr count --- n},{ISO FIG L0},
{Transfer characters from the terminal to address forthvar({addr}) ,
until a "return" or a number of forthvar({count}) characters have been
received. Rely on the operating system for input editing. One or more
nulls are added at the end of the text.
},{{KEY},{?TERMINAL}})
;
CODE_HEADER({ACCEPT},{ACCEP})
        CALL    c_expec
        LEA     ESP,[ESP+CELLS(2)]    ; remove input
        PUSH    EAX
        _NEXT
;
worddoc({INPUT},{KEY},{key},{--- c},{ISO FIG L0},
{Leave the ascii value of the next terminal key struck.},{})
CODE_HEADER({KEY},{KEY})
        CALL    c_key
        PUSH    EAX
        _NEXT
;
worddoc({INPUT},{?TERMINAL},{question_terminal},{--- f},{},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },{})
CODE_HEADER({?TERMINAL},{QTERM})
        CALL    c_qterm
        PUSH    EAX
        _NEXT
;
});_END_({_LINUX_C_})
_LINUX_N_({
;{ All I/O goes through the modern device (unix-standard)}
;{ device I/O. Code fields are filled in during bootup. }
;{ Lower case labels starting with "c_.." are c-supplied facilities.}
worddoc({SYSTEM},{?LINUX-ERROR},{query_linux_error},{errno ---},{},
{Handle the error forthvar({errno}) by interpreting it as returned from a
Linux system call. If it is negative error forthvar({-n}) is displayed and the word
is aborted.
},{{?ERROR}})
HEADER({?LINUX-ERROR},{QLERR},{DOCOL})
        DC      LDUP, ZERO, MIN, SWAP ; ( errno -- error flag, errno)
        DC      LIT, 64, PLUS   ; Project onto SCREEN 4..7.
        DC      QERR  ; Make errno's count from the top.
        DC      SEMIS
;
worddoc({INPUT},{TERMIO},{termio},{--- addr},{},
{Leave the address of the terminal description, this has the layout of
a the c-structure forthsamp({termio}) .
},{{SET-TERM}})
HEADER({TERMIO},{TERMIO},{DOVAR})
        _RESB    SIZE_TERMIO     ; Filled induring cold boot.
;
worddoc({INPUT},{SET-TERM},{set_term},{len b --- },{},
{Set the terminal length to forthvar({len}) and toggle the c_lflag field
with forthvar({b}) in the termio structure forthcode({TERMIO}) .
In particular toggling with 0AH makes that
the terminal doesn't wait for a <return>.
},{{SET-TERM}})
HEADER({SET-TERM},{STTERM},{DOCOL})
        DC      LIT, _PARAMETER_FIELD(TERMIO)+CELLS(3)
        DC      SWAP, TOGGL
        DC      LIT, _PARAMETER_FIELD(TERMIO)+CELLS(4)+7
        DC      CSTOR
        DC      ZERO, LIT, TCSETS, TERMIO
        DC      LIT, ioctl, LINOS, QLERR
        DC      SEMIS
; Alternative: if no terminal, this is copied over above code during boot
STTERM_A:
        DC      DROP, DROP
        DC      SEMIS
STTERM_B:

;
worddoc({OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit count characters from forthvar({addr}) to the output device.
All terminal I/O goes through this word. It is high level so terminal
I/O can be redirected, by forthref({revectoring}) it
_VERBOSE_(and the usual redirection or forthvar({tee})-ing by Linux).
forthcode({OUT}) is not observed.},{{EMIT},{OUT}})
HEADER({TYPE},{LTYPE},{DOCOL})
        DC      ONE, ROT, ROT   ; filedescriptor 1 for standard output.
        DC      LIT, write
        DC      LINOS
        DC      DROP
        DC      SEMIS
;
worddoc({INPUT},{ACCEPT},{accept},{addr count ---},{ISO FIG L0},
{Transfer characters from the terminal to address, until a "return"
or the count of characters have been received.
Rely on the operating system for input editing.
One or more nulls are added at the end of the text.},
{{KEY},{?TERMINAL}},
{{( ." Type an 'A'" PAD 2 ACCEPT . PAD C@ EMIT)},{( 1 A)},
{( ." Type an 'ABCDEF'" PAD 80 ACCEPT . )},{( 6)},
{( ." Type an 'ZX'" PAD 1 ACCEPT . PAD C@ EMIT)},{( 1 Z)}})
HEADER({ACCEPT},{ACCEP},{DOCOL})
        DC      ZERO    ; filedescriptor 0 for standard input.
        DC      ROT
        DC      ROT
        DC      LIT, read
        DC      LINOS
        DC      ONE, LSUB, ZERO, MAX ; Position of CR (or 0 for failure)
        DC      SEMIS
        _RESB    CELLS(4)        ; Room for patching
; Alternative: if no terminal, this is copied over above code during boot
ACCEP_A:
        DC      OVER, TOR
        DC      EXPEC
        DC      FROMR, LDUP
ACCEP4:  DC      COUNT, ZEQU
        _0BRANCH(ACCEP4)
        DC      SWAP, LSUB
        DC      SEMIS
ACCEP_B:
worddoc({INPUT},{EXPECT},{expect},{addr count ---},{ISO FIG L0},
{Transfer characters from the terminal to address, until a "return"
or the count of characters have been received.
Rely on the operating system for input editing.
One or more nulls are added at the end of the text.},
{{KEY},{?TERMINAL}})
HEADER({EXPECT},{EXPEC},{DOCOL})
        DC      OVER, OVER, ONEP, LERASE
        DC      OVER, PLUS, SWAP     ; Bounds
        DC      XDO
EXPEC1: DC      KEY, LDUP, LIT, LF
        DC      EQUAL
        _0BRANCH(EXPEC2)
        DC      DROP
        DC      LLEAV
        _BRANCH(EXPEC3)
EXPEC2: DC      IDO,CSTOR
EXPEC3: _LOOP(EXPEC1)
        DC      SEMIS
;
worddoc({INPUT},{KEY},{key},{--- c},{ISO FIG L0},
{Leave the ascii value of the next terminal key struck.},
{{EXPECT},{?TERMINAL}})
HEADER({KEY},{KEY},{DOCOL})
        DC      ONE, LIT, RAWIO, STTERM ; Do not wait for CR
        DC      ZERO, SPFET     ; Expect single key on stack
        DC      ZERO            ; Standard input
        DC      SWAP, ONE       ; Buffer and length
        DC      LIT, read, LINOS, DROP ; Retain char, drop count/error
        DC      ONE, LIT, RAWIO, STTERM       ; Toggle back
        DC      SEMIS
;
worddoc({INPUT},{?TERMINAL},{question_terminal},{--- f},{},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is consumed.
A true flag indicates actuation. },
{{KEY},{EXPECT}})
HEADER({?TERMINAL},{QTERM},{DOCOL})
        ; Return immediately even for zero characters available
        DC      ZERO, LIT, RAWIO, STTERM
        DC      ZERO, SPFET     ; Expect single key on stack
        DC      ZERO            ; Standard input
        DC      SWAP, ONE       ; Buffer and length
        DC      LIT, read, LINOS
        DC      SWAP, DROP      ; Retain only count
        DC      ONE, LIT, RAWIO, STTERM       ; Toggle back
        DC      SEMIS
;
});_END_({_LINUX_N_})
_HOSTED_LINUX_({
worddoc({OUTPUT},{EMIT},{emit},{c ---},{ISO FIG L0},
{Transmit ascii character forthvar({c}) to the output device.
All terminal I/O goes through forthcode({TYPE}).
forthcode({OUT}) is not observed.},{{TYPE},{OUT}})
HEADER({EMIT},{EMIT},{DOCOL})
        DC      SPFET, ONE, LTYPE
        DC      DROP
        DC      SEMIS
;
});_END_({_HOSTED_LINUX_})
;
_CLASSIC_({
;{ All I/O goes through the 3 assembler functions}
;{ CI CHO CSTAT. They could be collapsed into the }
;{ code definitions, but this way they are available}
;{ to be called from code. And the high level words can be revectored }
worddoc({INPUT},{EXPECT},{expect},{addr count ---},{ISO FIG L0},
{Transfer characters from the terminal to address forthvar({addr}) ,
until a "return" or a number of forthvar({count}) characters have been
received. One or more nulls are added at the end of the text. Receive
characters key by key using forthcode({KEY}). Observe
forthcode({RUBOUT}). },
{{KEY},{?TERMINAL}})
HEADER({EXPECT},{EXPEC},{DOCOL})
        DC      OVER
        DC      PLUS
        DC      OVER
        DC      XDO     ;{ DO                    }
EXPE1:  DC      KEY
        DC      LDUP
        DC      RUBOUT
        DC      FETCH
        DC      EQUAL
        _0BRANCH(EXPE2) ;{ IF                    }
        DC      DROP
        DC      LDUP
        DC      IDO
        DC      EQUAL
        DC      LDUP
        DC      FROMR
        DC      TWO     ;{ Remove last 2 chars }
        DC      LSUB
        DC      PLUS
        DC      TOR
        _0BRANCH(EXPE6) ;{ IF                    }
        DC      LIT
        DC      BELL
        _BRANCH(EXPE7)  ;{ ELSE                  }
EXPE6:  DC      LIT
        DC      BSOUT   ;{ ENDIF                 }
EXPE7:  _BRANCH(EXPE3)  ;{ ELSE                  }
EXPE2:  DC      LDUP
        DC      LIT,0DH
        DC      EQUAL
        _0BRANCH(EXPE4) ;{ IF}
        DC      LLEAV
        DC      DROP
        DC      LBL
        DC      ZERO
        _BRANCH(EXPE5)  ;{ ELSE}
EXPE4:  DC      LDUP    ;{ ENDIF}
EXPE5:  DC      IDO
        DC      CSTOR
        DC      ZERO
        DC      IDO
        DC      ONEP
        DC      STORE   ;{ ENDIF}
EXPE3:  DC      EMIT
        _LOOP(EXPE1)    ;{ LOOP}
        DC      DROP
        DC      SEMIS
;
worddoc({INPUT},{KEY},{key},{--- c},{ISO FIG L0},
{Leave the ascii value of the next terminal key struck.},{})
CODE_HEADER({KEY},{KEY})
        CALL    CI      ;{CONSOLE INPUT}
        MOV     AH,0    ;{MAKE 16 BITS}
        _PUSH   ;{SAVE KEY VALUE}
CI      PROC    NEAR
        MOV     AH,0    ;{ READ CHAR FUNCTION}
        INT     16H
        RET
_ENDP CI      ENDP
;
worddoc({OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit forthvar({count}) characters from forthvar({addr}) to the
terminal.
In this ciforth all terminal I/O goes through forthcode({EMIT}), so
forthcode({OUT}) is observed.},{{EMIT},{OUT}})
HEADER({TYPE},{LTYPE},{DOCOL})
        DC      DDUP
        _0BRANCH(TYPE1) ;{ IF}
        DC      OVER
        DC      PLUS
        DC      SWAP
        DC      XDO     ;{ DO}
TYPE2:  DC      IDO
        DC      CFET
        DC      EMIT
        _LOOP(TYPE2)    ;{ LOOP}
        _BRANCH(TYPE3)  ;{ ELSE}
TYPE1:  DC      DROP    ;{ ENDIF}
TYPE3:  DC      SEMIS
;
worddoc({OUTPUT},{EMIT},{emit},{c ---},{ISO FIG L0},
{Transmit ascii character forthvar({c}) to the terminal.
All terminal I/O goes through this word. It is high level so terminal
I/O can be redirected, by forthdefi({revectoring}) it.
forthcode({OUT}) is incremented for each character output and reset for
a carriage return.
Note that in this ciforth (``classical FIG'') terminal I/O mainly
uses BDOS, where disk I/O uses the BIOS.
},{{TYPE},{OUT}})
HEADER({EMIT},{EMIT},{DOCOL})
        DC      PEMIT
        DC      ONE,LOUT
        DC      PSTOR,SEMIS
PEMIT   DC      $+CELLS(1)
        POP     AX      ;{GET CHAR}
        CMP     AL,LF   ;{ Precede ^J with ^M}
        JNE     PEMIT1
        MOV     _CELL_PTR[_PARAMETER_FIELD(LOUT)],0H
        MOV     AL,ACR
        CALL    CHO
        MOV     AL,LF
        ;{ Bizar, without the colon MASM reports error.}
PEMIT1: CALL    CHO    ;{CHAR OUTPUT}
        _NEXT
CHO     PROC    NEAR
        PUSH    DX
        PUSH    AX      ;{SAVE CHAR}
        MOV     DL,AL   ;{CHAR TO WRITE}
        MOV     AH,2    ;{CHAR OUT FUNCTION}
        INT     21H     ;{DOS}
        POP     AX
        POP     DX
        RET
_ENDP CHO     ENDP
;
worddoc({INPUT},{?TERMINAL},{question_terminal},{--- f},{FIG},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },
{{KEY},{EXPECT}})
CODE_HEADER({?TERMINAL},{QTERM})
        JMP     PQTER
PQTER:  CALL    CSTAT   ;{TEST FOR KEY}
        OR      AL,AL   ;{ANY KEY?}
        JZ      PQTER1  ;{NO}
        MOV     AL,1    ;{TRUE = CHAR FOUND}
PQTER1: MOV     AH,0    ;{MAKE 16 BITS}
        _PUSH   ;{SAVE STATUS}
;
CSTAT   PROC    NEAR
        PUSH    DX
        MOV     DX,0FFH
        MOV     AX,0600H
        INT     21H
        POP     DX
STATRT: RET
_ENDP CSTAT   ENDP
});_END_({_CLASSIC_})
_USEBIOS_({
worddoc({INPUT},{EXPECT},{expect},{addr count ---},{ISO FIG L0},
{Transfer characters from the terminal to address forthvar({addr}) ,
until a "return" or a number of forthvar({count}) characters have been
received. Receive characters key by forthcode({KEY}) and observe
forthcode({RUBOUT}) . One or more nulls are added at the end of the
text. Uses ``BIOS''. },
{{KEY},{?TERMINAL}})
HEADER({EXPECT},{EXPEC},{DOCOL})
        DC      OVER
        DC      PLUS
        DC      OVER
        DC      XDO     ;{ DO                    }
EXPE1:  DC      KEY
        DC      LDUP
        DC      RUBOUT
        DC      FETCH
        DC      EQUAL
        _0BRANCH(EXPE2) ;{ IF                    }
        DC      DROP
        DC      LDUP
        DC      IDO
        DC      EQUAL
        DC      LDUP
        DC      FROMR
        DC      TWO     ;{ Remove last 2 chars }
        DC      LSUB
        DC      PLUS
        DC      TOR
        _0BRANCH(EXPE6) ;{ IF                    }
        DC      LIT
        DC      BELL
        _BRANCH(EXPE7)  ;{ ELSE                  }
EXPE6:  DC      LIT
        DC      BSOUT   ;{ ENDIF                 }
EXPE7:  _BRANCH(EXPE3)  ;{ ELSE                  }
EXPE2:  DC      LDUP
        DC      LIT,0DH
        DC      EQUAL
        _0BRANCH(EXPE4) ;{ IF}
        DC      LLEAV
        DC      DROP
        DC      LBL
        DC      ZERO
        _BRANCH(EXPE5)  ;{ ELSE}
EXPE4:  DC      LDUP    ;{ ENDIF}
EXPE5:  DC      IDO
        DC      CSTOR
        DC      ZERO
        DC      IDO
        DC      ONEP
        DC      STORE   ;{ ENDIF}
EXPE3:  DC      EMIT
        _LOOP(EXPE1)    ;{ LOOP}
        DC      DROP
        DC      SEMIS
;
worddoc({INPUT},{KEY},{key},{--- c},{ISO FIG L0},
{Leave the ascii value of the next terminal key struck.},{})
HEADER({KEY},{KEY},{DOCOL})
             DC         LIT, 1000H, ZERO, ZERO, ZERO
             DC         LIT, 0016H, BIOS
             DC         DROP,DROP,DROP,DROP
             DC         LIT, 00FFH, LAND, SEMIS
;
worddoc({OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit count characters from forthvar({addr}) to the output device.
forthcode({OUT}) is incremented for each character output.
In this ciforth all terminal I/O goes through forthcode({EMIT}), so
forthcode({OUT}) is observed.
},{{EMIT},{OUT}})
HEADER({TYPE},{LTYPE},{DOCOL})
             DC      DDUP
             _0BRANCH(TYPE1)
             DC      OVER,   PLUS
             DC      SWAP,   XDO
TYPE2:       DC      IDO,    CFET,    EMIT
             _LOOP(TYPE2)
             _BRANCH(TYPE3)
TYPE1:       DC      DROP
TYPE3:       DC      SEMIS
;{            }
worddoc({OUTPUT},{EMIT},{emit},{c ---},{ISO FIG L0},
{Transmit ascii character forthvar({c}) to the terminal.
All terminal I/O goes through this word. It is high level so terminal
I/O can be redirected, by forthref({revectoring}) it.
forthcode({OUT}) is incremented for each character output and reset for
a carriage return.
},{{TYPE},{OUT}})
HEADER({EMIT},{EMIT},{DOCOL})
             DC      ONE,LOUT,PSTOR
             DC      LIT, 07FH, LAND
             DC      LDUP,LIT,LF,EQUAL
             _0BRANCH(EMIT1)
             DC      LIT,ACR,PEMIT
             DC      ZERO,LOUT,STORE
EMIT1:       DC      PEMIT
             DC      SEMIS
;{            }
worddocsafe({OUTPUT},{(EMIT)},{paren_emit},{c ---},{},
{Just transmit ascii character forthvar({c}) to the terminal
by a BIOS call.
},{{EMIT}})
HEADER({(EMIT)},{PEMIT},{DOCOL})
             DC      LIT, 0E00H, PLUS, ZERO, ZERO, ZERO
             DC      LIT, 0010H, BIOS
             DC      DROP, DROP, DROP, DROP, DROP, SEMIS

;
worddoc({INPUT},{?TERMINAL},{question_terminal},{--- f},{},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },
{{KEY},{EXPECT}})
HEADER({?TERMINAL},{QTERM},{DOCOL})
             DC      LIT, 01100H, ZERO, ZERO, ZERO
             DC      LIT, 016H, BIOS
             DC      LIT, 040H, LAND, ZEQU, TOR
             DC      DROP, DROP, DROP, DROP
             DC      FROMR, SEMIS

             ;{ Output to PRN }
worddoc({OUTPUT},{POUT)},{p_out},{c ---},{},
{Just transmit ascii character forthvar({c}) to the printer
by a BIOS call. forthcode({OUT}) is not observed.
},{{EMIT}})
HEADER({POUT},{POUT},{DOCOL})
             DC      ZERO, ZERO, ZERO
             DC      LIT, 0017H, BIOS
             DC      DROP, DROP, DROP, DROP, DROP, SEMIS
;
});_END_({_USEBIOS_})
        PAGE
;{------------------------------------}
;{       SYSTEM DEPENDANT DISK I/O}
;{------------------------------------}
define({_FILENAMELENGHT_M4_},_BITS16_(30)_BITS32_(254))
_BLOCKSINFILE_({
worddoc({STORAGE},{BLOCK-FILE},{block_file},{---addr},{},
{Leave the address forthvar({addr}) of a counted string,
the name of a file in which blocks are (to be) allocated.
The name may contain a path and be at most}
_FILENAMELENGHT_M4_ {characters long.
The default name is forthvar({BLOCKS.BLK}) .
},{{BLOCK-HANDLE},{BLOCK-INIT},{BLOCK-EXIT}})
HEADER({BLOCK-FILE},{BLFL},{DOVAR})
        _STRING({BLOCKS.BLK})
        _RESB(_FILENAMELENGHT_M4_-9)               ;{ Allow for some path}
worddoc({STORAGE},{BLOCK-HANDLE},{block_handle},{---n},{},
{Leave a file handle in forthvar({n}) .
If it is negative there is no block file open,
otherwise the handle is used by the system to access blocks.
_LINUX_C_({In this ciforth forthcode({BLOCK-HANDLE}) is not used.})
},{{BLOCK-FILE},{BLOCK-INIT},{BLOCK-EXIT}})
HEADER({BLOCK-HANDLE},{BHAN},{DOVAR})
        DC      -1
;
});_END_({_BLOCKSINFILE_})
;
_RWFILE_({
worddoc({STORAGE},{DISK-ERR},{disk_error_},{u---},{},
{Interpret forthvar({u}) as the status of a disk i/o BDOS call.
Report an error if it contains an error condition.
},{{BLOCK-FILE},{BLOCK-HANDLE},{BLOCK-INIT},{BLOCK-EXIT}})
HEADER({DISK-ERR},{DERR},{DOCOL})
        DC      ONE, LAND
        DC      LIT, 08H, QERR
        DC      SEMIS
;
worddoc({STORAGE},{BLOCK-INIT},{block_init},{---},{},
{Map the blocks on the block file forthcode({BLOCK-FILE}),
i.e. the mass storage words refer
to the blocks in this file, using forthvar({BLOCK-HANDLE}) to acces it.
},{{BLOCK},{LIST},{LOAD},{BLOCK-EXIT}})
HEADER({BLOCK-INIT},{BLINI},{DOCOL})
        DC      LIT, 03D02H    ;{ Open file for read/write}
        DC      ZERO,ZERO
        DC      BLFL
        DC      SFET, OVER, PLUS
        DC      ZERO, SWAP, CSTOR  ;{ Zero ended as required}
         _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS, })
        DC      BDOS
        DC      ONE, LAND, ZEQU, WARN, STORE
        DC      DROP, DROP, DROP
        DC      BHAN, STORE
        DC      SEMIS
;
worddoc({STORAGE},{BLOCK-EXIT},{block_exit},{---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Close the currently open block file forthcode({BLOCK-HANDLE}),
i.e. the mass storage words no longer work, and will result in
error messages.
},{{BLOCK},{LIST},{LOAD}})
HEADER({BLOCK-EXIT},{BLEXI},{DOCOL})
        DC      LIT, 03E00H    ;{ Close file }
        DC      ZERO, WARN, STORE
        DC      BHAN, FETCH
        DC      ZERO, ZERO
        DC      BDOS, DERR
        DC      DROP, DROP, DROP, DROP
        DC      LIT, -1, BHAN, STORE
        DC      SEMIS
;
worddoc({STORAGE},{SEEK},{seek},{n---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Position the file pointer at block forthvar({n})
in behalf of subsequent reads and writes.
},{{BLOCK},{LIST},{LOAD}})
HEADER({SEEK},{SEEK},{DOCOL})
        DC      BHAN, FETCH
        DC      SWAP, TOR, TOR
        DC      LIT, 04200H     ;{ Seek from start}
        DC      FROMR           ;{ Handle}
        DC      FROMR, BBUF
        _BITS16_({DC      USTAR,SWAP})    ;{ L.S. ON TOP}
        _BITS32_({DC      STAR, LIT, 10000H, SLMOD,SWAP})    ;{ L.S. ON TOP}
        DC      BDOS, DERR
        DC      DROP, DROP, DROP, DROP
        DC      SEMIS
;
worddoc({STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The fig-FORTH standard disc read-write linkage. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read-write and aborts on errors.
},
{{BLOCK}})
HEADER({R/W},{RSLW},{DOCOL})
        _0BRANCH(RSLW1)
        DC      LIT, 03F00H     ;{ Disk read }
        _BRANCH(RSLW2)
RSLW1:  DC      LIT, 04000H     ;{ Disk write}
RSLW2:  DC      TOR
        DC      SEEK ;{ That's done}
        DC      FROMR, SWAP, TOR
        DC      BHAN, FETCH
        DC      BBUF
        DC      FROMR           ;{ ADDR}
        _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS, })
        DC      BDOS, DERR
        DC      DROP, DROP, DROP
        DC      BBUF, LSUB, DERR
        DC      SEMIS

});_END_({_RWFILE_})
_HOSTED_LINUX_({
worddoc({STORAGE},{DISK-ERROR},{disk_error},{--- addr},{},
{Leave the address addr of a variable containing the
latest disk error in opening, using or closing the block file.
Negative means an error
(the Unix forthsamp({errno}) and zero means okay.)
},{{BLOCK},{LINUX-ERROR}})
HEADER({DISK-ERROR},{DERR},{DOVAR})
        DC      -1
;
});_END_({_HOSTED_LINUX_})
_LINUX_N_({
worddoc({STORAGE},{BLOCK-INIT},{block_init},{---},{},
{Map the blocks on the block file forthcode({BLOCK-FILE}),
i.e. the mass storage words refer
to the blocks in this file, using forthcode({BLOCK-HANDLE}) to acces it.
If successful, forthcode({WARNING}) is reinitialised to use disk messages.
},{{BLOCK},{LIST},{LOAD},{BLOCK-EXIT},{DISK-ERROR}})
HEADER({BLOCK-INIT},{BLINI},DOCOL)
        DC      ZERO, BLFL, SFET, PLUS, STORE ; {Unix requires a c-string.}
        DC      BLFL, SFET, DROP
        DC      LIT, O_RDWR
        DC      ZERO
        DC      LIT, open
        DC      LINOS
        DC      LDUP, BHAN, STORE
        DC      ZERO, MIN      ; 0/-errno
        DC      LDUP, DERR, STORE
        DC      ZEQU, WARN, STORE
        DC      SEMIS
;
worddoc({STORAGE},{BLOCK-EXIT},{block_exit},{---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Close the currently open block file forthcode({BLOCK-HANDLE}),
i.e. the mass storage words no longer work, and will result in
error messages.
},{{BLOCK},{LIST},{LOAD},{DISK-ERROR}})
HEADER({BLOCK-EXIT},{BLEXI},DOCOL)
        DC      ZERO, WARN, STORE
        DC      BHAN, FETCH
        DC      ZERO,ZERO
        DC      LIT, close
        DC      LINOS
        DC      ZERO, MIN      ; 0/-errno
        DC      DERR, STORE
        DC      SEMIS
;
worddoc({STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The fig-FORTH standard disc read-write linkage. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read-write and aborts on errors.},
{{BLOCK}})
;{      ( ADDR  BLK#  FLAG (0=W, 1=R) --- )}
HEADER({R/W},{RSLW},{DOCOL})
        DC      TOR
        DC      BBUF, STAR
        DC      BHAN, FETCH, SWAP
        DC      LIT, SEEK_SET
        DC      LIT, lseek
        DC      LINOS
        DC      ZERO, MIN      ; 0/-errno
        DC      LDUP, DERR, STORE
        _0BRANCH( RSLW1 )
        DC      FROMR, DROP
        _BRANCH( RSLW2 )
RSLW1:
        DC      BHAN, FETCH, SWAP
        DC      BBUF
        DC      FROMR
        _0BRANCH( RSLW3 )
        DC     LIT, read
        _BRANCH( RSLW4 )
RSLW3:
        DC      LIT, write
RSLW4:  DC      LINOS
        DC      ZERO, MIN      ; 0/-errno
        DC      DERR, STORE
RSLW2:  DC      DERR, FETCH
        DC      LIT, 08H, QERR
        DC      SEMIS

});_END_({_LINUX_N_})

_LINUX_C_({
worddoc({STORAGE},{BLOCK-INIT},{block_init},{---},{},
{Map the blocks on the block file forthcode({BLOCK-FILE}),
i.e. the mass storage words refer
to the blocks in this file. The handle to use it is
hidden in the c-code. forthcode({DISK-ERROR}) reflects whether the mapping was
successful.
If successful, forthcode({WARNING}) is reinitialised to use disk messages.
_VERBOSE_({This word is executed by c-code outside of Forth})
},{{BLOCK},{LIST},{LOAD},{BLOCK-EXIT},{DISK-ERROR}})
CODE_HEADER({BLOCK-INIT},{BLINI})
        XOR     AX,AX
        MOV     AL,[_PARAMETER_FIELD(BLFL)]
        MOV     BX,_PARAMETER_FIELD(BLFL)+1
        PUSH    BX
        PUSH    AX
        CALL    c_block_init
        MOV     [_PARAMETER_FIELD(DERR)],AX
        LEA     ESP,[ESP+CELLS(2)]    ; remove input
        _NEXT
;
worddoc({STORAGE},{BLOCK-EXIT},{block_exit},{---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Close the currently open block file,
i.e. the mass storage words no longer work, and will result in
error messages.
_VERBOSE_({This word is executed by c-code outside of Forth})
},{{BLOCK},{LIST},{LOAD},{DISK-ERROR}})
CODE_HEADER({BLOCK-EXIT},{BLEXI})
        CALL    c_block_exit
        _NEXT
;
worddoc({STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The fig-FORTH standard disc read-write linkage. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read-write and shows errors via forthcode({DISK-ERROR}).},
{{BLOCK}})
;{      ( ADDR  BLK#  FLAG (0=W, 1=R)}
CODE_HEADER({R/W},{RSLW})
        CALL c_rslw
        MOV     [_PARAMETER_FIELD(DERR)],AX
        LEA     ESP,[ESP+CELLS(3)]    ; remove input
        _NEXT


});_END_({_LINUX_C_})
_CLASSIC_({
; This the mass storage I/O that looks most like FIG.
; It may not be pretty but it surely is the smallest.
;
;
worddoc({STORAGE},{DRIVE},{drive},{--- addr},{},
{Leave the address addr of a variable containing the
drive used for mass storage. This is in MSDOS coding,
0 is floppy A: , 1 is floppy B:, 80H is drive C:,
81H is drive D: and so forth.
The drive may be switched but this should only be
attempted after forthcode({EMPTY-BUFFERS}) .},
{{BLOCK},{FLUSH}})
HEADER({DRIVE},{LDRIVE},{DOVAR})
      DC  0
;
WERR    DB      'DISK WRITE ERROR  $'
RERR    DB      'DISK READ ERROR   $'
;
SBLK    PROC    NEAR
;{      ( ADDR  BLK# -- )}
;{      THIS ROUTINE WILL PREPARE PARAMETERS FOR DISK I/O}
;{       DRIVE, ADDRESS, LENGTH, SEC#}
        POP     DI      ;{SAVE RETURN}
        POP     AX      ;{BLK #}
        MOV     CX,SPB
        MUL     CX   ;{SEC #}
        MOV     DX,AX
        MOV     AL,[_PARAMETER_FIELD(LDRIVE)]    ;{SELECT DR A}
        POP     BX      ;{TRANSFER ADDR}
        PUSH    DI      ;{GET THAT RETURN BACK}
        RET
_ENDP SBLK    ENDP
;
worddoc({STORAGE},{RBLK},{read_block},{addr blk --},{},
{forthvar({1 R/W}) is an abbreviation for forthvar({RBLK}).
},{{R/W}})
CODE_HEADER({RBLK},{RBLK})
        CALL    SBLK
        PUSH    SI      ;{PRESERVE INTERPRETER POINTER}
        PUSH    BP      ;{RETURN POINTER}
        INT     25H
        JNC     DOK     ;{NO ERRORS}
        LEA     DX,[RERR]
        JMP     DERR
;
worddoc({STORAGE},{WBLK},{write_block},{addr blk --},{},
{forthvar({0 R/W}) is an abbreviation for forthvar({WBLK}).
},{{R/W}})
CODE_HEADER({WBLK},{WBLK})
        CALL    SBLK
        PUSH    SI
        PUSH    BP
        INT     26H
        JNC     DOK
        LEA     DX,[WERR]
;
;{ Error exit for both RBLK and WBLK }
DERR:   PUSH    AX      ; DX contains message.
        MOV     AH,9    ;{String write fncn, obsolete for ages}
        INT     21H
        POP     AX      ;{ERROR CODE IN AX}
;
;{ Okay exit for both RBLK and WBLK }
DOK:    POPF            ;{POP FLAGS}
        POP     BP      ;{RETURN STACK}
        POP     SI      ;{INTERPRETER PNTR}
        _NEXT
;
worddoc({STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The figforth standard disc read-write linkage. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read-write. This version of ciforthh features the
most classic
mass storage. Blocks are counted sequentially from 0
on the drive with MSDOS code in forthcode({DRIVE}),
so forthcode({R/W}) can be used to write boot code.
Errors are handled by writing directly to the console
after they are detected.
},
{{BLOCK},{DRIVE}})
;{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
HEADER({R/W},{RSLW},{DOCOL})
         _SWITCH_({DC   ROT, LIT, M4_SWITCHOFFSET, PLUS, ROT, ROT})
        _0BRANCH(RSLW1)
        DC      RBLK
        _BRANCH(RSLW2)
RSLW1:  DC      WBLK
RSLW2:  DC      SEMIS
});_END_({_CLASSIC_})
_USEBIOS_({
;
worddoc({STORAGE},{SEC/BLK},{sectors_per_block},{--- c},{},
{This constant leaves the number of sectors per block. _VERBOSE_(
The original idea was that a sector forthemph({is}) a block. In
fact SEC/BLK is set such that B/SRC is one, as is required for ISO.)
},{{BLOCK},{B/SCR}})
HEADER({SEC/BLK},{SPBLK},{DOCON}) ;{# SECTORS/BLOCK}
        DC      SPB
;
worddoc({STORAGE},{DISK-ERROR},{disk_error},{--- addr},{},
{Leave the address addr of a variable containing the
latest disk error in opening, using or closing the block file.
One means an error and and zero means okay.
},{{BLOCK},{R/W}})
HEADER({DISK-ERROR},{DSKERR},{DOVAR})
      DC  0
});_END_({_USEBIOS_})
;
_RWFD_({
worddoc({STORAGE},{SEC-RW},{sector_read_write},{com addr blk --},{},
{Performs the forthcode({BIOS}) function forthvar({com}) , for
a single sector
forthvar({blk}) either a read to forthvar({addr}) or write from
forthvar({addr}) .
Disk errors are stored in
forthcode({DISK-ERROR}).},
{{BLOCK},{R/W}})
;{  (Command, address, sec# -- )}
HEADER({SEC-RW},{SECRW},{DOCOL})
        DC      LIT, SPT*HEADS, SLMOD   ;{ Juggle #sec, #head, #track}
        DC      SWAP, LIT, SPT, SLMOD, TOR
        DC      SWAP, LIT, 0100H, STAR, PLUS, ONEP
        DC      FROMR, LIT, 0100H, STAR  ;{ .. to arrive at CX, DX}
        DC      LIT, 13H, BIOS
        DC      ONE, LAND, DSKERR, PSTOR
        DC      DROP, DROP, DROP, DROP
        DC      SEMIS
;
worddoc({STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The figforth standard disc read-write linkage. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read-write and aborts with an error message for failures.
forthcode({DISK-ERROR}) contains an error count for the latest operation.
},
{{BLOCK},{DISK-ERROR},{SECRW}})
;{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
HEADER({R/W},{RSLW},{DOCOL})
         _SWITCH_({DC   ROT, LIT, M4_SWITCHOFFSET, PLUS, ROT, ROT})
        DC      ZERO, DSKERR, STORE
        _0BRANCH(RSLW1)
        DC      LIT, 0201H      ;{ Read (AH) one (AL) sector }
        _BRANCH(RSLW2)
RSLW1:  DC      LIT, 0301H      ;{ Write (AH) one (AL) sector }
RSLW2:  DC      SWAP
        DC      SPBLK,  STAR
        DC      SPBLK,  OVER, PLUS
        DC      SWAP,   XDO
RSLW0:
        DC      SWAP, TDUP
        DC      IDO
        DC      SECRW
        DC      LIT, BPS, PLUS, SWAP
        _LOOP(RSLW0)
        DC      DROP, DROP
        DC      DSKERR, FETCH,     DDUP
        _0BRANCH(RSLW5)              ;{OK}
        DC      ZLESS
        _0BRANCH(RSLW3)
        DC      LIT,    9   ;{Write error}
        _BRANCH(RSLW4)
RSLW3:  DC      LIT,    8   ;{Read error}
RSLW4:  DC      ZERO,   PREV,   FETCH,     STORE   ;{This  buffer}
                                                   ;{ is no good!}
        DC      QERR
RSLW5:  DC      SEMIS
;
});_END_({ _RWFD_})
_RWHD_({

;{ Warning : if this LBA is used apart from by R/W}
;{ the fields marked default must be restored.}
worddoc({STORAGE},{LBAPAR},{l_b_a_params},{--},{},
{ A data structure used by R/W , that also must be filled in for disk
operations forthcode({RBLK}) and forthcode({WBLK}) . Do not touch the
first 16-bits word. The second word is the number of sectors to be
transferred. The third and fourth word contain a long real pointer
where the data comes from or goes to. The fourth word and fifth word
is as 32 bit counter for the sector on the disc. If a 2 Terabyte disk
is not enough this can be extended into the sixth and seventh word.
Word 1,2,4 6 and 7 must be restored to their previous value after
calling forthcode({RBLK}) and forthcode({WLBK}) so as not to interfere
with forthcode({R/W}). },
{{R/W},{BLOCK},{OFFSET}})
HEADER({LBAPAR},{LBA},{DOVAR})
        DB      10H, 0      ;{ default    }
        DW      SPB         ;{ default    }
        DW      0           ;{ to be filled with offset}
        DW      _SWITCH_({SWITCHSEGMENT}) ;{ default segment}
        ;{ At a hard disk we just read sector from sector 1        }
        DD      0       ;{ sector number}
        DD      0       ;{ M.S. 32 BITS default}

worddoc({STORAGE},{RBLK},{read_block},{--},{},
{Perform a disk read operation using a properly filled in LBA structure
in forthcode({LBAPAR}). }
{{R/W},{WBLK}})
CODE_HEADER({RBLK},{RBLK})
        MOV     BX,4200H
        JMP    RWBLK
;
worddoc({STORAGE},{WBLK},{write_block},{--},{},
{Perform a disk write operation using a properly filled in LBA
structure in forthcode({LBAPAR}). }
{{R/W},{RBLK}})
CODE_HEADER({WBLK},{WBLK})
        MOV     BX,4300H
RWBLK:
        POP     AX
        PUSH    SI      ;{PRESERVE INTERPRETER POINTER}
        _SWITCH_({ADD     AX, M4_SWITCHOFFSET })
        MOV     SI,AX
        PUSH    BP      ;{RETURN POINTER}
        MOV     DX,0080H  ;{   Disk C                                 }
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    BX,AX
        INT     13H
        PUSHF           ;{ REMEMBER STATUS}
        POP     BX
        _SWITCH_({JMPHERE_FROM_OS})
        POP     BP      ;{RETURN STACK}
        POP     SI      ;{INTERPRETER PNTR}
        PUSH    BX
        _NEXT

worddoc({STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The figforth standard disc read-write linkage. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read-write and aborts with an error message for failures.
This function uses ``LBA'' : Logical Block Addressing and may
not work on elderly hard disks.
_BITS_({Where blk is at most 64K the largest addressable disk is
64M , you can get around this by filling in forthcode({LBAPAR}) and then calling
 forthcode({RBLK}) or forthcode({WBLK}) })
forthcode({DISK-ERROR}) contains the status of the latest operation,
bit 1 (carry flag) indicates an error.
},
{{BLOCK},{DISK-ERROR},{RBLK},{WBLK}})
;{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
HEADER({R/W},{RSLW},{DOCOL})
        DC      TOR
        DC      LIT, SPB, STAR  ;{ Sector number}
        DC      SWAP
;       On a big endian machine the following code is 16/32 bit clean.
;       The 2 m.s. bytes are overwritten by the next store.
         _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS })
        DC      LBA, LIT, 4, PLUS, STORE   ; { Address }
        DC      LIT, _SWITCH_({SWITCHSEGMENT})
        DC      LBA, LIT, 6, PLUS, STORE
        DC      LBA, LIT, 8, PLUS, STORE ; { Sector number. }
        DC      LBA
        DC      RR
        _0BRANCH(RSLW1)
        DC      RBLK
        _BRANCH(RSLW2)
RSLW1:  DC      WBLK
RSLW2:  DC      LDUP, DSKERR, STORE

        DC      ONE, LAND, LDUP
        _0BRANCH(RSLW4)
;{        DC      ZERO,   PREV,   FETCH,     STORE   ;This  buffer}
                                                   ;{ is no good!}
RSLW4:
        ;{ Handle error}
        DC      LIT,    9   ;{Write error}
        DC      FROMR, LSUB ;{ 1 less: read error}
        DC      QERR
        DC      SEMIS
;
});_END_({ _RWHD_})
        PAGE
        ;{ At line     LINE ~3500}
worddocsafe({DICTIONARY},{'},{tick},{--- addr},{P,L0},
{Used in the form: .
forthcode({'}) forthcode({nnnn})
Leaves the parameter field address of dictionary word forthvar({nnnn}).
As a compiler directive, executes in a colon-definition to compile
the address as a literal. If the word is not found after a search of
forthcode({CONTEXT}) and forthcode({CURRENT}) , an appropriate error message is given.},
{{CFA},{>LFA},{>NFA},{>PFA}} )
HEADER({'},{TICK},{DOCOL},B_IMMED)
        DC      PWORD
        DC      PFIND
        DC      LDUP
        DC      ZEQU
        DC      ZERO
        DC      QERR
        DC      LITER
        DC      SEMIS
;
worddoc({DICTIONARY},{FORGET-VOC},{forget_voc},{n1 dea -- n1 },{},
{Forget all words below forthvar({n1}) from the vocabulary
whose dea is given by forthvar({dea}) . Leave n1 as this word is
intended to be used with forthcode({FOR-VOCS}) .},
{{FORGET}})
HEADER({FORGET-VOC},{FORGV},{DOCOL})
        DC      TDUP
        DC      SWAP
        DC      ULESS
        _0BRANCH(FORGV1)
; { Forget part of contents.}
        DC      SWAP
        DC      TOR
        DC      TDFA
        DC      LDUP
FORGV3:
        DC      TLFA,FETCH    ; {Next voc}
        DC      LDUP
        DC      RR
        DC      ULESS
        _0BRANCH(FORGV3)
        DC      SWAP
        DC      TLFA
        DC      STORE
        DC      FROMR
        _BRANCH(FORGV2)
FORGV1:
;       { Vocabulary itself is also forgotten.}
        DC      TVFA
        DC      FORTH
        DC      DEFIN
        DC      FETCH     ;{ Unlink by linking next vocabulary.}
        DC      VOCL
        DC      STORE
FORGV2: DC      SEMIS
;
worddoc({DICTIONARY},{FORGET},{forget},{},{E,L0},
{Executed in the form:
               forthcode({FORGET}) forthvar({cccc})
 Deletes definition named forthvar({cccc}) from the dictionary with all entries
physically following it. In fig-FORTH, an error message will occur
if the forthcode({CURRENT}) and forthcode({CONTEXT}) vocabularies are not currently the same.},
{{FENCE}})
HEADER({FORGET},{FORG},{DOCOL})
        DC      CURR
        DC      FETCH
        DC      CONT
        DC      FETCH
        DC      LSUB
        DC      LIT,18H
        DC      QERR
        DC      TICK
        DC      LDUP
        DC      FENCE
        DC      FETCH
        DC      LESS
        DC      LIT,15H
        DC      QERR
        DC      LDUP
        DC      LIT,FORGV
        DC      FORV
        DC      DROP
        DC      SEMIS
;
worddoc({CONTROL},{BACK},{back},{addr --},{},
{Calculate the backward branch offset from forthcode({HERE}) to forthvar({addr}) and compile
into the next available dictionary memory address.},{{LOOP},{UNTIL}})
HEADER({BACK},{BACK},{DOCOL})
        DC      HERE
        DC      LSUB
        DC      COMMA
        DC      SEMIS
;
worddoc({CONTROL},{BEGIN},{begin},{--- addr n  (compiling)},{P,L0},
{Occurs in a colon-definition in form:
  forthexample({BEGIN ... UNTIL})
  forthexample({BEGIN ... AGAIN})
  forthexample({BEGIN ... WHILE ... REPEAT})
At run-time, forthcode({BEGIN}) marks the start of a sequence that may be
repetitively executed. It serves as a return point from the
corresponding forthcode({UNTIL}) , forthcode({AGAIN}) or forthcode({REPEAT})
When executing forthcode({UNTIL}) a return
to forthcode({BEGIN}) will occur if the top of the stack is false;
for forthcode({AGAIN}) and forthcode({REPEAT}) a return to forthcode({BEGIN}) always occurs.

At compile time forthcode({BEGIN}) leaves its return address and forthvar({n}) for compiler
error checking.},{})
HEADER({BEGIN},{BEGIN},{DOCOL},B_IMMED)
        DC      QCOMP
        DC      HERE
        DC      ONE
        DC      SEMIS
;
worddoc({CONTROL},{ENDIF},{endif},{addr n --- (compile)},{P,CO,L0},
{Occurs in a colon-definition in form:
 forthsamp({IF ... ENDIF})                                                                                                                   x
 forthsamp({IF ... ELSE ... ENDIF})
At run-time, forthcode({ENDIF}) serves only as the destination of a forward
branch from forthcode({IF}) or forthcode({ELSE}) . It marks the conclusion of the conditional
structure. forthcode({THEN}) is another name for forthcode({ENDIF}) . Both names are supported
in fig-FORTH.

At compile-time, forthcode({ENDIF}) computes the forward branch offset from forthvar({addr})
to forthcode({HERE}) and stores it at forthvar({addr}) . forthvar({n}) is used for error tests.},
{{IF},{ELSE}})
HEADER({ENDIF},{LENDIF},{DOCOL},B_IMMED)
        DC      QCOMP
        DC      TWO     ;{ Magic number}
        DC      QPAIR
        DC      HERE
        DC      OVER
        DC      LSUB
        DC      SWAP
        DC      STORE
        DC      SEMIS
;
worddoc({CONTROL},{THEN},{then},{},{P,CO,L O},
{An alias for forthcode({ENDIF}) .},{})
HEADER({THEN},{THEN},{DOCOL},B_IMMED)
        DC      LENDIF
        DC      SEMIS
;
worddoc({CONTROL},{DO},{do},{n1 n2 --- (execute)
addr n --- (compile)},{P,C2,L0},
{Occurs in a colon-definition in form:
    forthsamp({DO ... LOOP})

At run time, forthcode({DO}) begins a sequence with repetitive execution
controlled by a loop limit forthvar({n1}) and an index with initial value forthvar({n2}) . forthcode({DO})
removes these from the stack. Upon reaching forthcode({LOOP}) the index is
incremented by one.
Until the new index equals or exceeds the limit, execution loops
back to just after forthcode({DO}) ; otherwise the loop parameters are discarded
and execution continues ahead. Both forthvar({n1}) and forthvar({n2}) are determined at
run-time and may be the result of other operations.
Within a loop forthcode({I}) will copy the current value of the index to the
stack.

When compiling within the colon definition, forthcode({DO}) compiles forthcode({(DO)}) , leaves
the following address forthvar({addr}) and forthvar({n}) for later error checking.},
{{I},{LOOP},{+LOOP},{LEAVE}})
HEADER({DO},{DO},{DOCOL},B_IMMED)
        DC      COMP
        DC      XDO
        DC      HERE
        DC      THREE   ;{ Magic number}
        DC      SEMIS
;
worddoc({CONTROL},{LOOP},{loop},{addr n --- (compiling)},{P,C2,L0},
{Occurs in a colon-definition in form:
               forthsamp({DO ... LOOP})
At run-time, forthcode({LOOP}) selectively controls branching back to the
corresponding forthcode({DO}) based on the loop index and limit. The loop index
is incremented by one and compared to the limit. The branch back to
forthcode({DO}) occurs until the index equals or exceeds the limit;
at that time, the parameters are discarded and execution continues
ahead.

At compile-time, forthcode({LOOP}) compiles forthcode({(LOOP)}) and uses forthvar({addr}) to calculate an
offset to forthvar({DO}) . forthvar({n}) is used for error testing.},{})
HEADER({LOOP},{LLOOP},{DOCOL},B_IMMED)
        DC      THREE   ;{ Magic number}
        DC      QPAIR
        DC      COMP
        DC      XLOOP
        DC      BACK
        DC      SEMIS
;
worddocsafe({CONTROL},{(+LOOP)},{paren_plus_loop},{n ---},{C2},
{The run-time proceedure compiled by forthcode({+LOOP}), which increments the loop
index by n and tests for loop completion.},{{+LOOP}})
HEADER({+LOOP},{PLOOP},{DOCOL},B_IMMED)
        DC      THREE   ;{ Magic number}
        DC      QPAIR
        DC      COMP
        DC      XPLOO
        DC      BACK
        DC      SEMIS
;
worddoc({CONTROL},{UNTIL},{until},{f --- (run-time)
 addr n --- (compile)},{P,C2,L0},
{Occurs within a colon-definition in the form:
              forthsamp({BEGIN ... UNTIL})
At run-time, forthcode({UNTIL}) controls the conditional branch back to the
corresponding forthcode({BEGIN})  If f is false, execution returns to just after
forthcode({BEGIN}) .
if true, execution continues ahead.

At compile-time, forthcode({UNTIL}) compiles forthcode({0BRANCH}) and an offset from forthcode({HERE}) to
addr. forthvar({n}) is used for error tests.},{})
HEADER({UNTIL},{UNTIL},{DOCOL},B_IMMED)
        DC      ONE
        DC      QPAIR
        DC      COMP
        DC      ZBRAN
        DC      BACK
        DC      SEMIS
;
worddoc({CONTROL},{END},{end},{},{P,C2,L0},
{This is an 'alias' or duplicate definition for forthcode({UNTIL}) .},{{BEGIN}})
HEADER({END},{LEND},{DOCOL},B_IMMED)
        DC      UNTIL
        DC      SEMIS
;
worddoc({CONTROL},{AGAIN},{again},{addr n --- (compiling)},{P,C2,L0},
{Used in a colon-definition in the form:
                forthexample({BEGIN ... AGAIN})
At run-time, forthcode({AGAIN}) forces execution to return to corresponding
forthcode({BEGIN}) .
There is no effect on the stack. Execution cannot leave this loop
(unless forthcode({R>}) forthcode({DROP}) is executed one level below).

At compile time, forthcode({AGAIN}) compiles forthcode({BRANCH}) with an offset from forthcode({HERE}) to
addr. forthvar({n}) is used for compile-time error checking.},{})
HEADER({AGAIN},{AGAIN},{DOCOL},B_IMMED)
        DC      ONE
        DC      QPAIR
        DC      COMP
        DC      BRAN
        DC      BACK
        DC      SEMIS
;
worddoc({CONTROL},{REPEAT},{repeat},{addr n --- (compiling)},{P,C2},
{Used within a colon-definition in the form:
                 forthsamp({BEGIN ... WHILE ... REPEAT})
At run-time, forthcode({REPEAT}) forces an unconditional branch back to just
after the corresponding forthcode({BEGIN}) .

At compile-time, forthcode({REPEAT}) compiles forthcode({BRANCH}) and the offset from forthcode({HERE}) to
addr. forthvar({n}) is used for error testing.},{{WHILE}})
HEADER({REPEAT},{REPEA},{DOCOL},B_IMMED)
        DC      TOR
        DC      TOR
        DC      AGAIN
        DC      FROMR
        DC      FROMR
        DC      TWO     ;{ Magic number}
        DC      LSUB
        DC      LENDIF
        DC      SEMIS
;
worddoc({CONTROL},{IF},{if},{f --- (run-time) / --- addr n (compile)},{P,C2,L0},
{Occurs is a colon-definition in form:
      forthsamp({IF (tp) ...  ENDIF}) or
      forthsamp({IF (tp) ... ELSE (fp) ... ENDIF})
At run-time, forthcode({IF}) selects execution based on a boolean flag. If forthvar({f}) is
true (non-zero), execution continues ahead thru the true part. If forthvar({f})
is false (zero), execution skips till just after forthcode({ELSE}) to execute
the false part. After either part, execution resumes after forthcode({ENDIF}) .
forthcode({ELSE}) and its false part are optional.; if missing, false execution
skips to just after forthcode({ENDIF}) .

At compile-time forthcode({IF}) compiles forthcode({0BRANCH}) and reserves space for an offset
at forthvar({addr}) . forthvar({addr}) and forthvar({n}) are used later for resolution of the offset and
error testing.},{})
HEADER({IF},{LIF},{DOCOL},B_IMMED)
        DC      COMP
        DC      ZBRAN
        DC      HERE
        DC      ZERO
        DC      COMMA
        DC      TWO     ;{ Magic number           }
        DC      SEMIS
;
worddoc({CONTROL},{ELSE},{else},{addr1 n1 --- addr2 n2 (compiling)},{P,C2,L0},
{Occurs within a colon-definition in the form:
               forthexample({IF ... ELSE ... ENDIF})
At run-time, forthcode({ELSE}) executes after the true part following forthcode({IF}) . forthcode({ELSE})
forces execution to skip over the following false part and resumes
execution after the forthcode({ENDIF}) . It has no stack effect.

At compile-time forthcode({ELSE}) emplaces forthcode({BRANCH}) reserving a branch offset,
leaves the address forthvar({addr2}) and forthvar({n2}) for error testing. forthcode({ELSE}) also
resolves the pending forward branch from forthcode({IF}) by calculating the
offset from forthvar({addr1}) to forthcode({HERE}) and storing at forthvar({addr1}) .},{})
HEADER({ELSE},{LELSE},{DOCOL},B_IMMED)
        DC      TWO     ;{ Magic number }
        DC      QPAIR
        DC      COMP
        DC      BRAN
        DC      HERE
        DC      ZERO
        DC      COMMA
        DC      SWAP
        DC      TWO     ;{ Magic number           }
        DC      LENDIF
        DC      TWO     ;{ Magic number           }
        DC      SEMIS
;
worddoc({CONTROL},{WHILE},{while},{f --- (run-time) / ad1 nl --- ad1 n1 ad2 n2},{p,C2},
{Occurs in a colon-definition in the form:
         forthsamp({BEGIN ... WHILE (tp) ... REPEAT})
At run-time, forthcode({WHILE}) selects conditional execution based on boolean
flag forthvar({f}) . If forthvar({f}) is true (non-zero), forthcode({WHILE}) continues execution of the
true part thru to forthcode({REPEAT}) , which then branches back to forthcode({BEGIN}) . If forthvar({f}) is
false (zero), execution skips to just after forthcode({REPEAT}) , exiting the
structure.

At compile time, forthcode({WHILE}) emplaces forthcode({0BRANCH}) and leaves forthvar({ad2}) of the
reserved offset. The stack values will be resolved by forthcode({REPEAT}) .},{})
HEADER({WHILE},{WHILE},{DOCOL},B_IMMED)
        DC      LIF
        DC      TWOP        ;{ Magic number           }
        DC      SEMIS
;
worddoc({OUTPUT},{SPACES},{spaces},{n ---},{L0},
{Transmit forthvar({n}) ascii blanks to the output device.},{{SPACE},{OUT}})
HEADER({SPACES},{SPACES},{DOCOL})
        DC      ZERO
        DC      MAX
        DC      DDUP
        _0BRANCH(SPAX1)
        DC      ZERO
        DC      XDO     ;{DO}
SPAX2:  DC      SPACE
        _LOOP(SPAX2)    ;{LOOP}
SPAX1:  DC      SEMIS
;
worddoc({FORMATTING},{<#},{less_number_sign},{},{L0},
{Setup for pictured numeric output formatting using the words:
   forthcode({<#}) forthcode({#}) forthcode({#S}) forthcode({SIGN}) forthcode({#>})
The conversion is done on a double number producing
text at forthcode({PAD}) .},{{DPL},{HLD},{HOLD},{FLD}})
HEADER({<#},{BDIGS},{DOCOL})
        DC      PAD
        DC      HLD
        DC      STORE
        DC      SEMIS
;
worddoc({FORMATTING},{#>},{number_sign_greater},{d --- addr count},{L0},
{Terminates numeric output conversion by dropping forthvar({d}), leaving the text
address and character count suitable for forthcode({TYPE}).},{})
HEADER({#>},{EDIGS},{DOCOL})
        DC      DROP
        DC      DROP
        DC      HLD
        DC      FETCH
        DC      PAD
        DC      OVER
        DC      LSUB
        DC      SEMIS
;
worddoc({FORMATTING},{SIGN},{sign},{n d --- d},{L0},
{Stores an ascii "-" sign just before a converted numeric output
string in the text output buffer when forthvar({n}) is negative. forthvar({n}) is discarded
but double number forthvar({d}) is maintained. Must be used between forthcode({<#}) and forthcode({#>}) .},
{{+-},{D+-}})
HEADER({SIGN},{SIGN},{DOCOL})
        DC      ROT
        DC      ZLESS
        _0BRANCH(SIGN1) ;{IF}
        DC      LIT,2DH
        DC      HOLD    ;{ENDIF}
SIGN1:  DC      SEMIS
;
worddoc({FORMATTING},{#},{number_sign},{d1 --- d2},{L0},
{Generate from a double number forthvar({d1}), the next ascii character which is
placed in an output string. Result forthvar({d2}) is the quotient after division
by forthcode({BASE}), and is maintained for further processing. Used between forthcode({<#})
and forthcode({#>}).},{{#S}} )
HEADER({#},{DIG},{DOCOL})
        DC      BASE
        DC      FETCH
        DC      MSMOD
        DC      ROT
        DC      LIT,9
        DC      OVER
        DC      LESS
        _0BRANCH(DIG1)  ;{IF}
        DC      LIT,7
        DC      PLUS    ;{ENDIF}
DIG1:   DC      LIT,30H
        DC      PLUS
        DC      HOLD
        DC      SEMIS
;
worddoc({FORMATTING},{#S},{number_sign_s},{d1 --- d2},{L0},
{Generates ascii text in the text output buffer,
by the use of (sharp) dnl forthvar({#}),
until a zero double number forthvar({n2}) results.
Used between forthcode({<#}) and forthcode({#>}).},{})
HEADER({#S},{DIGS},{DOCOL})
DIGS1:  DC      DIG     ;{BEGIN}
        DC      OVER
        DC      OVER
        DC      LOR
        DC      ZEQU
        _0BRANCH(DIGS1) ;{UNTIL}
        DC      SEMIS
;
worddoc({OUTPUT},{D.R},{d_dot_r},{d n ---},{},
{Print a signed double number forthvar({d}) right aligned in a field forthvar({n}) characters
wide.},{{OUT},{D.}})
HEADER({D.R},{DDOTR},{DOCOL})
        DC      TOR
        DC      SWAP
        DC      OVER
        DC      DABS
        DC      BDIGS
        DC      DIGS
        DC      SIGN
        DC      EDIGS
        DC      FROMR
        DC      OVER
        DC      LSUB
        DC      SPACES
        DC      LTYPE
        DC      SEMIS
;
worddocsafe({OUTPUT},{.R},{dot_r},{n1 n2 ---},{},
{Print the number n1 right aligned in a field whose width is forthvar({n2}) . No
following blank is printed.},{{OUT},{.}})
HEADER({.R},{DOTR},{DOCOL})
        DC      TOR
        DC      STOD
        DC      FROMR
        DC      DDOTR
        DC      SEMIS
;
worddoc({OUTPUT},{D.},{d_dot},{d ---},{L1},
{Print a signed double number forthvar({d}),
according to the current forthcode({BASE}) . A blank follows.
},{{OUT},{.},{D.R}})
HEADER({D.},{DDOT},{DOCOL})
        DC      ZERO
        DC      DDOTR
        DC      SPACE
        DC      SEMIS
;
worddocsafe({OUTPUT},{.},{dot},{n ---},{L0},
{Print a number from a signed _BITS_ bit two's complement value,
converted according to the numeric forthcode({BASE}) .
A trailing blanks follows.},{{OUT},{U.},{.R},{D.R},{D.}})
HEADER({.},{DOT},{DOCOL})
        DC      STOD
        DC      DDOT
        DC      SEMIS
;
worddoc({OUTPUT},{?},{question},{addr --},{L0},
{Print the value contained at the address in free format according to
the current base.},{{OUT},{.}})
HEADER({?},{QUES},{DOCOL})
        DC      FETCH
        DC      DOT
        DC      SEMIS
;
worddocsafe({OUTPUT},{U.},{u_dot},{u ---},{L0},
{Print a number from a unsigned _BITS_ bit value,
converted according to the numeric forthcode({BASE}) .
A trailing blanks

follows.},{{OUT},{.},{.R},{D.R},{D.}})
HEADER({U.},{UDOT},{DOCOL})
        DC      ZERO
        DC      DDOT
        DC      SEMIS
;
worddoc({DICTIONARY},{FOR-WORDS},{for_words},{x1...xn xt dea --},{},
{For the word with the forthdefi({dictionary entry address}) forthsamp({dea})
and all that are linked from that word
execute forthvar({xt})
 with as data forthvar({x1..xn}) plus
the forthdefi({dea}) of those words.         forthvar({xt})
must have the stack diagram forthsamp({x1..xn nfa --- x1..xn})
},
{{FOR-VOCS},{EXECUTE}})
HEADER({FOR-WORDS},{FORW},{DOCOL})
        DC      SWAP
        DC      TOR
        DC      TOR
FORW1:  DC      FROMR
        DC      RR
        DC      OVER
        DC      TLFA
        DC      FETCH
        DC      TOR
        DC      EXEC
        DC      RR
        DC      ZEQU
        _0BRANCH(FORW1)
        DC      FROMR
        DC      DROP
        DC      FROMR
        DC      DROP
        DC      SEMIS
;
worddoc({DICTIONARY},{FOR-VOCS},{for_vocs},{x1..xn xt ---},{},
{For all vocabularies execute forthvar({xt})
 with as data the forthdefi({dea}) of those words. forthvar({xt})
must have the stack diagram forthsamp({x1..xn vlfa --- x1..xn})
},
{{FOR-WORDS},{EXECUTE}})
HEADER({FOR-VOCS},{FORV},{DOCOL})
        DC      TOR
        DC      VOCL
        DC      FETCH
        DC      TOR
FORV1:  DC      FROMR
        DC      RR
        DC      OVER
        DC      TVFA
        DC      FETCH
        DC      TOR
        DC      EXEC
        DC      RR
        DC      ZEQU
        _0BRANCH(FORV1)
        DC      FROMR
        DC      DROP
        DC      FROMR
        DC      DROP
        DC      SEMIS
;
worddoc({DICTIONARY},{VLIST},{vlist},{},{},
{List the names of the definitions in the context vocabulary.
dnl A break as per forthcode({?TERMINAL}) will terminate the listing.
} {})
HEADER({VLIST},{VLIST},{DOCOL})
        DC      CSLL
        DC      LOUT
        DC      STORE
        DC      LIT, IDDOT
        DC      CONT
        DC      FETCH
        DC      FORW
        DC      SEMIS
;
_NORMAL_BYE_({
worddoc({SYSTEM},{BYE},{bye},{---},{ISO FIG},
{Return to the host environment MSDOS.
},{{COLD}})
HEADER({BYE},{BYE},{DOCOL})
        DC      LIT, 4CH, ZERO, ZERO, ZERO, LIT, 21H, BIOS
;{ EXIT TO PC-DOS}
});_END_({ _NORMAL_BYE_})
_ABSOLUTELOAD_({
worddoc({SYSTEM},{BYE},{bye},{---},{ISO FIG},
{_PROTECTED_({Switch back to real mode.})
Return to the host environment MSDOS.
},{{COLD}})
CODE_HEADER({BYE},{BYE})
;{ EXIT TO PC-DOS, if run from PC-DOS, otherwise hang or whatever.}
        _SWITCH_({JMPHERE_FROM_FORTH})
RETDOSV: JMP 0:0        ; {Filled in during boot}
        _BITS32_({SET_32_BIT_MODE})

});_END_({ _ABSOLUTELOAD_})
_HOSTED_LINUX_({
worddoc({SYSTEM},{BYE},{bye},{---},{ISO FIG},
{Return to the host environment Linux.
},{{COLD}})
HEADER({BYE},{BYE},{DOCOL})
;{ Exit to linux, with okay status. }
        DC      ZERO, ZERO, ZERO, ONE, LINOS
});_END_({ _HOSTED_LINUX_})
;
worddoc({SCREEN},{LIST},{list},{n ---},{L0},
{Display the ascii text of screen forthvar({n}) on the selected output device.
forthcode({SCR}) contains the screen number during and after this process.},{})
HEADER({LIST},{LLIST},{DOCOL})
        DC      DECA
        DC      CR,LDUP
        DC      SCR,STORE
        DC      PDOTQ
        _STRING({SCR # })
        DC      DOT
        DC      LIT,10H
        DC      ZERO,XDO
LIST1:  DC      CR,IDO
        DC      LIT,3
        DC      DOTR,SPACE
        DC      IDO,SCR
        DC      FETCH,DLINE
        DC      QTERM   ;{ ?TERMINAL}
        _0BRANCH(LIST2)
        DC      LLEAV
LIST2:  _LOOP(LIST1)
        DC      CR,SEMIS
;
worddoc({SCREEN},{INDEX},{index},{from to --},{},
{Print the first line of each screen over the range forthvar({from}) , forthvar({to}) . This is
used to view the comment lines of an area of text on disc screens.},{{LIST}})
HEADER({INDEX},{INDEX},{DOCOL})
        DC      LIT,FF
        DC      EMIT,CR
        DC      ONEP,SWAP
        DC      XDO
INDE1:  DC      CR,IDO
        DC      LIT,3
        DC      DOTR,SPACE
        DC      ZERO,IDO
        DC      DLINE,QTERM
        _0BRANCH(INDE2)
        DC      LLEAV
INDE2:  _LOOP(INDE1)
        DC      SEMIS
;
HEADER({^},{DOTS},{DOCOL})
        DC      CR, PDOTQ
        _STRING({S: })
        DC      SPFET, SZERO, FETCH,
DOC2:   DC      OVER, OVER,  EQUAL, ZEQU
        _0BRANCH(DOC1)
        DC      ZERO, CELLP, LSUB, LDUP, FETCH, DOT
        _BRANCH(DOC2)
DOC1:    DC DROP, DROP
        DC SEMIS
;
worddoc({SCREEN},{TRIAD},{triad},{scr --},{},
{Display on the selected output device the three screens which
include that numbered forthvar({scr}) , beginning with a screen evenly divisible
by three. Output is suitable for source text records, and includes a
reference line at the bottom taken from line 15 of screen 4.},{{MESSAGE}})
HEADER({TRIAD},{TRIAD},{DOCOL})
        DC      LIT,FF
        DC      EMIT
        DC      LIT,3
        DC      SLASH
        DC      LIT,3
        DC      STAR
        DC      LIT,3
        DC      OVER,PLUS
        DC      SWAP,XDO
TRIA1:  DC      CR,IDO
        DC      LLIST
        DC      QTERM   ;{ ?TERMINAL}
        _0BRANCH(TRIA2)
        DC      LLEAV   ;{LEAVE}
TRIA2:  _LOOP(TRIA1)    ;{ENDIF}
        DC      CR
        DC      SEMIS
; This word is not even fig!
worddoc({MISC},{.CPU},{dot_cpu},{---},{},
{Print the name of the CPU processor present in the boot up
parameters. Using the bizar convention of a base-36 number.},
{{ABORT},{COLD}})
HEADER({.CPU},{DOTCPU},{DOCOL})
;{ PRINT CPU TYPE (8088)}
        DC      BASE,FETCH
        DC      LIT,36
        DC      BASE,STORE
        DC      LIT,CELLS(12),PORIG ;
        DC      TFET
_BITS32_({
        DC      LIT, 10000H, STAR, PLUS, ZERO
});_END_({ _BITS32_})
        DC      DDOT
        DC      BASE,STORE
        DC      SEMIS
;
_DIRECTMAPPED_({
;
worddoc({MEMORY},{LOW-DP},{low_dictionary_pointer},{---- addr},{},
{A user variable leaving the lowest address that is free in the lowest
1 Mbyte of physical memory. This variable can be swapped with DP to
compile into this area.
},{{LOW-EM}})
HEADER({LOW-DP},{LOWDP},{DOUSE})
        DC      CELLS(14)
;
worddoc({MEMORY},{LOW-EM},{low_end_memory},{---- addr},{},
{A user variable leaving the address just above the highest memory
usable in the lowest 1 Mbyte of physical memory. This area can be used
to compile buffers into that must be accessed from real mode.
},{{DP},{EM}})
HEADER({LOW-EM},{LOWEM},{DOUSE})
        DC      CELLS(15)
;
});_END_({ _DIRECTMAPPED_})
;
;{**** LAST DICTIONARY WORD ****}
worddoc({MISC},{TASK},{task},{},{},
{A no-operation word which marks the boundary between
the forth system and applications. },{{COLD}})
HEADER({TASK},{TASK},{DOCOL})
        DC      SEMIS
;
_EQULAYOUT_({
TEXTEND  EQU     $       ; {Show end of dictionary.}
INITDP   EQU     M4_INITDP ;{Where we want new words.}
});_END_({ _EQULAYOUT_})

_COMMENT

The remaining memory ( up to 'EM' ) is
used for:

        1. EXTENSION DICTIONARY
        2. PARAMETER STACK
        3. TERMINAL INPUT BUFFER
        4. RETURN STACK
        5. USER VARIABLE AREA
        6. DISK BUFFERS (UNLESS REQURIED <1 MBYTE)


_ENDCOMMENT

_HOSTED_LINUX_({
;       This is the proper way to do it.
;       No memory addresses should be arrived at through equates.
;       However now we must teach the linker to keep the
;       two sections together.

FORTHSIZE       EQU     $-ORG0
         section dictionary nobits write exec alloc

INITDP:                 ;  It may be that it is not consecutive with TASK
                        ;  And that is a hell of a problem.
        BUFFERSIZE      EQU  (KBBUF+2*CW)*NBUF

       _RESB    M4_EM - FORTHSIZE - RTS - US - BUFFERSIZE
INITS0:                         ;{ Growns down}
STRTIB: _RESB     RTS            ;{ Start return stack area}
INITR0:                         ;{ Grows down}
STRUSA: _RESB    US              ;{ User area}
BUF1:   _RESB    BUFFERSIZE      ;{ FIRST DISK BUFFER}
EM:
});_END_({ _HOSTED_LINUX_})
;

 CSEG    ENDS
        PAGE
_COMMENT

  MISC. NOTES AND SCATTERED THOUGHTS

- This source will assemble on all platforms where NASM is
  available by the command line:
  nasm -fbin fig86.asm -o fig86.com
  (There may be exceptions for special configurations.)
  The result will run on MSDOS systems only, or stand alone
  an an IBM-compatible computer

- In a MODERN version <ctrl> P  will echo all output to the
  printer. This is not programmed here, but a feature of the OS.
  The operating system may make available a command history too.

- Use the installation manual.  Descriptions for all FIG
  words are given.  Those ERROR messages you get in FORTH
  correspond to the relative line numbers in blocks
  4 and 5 of the installation manual's model.

- Remember that all the FORTH words in this version are
  upper case letters.  Use <CAPS LOCK> when in FORTH.

- Changing variable EM will allow you to create a larger
  dictionary space.  However I suggest you develop and
  DEBUG with EM set to 4000H.  Setting it to a larger value
  will result in a larger FORTH.EXE file, and you may
  need to run EXE2BIN ( Chap 10, DOS 2.0 ) to get enough
  disk space.  Once you are satisfied with what you have,
  then by all means take that extra memory.

- Reading the section on batch files may speed up your
  developement.  See the example files that came with
  the Macro Assembler.

- Subscribe to FORTH Dimensions.  It is a valuable source
  of system and application ideas.  Talking with fellow
  FORTH programmers is sure to stir up some exciting ideas.
  Consider joining a FIG chapter.  See the back of FORTH
  Dimensions for more info.

- <Ctrl-Break> will vector to WARM start ( Label WRM: )

_ENDCOMMENT

;{ Define the entry point, not valid for auto booting.}
        END     ORIG
worddocchapter({COMPILING},{ },
{The wordset forthvar({COMPILING}) contains words that compile
forthxref({IMMEDIATE}) words and numbers.
You need special precautions because these words would execute during
compilation. Numbers are compiled forthdefi({in line}) , behind a word that fetches
them.},
{},{},{},{})
worddocchapter({CONTROL},{ },
{The wordset forthvar({CONTROL}) contains words that influence the control flow
of a program, i.e. the sequence in which commands are executed in compiled words.
With control words you can have actions performed repeatedly, or
depending on conditions.
},{},{},{},{})
worddocchapter({DEFINING},{ },
{The wordset forthvar({DEFINING}) contains words that add new entries
to the dictionary. A number of such forthdefi({defining word})'s
are predefined, but there is
also the possibility to make new defining words, using
forthcode({<BUILDS}) and forthcode({DOES>}) .
},
{},{},{},{})
worddocchapter({DICTIONARY},{ },
{The wordset forthvar({DICTIONARY}) contains words that at a lower level than
the wordset forthvar({DEFINING}) concern the memory area that
is allocated to the dictionary. They may add data to the dictionary at the expense
of the free space, one cell or one byte at a time, or allocate a buffer at once.
The dictionary space may also be shrunk, and the words that were there are lost.
The forthdefi({dictionary entry}) of a word is represented by its lowest address. Based on that
an entry may considered a record with fields. Words to access those fields also belong
to this wordset.},
{},{},{},{})
worddocchapter({DOUBLE},{ },
{The wordset forthvar({DOUBLE}) contains words that manipulate forthdefi({double})'s.
_BITS32_({In this 32 Forth you would never need double's if it weren't
for the NUMBER formatting wordset that uses them exclusively.})},
{},{},{},{})
worddocchapter({ERRORS},{ },
{The wordset forthvar({ERRORS}) contains words to handle errors.},
{},{},{},{})
worddocchapter({FORMATTING},{ },
{The wordset forthvar({FORMATTING}) generates formatted output for
numbers, i.e. printing the digits in a field with a certain width,
possibly with sign etc.
This is possible in any forthdefi({number base}). (Normally base 10 is used,
which means that digits are found as a remainder by dividing by 10).
Formatting in Forth is always based on forthdefi({double}) numbers.
Single numbers are handled by converting them to forthdefi({double}) first.
This requires some double precision operators to be present in the Forth core.
forthxref({DOUBLE}) wordset. forthxref({MULTIPLYING}) wordset.
},
{},{},{},{})
worddocchapter({INIT},{ },
{The wordset forthvar({INIT}) contains words to initialise or reinitialise Forth.},
{},{},{},{})
worddocchapter({INPUT},{ },
{The wordset forthvar({INPUT}) contains words to get input from the terminal
and such. For disk I/O: forthxref({STORAGE}) },
{},{},{},{})
worddocchapter({JUGGLING},{ },
{The wordset forthvar({JUGGLING}) contains words that change the lifo-buffer.
The necessity for this arise, because the data you want to feed to a program
is not directly accessible, i.e. on top of the stack.
It also possible that  you need the same data twice, because you have to feed
it to two different program's.
Design your program such that you need them as little as possible,
because they are confusing.},
{},{},{},{})
worddocchapter({LOGIC},{ },
{The wordset forthvar({LOGIC}) contains logic operators and
comparison operators.
A comparison operators (such as forthcode({=}) ) delivers a
forthdefi({logical flag}), 1 for true, 0 for false, representing a
condition (such as that two numbers are equal).
The logical operators ( forthcode({AND}) etc.)
work on all _BITS_ bits, one by one.
In this way they are useful for mask operations, as well
as for combining conditions
represented as flag's.
But beware that forthcode({IF}) only cares whether
the top of the stack is non-zero, such that
forthcode({-}) can mean non-equal to forthcode({IF}).
Such conditions (often named just forthdefi({flag})'s)
cannot be directly combined using logical operators,
but forthsamp({0= 0=}) can help.},
{},{},{},{})
worddocchapter({MEMORY},{ },
{The wordset forthvar({MEMORY}) contains words to fetch and
store numbers from forthdefi({double})s, forthdefi({cell})s or bytes in memory.
There are also words to copy blocks of memory or fill them, and words that
fetch a forthdefi({cell}), operate on it and store it back.},
{},{},{},{})
worddocchapter({MISC},{ },
{The wordset forthvar({MISC}) contains words that defy categorisation.},
{},{},{},{})
worddocchapter({MULTIPLYING},{ },
{The _BITS32_(original) 16 bits Forth's have problems with scaling (forthpxref({OPERATOR})).
Operators with intermediate results of double precision solve this and are
present in the forthvar({MULTIPLYING}) wordset. _BITS32_({In this 32-bit Forth
you will have less need, but scaling remain tricky.}).
Formatting is done with forthdefi({double})'s exclusively, and relies
on this wordset. Operators with mixed precision and unsigned operators
allow to build arbitray precision from them in forthdefi({high level}) code.},
{},{},{},{})
worddocchapter({OPERATOR},{ },
{The wordset forthvar({OPERATOR}) contains the familiar operators for addition, multiplication etc.
The result of the operation is always
an integer number, so division can't be precise. The combination of
forthcode({/}) and forthcode({MOD}) (remainder) is such that you can get the
original back: forthsamp({n m /   m *  n m MOD   +}) allways has the value
forthvar({m}) . This is true for all Forth's.
On ciforth the forthcode({/}) is a forthdefi({symmetric division}), i.e.
forthsamp({-n m /}) give the same result as forthsamp({n m /}), but negated.
The forgeoing rule now has the consequence that forthsamp({MOD n m})
has forthvar({2m-1}) possible outcomes instead of forthvar({m}) .
This is very worrysome for mathematicians, who stick to the rule that
forthsamp({MOD n m}) gives a result in the range forthvar({0 ... m-1})
(forthdefi({floored division})).
_BITS16_({Having a mere 3000 for the number range can easily lead to
overflow in intermediate results during forthdefi({scaling:}) a multiplication
followed by a division. _VERBOSE_({ For example forthsamp({: ADD10% 110
* 100 / ;})}). There are special operators to get around that.
forthxref({MULTIPLYING}).})},
{},{},{},{})
worddocchapter({OUTPUT},{ },
{The wordset forthvar({OUTPUT}) contains words to output
to the terminal and such. For disk I/O: forthxref({STORAGE}) },
{},{},{},{})
worddocchapter({PARSING},{ },
{The forthdefi({outer interpreter}) is responsible for parsing, i.e.
it gets a word from the input stream and interprets or compiles it,
advacing the forthcode({IN}) pointer. The wordset forthvar({PARSING}) contains
the words used by this interpreter and other words that consume characters
from the input stream. In this way the outer interpreter need not be very smart,
because its capabilities can be extended by new words based on those
building blocks.},
{},{},{},{})
worddocchapter({SCREEN},{ },
{Most of the mass storage is used for forthdefi({screen})'s that
have 16 lines of 64 characters. They are used for source code
and documentation.
Each screen is a whole number of forthcode({BLOCK})'s,
in our case it is one block.
The forthvar({SCREEN}) wordset contains facilities to view screens,
and forthdefi({load}) them, that is compiling them and thus extending
the base system.
A system is customized by loading source screens, possibly one of
these extension is a text editor for screens.},
{},{},{},{})
worddocchapter({SECURITY},{ },
{The wordset forthvar({SECURITY}) contains words that are used by control
words to abort with an error message if the control structure is not
correct. _VERBOSE_({Some say that this is not Forth-like.})
You only need to know them if want to extend the
forthvar({CONTROL}) wordset.},
{},{},{},{})
worddocchapter({STACKS},{ },
{The wordset forthvar({STACKS}) contains words related to the
forthdefi({data stack}) and forthdefi({return stack}).
Words can be moved between both stacks.
Stacks can be reinitialised and the value used to initialise the
forthdefi({stack pointer})'s can be altered.},
{},{},{},{})
worddocchapter({STORAGE},{ },
{The wordset forthvar({STORAGE}) contains words to input and output
to the mass storage, in this ciforth _BOOTFD_({ to the hard disk})
_BOOTHD_({to the hard disk}) _HOSTED_({to the file
forthfile({BLOCKS.BLK})}).
They are the underlying the forthvar({SCREEN}) facilities.},
{},{},{},{})
worddocchapter({STRING},{ },
{The wordset forthvar({STRING}) contains words that manipulate
strings of characters.},
{},{},{},{})
worddocchapter({SUPERFLUOUS},{ },
{The wordset forthvar({ SUPERFLUOUS}) contains words that are superfluous,
because they are equivalent to small sequences of code.
_VERBOSE_({Traditionally one hoped to speed Forth up by coding these words
directly})},
{},{},{},{})
worddocchapter({SYSTEM},{ },
{The wordset forthvar({SYSTEM}) contains words that call the underlying operating
system or functions available in the BIOS-rom.},
{},{},{},{})
worddocchapter({VOCABULARIES},{ },
{The dictionary is subdivided in non-overlapping subsets:
the forthdefi({vocabulary})'s. forthxref({DICTIONARY}).
They are created by the defining word
forthcode({VOCABULARY}) and filled by defining words while that
vocabulary is forthcode({CURRENT}) . They regulate how words are
found, different vocabularies can have words with the same names.
The wordset forthvar({VOCABULARIES}) contains words that manipulate
those vocabularies.},
{},{},{},{})
