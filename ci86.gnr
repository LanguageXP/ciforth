;               HCC FIG generic 8086 FORTH
; $Id$
; Copyright (2000): Albert van der Horst, HCC FIG Holland by GNU Public License
;
	PAGE  66,106
 TITLE   GENERIC FORTH FOR 8086 $Revision$
 _HEADER_ASM
_COMMENT 
	      FIG-FORTH
   implemented by:  Charlie Krajewski
		    205 ( BIG ) Blue Rd.
		    Middletown, CT  06457

	This generic version by:
		Albert van der Horst
		HCC Forth user group
		The Netherlands
		www.forth.hccnet.nl

  This implementation supports only one 64k segment

  The listing has been made possible by the
  prior work of:
	       Thomas Newman, Hayward, Ca.

 : other_acknowledgements
	 John_Cassidy
	 Kim_Harris
	 George_Flammer
	 Robert_D._Villwock ;
 To upgrade, modify, and understand Fig Forth, the
 value of the following book cannot be overstated:
	 Systems Guide to FIG Forth
	 C. H. Ting, PhD
 It is available through MVP.  See any recent issue
 of FORTH Dimensions for their ad.

No one who programs with FORTH can afford to be without:
  Starting Forth
  Leo Brodie
Get it.  Available through FORTH Interest Group.
Can also be found in many book stores.
Chapter 3 serves as a guide for the EDITOR that you
will probably type in from the FIG-Forth installation
manual.

Although there is much to be said for typing in your own
listing and getting it running, there is much to be said 
not typing in your own listing.  If you feel that 100+
pages of plinking is nutty, contact me for availability
of a disc with source & executable files.  Obtainable at
a bargain basement price, prepare yourself for bargain
basement support.

All publications of the FORTH Interest Group are public domain.
They may be further distributed by the inclusion of this
credit notice:
	       This publication has been made available by:
       
	       FORTH Interest Group
	       P.O. Box 1105
	       San Carlos, Ca.  94070
_ENDCOMMENT
	PAGE
FIGREL	EQU	1	; FIG RELEASE #
FIGREV	EQU	0	;FIG REVISION #
USRVER  EQU     0  	; USER VERSION NUMBER
;
;	ASCII CHARACTER EQUIVALENTS
;
ABL	EQU	20H	; SPACE
ACR	EQU    	0DH	; CR
ADOT	EQU	2EH	; PERIOD
BELL	EQU	07H	; ^G
BSIN	EQU	08H	; INPUT DELETE CHARACTER
BSOUT	EQU	08H	; OUTPUT BACKSPACE ( ^H )
DLE	EQU	10H	; ( ^P )  MAKE PRINTER OUTPUT DEVICE
LF	EQU 	0AH	; LINE FEED
FF	EQU	0CH	; FORM FEED
;
;	MEMORY + I/O CONSTANTS
;
SEC_DSK	EQU	360
PRINTER_NO	EQU	0
EM	EQU	04000H	; END OF MEMORY + 1
NSCR	EQU	2	; NO. 1024 BYTE SCREENS
KBBUF	EQU	512	;DATA BYTES PER DISK BUFFER
US	EQU	40H	; USER VARIABLE SPACE
RTS	EQU	0A0H	; RETURN STACK & TERM BUFFER
;
CO	EQU	KBBUF+4		; DISK BUFFER + 4 BYTES
NBUF	EQU	NSCR*1024/KBBUF	; NO. OF BUFFERS
BUF1	EQU	EM-CO*NBUF	; FIRST DISK BUFFER
INITR0	EQU	BUF1-US		; ( RO )
INITS0	EQU	INITR0-RTS	; ( S0 )
;
 PAGE
 CSEG    SEGMENT PARA PUBLIC 'CODE'
	ASSUME CS:CSEG,DS:CSEG,SS:CSEG,ES:CSEG
	ORG	100H	; FOR EXE2BIN COMMAND AFTER LINK
;			  SEE PG 10-14 OF DOS 2.0 MANUAL
;                         FOR EXPLANATION OF EXE2BIN
ORIG	PROC	FAR	; SEE PG 5-31, MACRO ASSEMBLER
	NOP
	JMP	LCLD     ;VECTOR TO COLD START
	NOP
	JMP	WRM	; VECTOR TO WARM START
;
	DB	FIGREL	; FIG RELEASE #
	DB	FIGREV	; FIG REVISION #
	DB	USRVER	; USER REVISION #
	DB	0EH	; VERSION ATTRIBUTES
	DW	TASK-7	; TOP WORD IN FORTH VOCABULARY
	DW	BSIN	; BACKSPACE
	DW	INITR0	; INIT (UP)
;
;	<<<<< following used in COLD start >>>>>
;       <<<<< must be in same order as user variables >>>>>
;
	DW 	INITS0	; INIT (S0)
	DW 	INITR0	; INIT (R0)
	DW 	INITS0	; INIT (TIB)
	DW	32	;       INIT (WIDTH)
	DW	0	; 	INIT (WARNING)
	DW	INITDP	;	INIT (FENCE)
	DW	INITDP  ;	INIT (DP)
	DW	FORTH+6	;	INIT (VOC-LINK)
	;
;	<<<<< end of data used by cold start >>>>>
;
;	The following is the CPU's name, printed
;       during cold start.
;       The name is 32 bits in base 32.
;
	DW	5H,0B328H	; '8088'
UP	DW	INITR0	; USER AREA POINTER
RPP	DW	INITR0	; RETURNS STACK POINTER
	PAGE
_COMMENT
   FORTH REGISTERS

   FORTH   8088     FORTH PRESERVATION RULES
   -----   ----     ----- ------------ -----
    IP      SI      Interpreter pointer.  Must be preserved
		    across FORTH words.

     W      DX      Working register.  Jump to 'DPUSH' will
		    push contents onto the parameter stack
		    before executing 'APUSH'.
 
    SP      SP      Parameter stack pointer.  Must be preserved 
		    across FORTH words.
 
    RP      BP      Return stack.  Must be preserved across
		    FORTH words.

	    AX      General register.  Must be preserved across
		    FORTH words.

	    BX      General purpose register.
 
	    CX      General purpose register.

	    DI      General purpose register.

	    CS      Segment register.  Must be preserved
		    across FORTH words.

	    DS      ditto
	
	    SS      ibid
 
	    ES      Temporary segment register only used by
		    a few words.

---------------------------------------------------------- 
_ENDCOMMENT
	PAGE
_COMMENT 
---------------------------------------------

   COMMENT CONVENTIONS
   ------- -----------

   =       IS EQUAL TO
   <-      ASSIGNMENT

  NAME        =  Address of name
  (NAME)      =  Contents of name
  ((NAME))    =  Indirect contents

  CFA         =  Address of CODE FIELD
  LFA         =  Address of LINK FIELD
  NFA         =  Address of NAME FIELD
  PFA         =  Address of PARAMETER FIELD

  S1          =  Parameter stack - 1st word
  S2          =  Parameter stack - 2nd word
  R1          =  Return stack    - 1st word
  R2          =  Return stack    - 2nd word

  LSB         =  Least significant bit
  MSB         =  Most  significant bit
  LB          =  Low byte
  HB          =  High byte
  LW          =  Low  word

------------------------------------------------------------ 
_ENDCOMMENT
	PAGE
_COMMENT 
	     DEBUG SUPPORT

THIS ROUTINE WILL ALLOW YOU TO STEP THRU FORTH PROGRAMS
EVERY TIME 'NEXT' IS EXECUTED.

IN ORDER TO USE THE STEP FEATURE YOU MUST DO THE FOLLOWING:

	1.  PATCH THE INSTRUCTION IN 'NEXT' WITH A JUMP
	    TO 'TNEXT'
 
	2.  PATCH YOUR BREAKPOINT ROUTINE AT
	    LABEL   'BREAK'
	
	3.  SET VARIABLES, `BIP' & `BIPE' TO THE
	    ADDRESSES YOU WANT TO STEP THRU.

THE CONTENTS OF THE 2 VARIABLES 'BIP` AND `BIPE'
ARE INTERPRETED AS FOLLOWS:

BIP	BIPE	DEBUG-CONDITION
---	----	---------------

  0	   X	OFF
 -1	   X    TRACE ALL `NEXT' CALLS
ADDR1      0    TRACE `ADDR1' ONLY
ADDR1  ADDR2    TRACE `ADDR1' TO `ADDR1'

NOTE:	THE ABOVE ADDRESSES CAN'T POINT TO A
	`CODE FIELD ADDRESS'. 
	X = DON'T CARE

----------------------------------------------------- 
_ENDCOMMENT

BIP	DW	0	; BREAKPOINT START ADDRESS
BIPE	DW	0	; BREAKPOINT END ADDR
	PAGE
;	THIS IS THE `NEXT' WITH DEBUG SUPPORT

TNEXT:  PUSHF		;SAVE REGISTER
	PUSH	AX
	MOV	AX,[BIP]  ; BREAKPOINT START ADDR
	OR	AX,AX	; ZERO?
	JZ	TNEXT2	; NO BREAKPOINT
	CMP	AX,-1
	JZ	TNEXT1	; STEP ALL POINTS
	CMP	AX,SI	; IN BREAKPOINT RANGE?
	JZ	TNEXT1	; STEP THIS LOCATION
	JA	TNEXT2	; NO
	MOV	AX,[BIPE] ; BREAKPOINT END ADDR
	OR	AX,AX	; ZERO?
	JZ	TNEXT2	; ONLY 1 LOCATION
	CMP	AX,SI	; IN RANGE STILL?
	JB	TNEXT2	; NO

;	PAUSE ON ADDRESS
;
TNEXT1: POPF
;
;********  ADD YOUR BREAKPOINT HERE  **********
;
BREAK:  JMP	SHORT	TNEXT3	;CONT WITH PROGRAM
;
;	NO BREAKPOINT PAUSE - RESTORE REGISTERS
;
TNEXT2:	POP	AX
	POPF
TNEXT3:	LODSW		; AX <- (IP)
	MOV	BX,AX
	JMP	SHORT	NEXT1
	PAGE
DPUSH:	PUSH	DX
APUSH:	PUSH	AX
_COMMENT

	Patch the next 3 locations
( using a DBUG monitor )
with a `JMP TNEXT' for tracing through
high level FORTH words.
_ENDCOMMENT
NEXT:	LODSW		;AX <- (IP)
	MOV	BX,AX
;
;
NEXT1:	MOV	DX,BX	; (W) <- (IP)
	INC	DX	; (W) <- (W) + 1
	JMP     _WORD_PTR[BX]    ; TO `CFA'
	PAGE
_START_DICTIONARY
DP0:    HEADER({LIT},{LIT},{$ + 2})
	LODSW		; AX <- LITERAL
	JMP SHORT     APUSH   ; TO TOP OF STACK
;
	HEADER({EXECUTE},{EXEC},{$+2})
	POP     BX      ; GET CFA
	JMP SHORT     NEXT1   ; EXECUTE NEXT
;
 	HEADER({BRANCH},{BRAN},{$+2})
BRAN1:	ADD	SI,[SI]
	JMP SHORT     NEXT    ; JUMP TO OFFSET
;
 	HEADER({0BRANCH},{ZBRAN},{$+2})
	POP	AX	; GET STACK VALUE
	OR	AX,AX	; ZERO?
	JZ	BRAN1	; YES, BRANCH
	INC	SI	; NO - CONTINUE...
	INC 	SI
	JMP SHORT     NEXT
;
	PAGE
;
 	HEADER({(LOOP)},{XLOOP},{$+2})
	MOV	BX,1	; INCREMENT
XLOO1:	ADD	[BP],BX	; INDEX = INDEX + INCR
	MOV	AX,[BP]	; GET NEW INDEX
	SUB	AX,[2+BP]        ; COMPARE WITH LIMIT
	XOR	AX,BX	; TEST SIGN
	JS	BRAN1	; KEEP LOOPING
;
;  END OF `DO' LOOP
	ADD	BP,_BYTE 4    ; ADJ RETURN STACK
	INC	SI	; BYPASS BRANCH OFFSET
	INC	SI
	JMP SHORT     NEXT
;	DEBUG STUFF
        HEADER({NOOP},{NOOP},{$+4})
NOP0	DW	$+2
	JMP SHORT     NEXT
NOP1	DW 	$+2
	JMP SHORT     NEXT
NOP2	DW	$+2
	JMP SHORT     NEXT
;
 	HEADER({(+LOOP)},{XPLOO},{$+2})
	POP	BX	; GET LOOP VALUE
	JMP SHORT     XLOO1
;
 	HEADER({(DO)},{XDO},{$+2})
	POP	DX	; INITIAL INDEX VALUE
	POP	AX	; LIMIT VALUE
	XCHG	BP,SP	; GET RETURN STACK
	PUSH	AX
	PUSH	DX
	XCHG	BP,SP	; GET PARAMETER STACK
	JMP	NEXT
	PAGE
;
 	HEADER({I},{IDO},{$+2})
	MOV	AX,[BP]	; GET INDEX VALUE
	JMP	APUSH	; TO PARAMETER STACK
        HEADER({DIGIT},{DIGIT},{$+2})
	POP	DX	;NUMBER BASE
	POP	AX	;ASCII DIGIT
	SUB	AL,'0'
	JB	DIGI2	;NUMBER ERROR
	CMP	AL,9
	JBE	DIGI1	;NUMBER = 0 THRU 9
	SUB	AL,7
	CMP	AL,10	;NUMBER 'A' THRU 'Z'?
	JB	DIGI2	;NO
DIGI1:	CMP	AL,DL	; COMPARE NUMBER TO BASE
	JAE	DIGI2	;NUMBER ERROR
	SUB	DX,DX	;ZERO
	MOV	DL,AL	;NEW BINARY NUMBER
	MOV	AL,1	;TRUE FLAG
	JMP	DPUSH	;ADD TO STACK
;   NUMBER ERROR
DIGI2:	SUB	AX,AX	;FALSE FLAG
	JMP	APUSH
	PAGE
        HEADER({(FIND)},{PFIND},{$+2})
	MOV	AX,DS
	MOV	ES,AX	;ES = DS
	POP	BX	;NFA
	POP	CX	;STRING ADDR
;
;  SEARCH LOOP
PFIN1:  MOV	DI,CX	;GET ADDR
	MOV	AL,[BX]	;GET WORD LENGTH
	MOV	DL,AL	;SAVE WORD LENGTH
	XOR	AL,[DI]
	AND	AL,3FH	;CHECK LENGTHS
	JNZ	PFIN5	;LENGTHS DIFFER

;
;   LENGTHS MATCH - CHECK EACH CHARACTER IN NAME
PFIN2:	INC	BX
	INC	DI	; NEXT CHAR OF NAME
	MOV	AL,[BX]
	XOR	AL,[DI]	;COMPARE NAMES
	ADD	AL,AL	;THIS WILL BE TEST BIT 8
	JNZ	PFIN5	;NO MATCH
	JNB	PFIN2	;MATCH SO FAR - LOOP
;
;   FOUND END OF NAME (BIT 8 SET) - A MATCH
	ADD	BX,_BYTE 5    ; BX = PFA
	PUSH	BX	; (S3) <- PFA
	MOV	AX,1	;TRUE VALUE
	SUB	DH,DH
	JMP	DPUSH
;
;   NO NAME MATCH - TRY ANOTHER
;
; GET NEXT LINK FIELD ADDR (LFA)
; ( ZERO = FIRST WORD OF DICTIONARY )
;
PFIN5:	INC	BX	;NEXT ADDR
	JB	PFIN6	;END OF NAME
	MOV	AL,[BX]	;GET NEXT CHAR
	ADD	AL,AL	;SET/RESET CARRY
	JMP SHORT     PFIN5   ;LOOP UNTIL FOUND
;
PFIN6:	MOV	BX,[BX]	; GET LINK FIELD ADDR
	OR	BX,BX	; START OF DICT ( 0 )
	JNZ	PFIN1	; NO , LOOK MORE
	MOV	AX,0	; FALSE FLAG
	JMP	APUSH	; DONE ( NO MATCH FOUND )
;
	PAGE
        HEADER({ENCLOSE},{ENCL},{$+2})
	POP	AX	;S1 - TERMINATOR CHAR
	POP	BX	;S2 - TEXT ADDR
	PUSH	BX	;ADDR - BACK TO STACK ( IT RHYMES )
	MOV	AH,0	;ZERO
	MOV	DX,-1	;CHAR OFFSET COUNTER
	DEC	BX	;ADDR -1
;
;   SCAN TO FIRST NON-TERMINATOR CHARACTER
ENCL1:	INC	BX	;ADDR+1
	INC	DX	;COUNT+1
	CMP	AL,[BX]
	JZ	ENCL1	;WAIT FOR NON-TERMINATOR
	PUSH	DX	;OFFSET TO 1ST TEXT CHAR
	CMP	AH,[BX]	;NULL CHAR?
	JNZ	ENCL2	;NO
;
;  FOUND NULL BEFORE 1ST NON-TERM CHAR
	MOV	AX,DX	;COPY COUNTER
	INC	DX	; +1
	JMP	DPUSH
;
;   FOUND FIRST TEXT CHAR - COUNT THE CHARS
ENCL2:	INC	BX	; ADDR+1
	INC	DX	;COUNT+1
	CMP	AL,[BX]	;TERMINATOR CHAR?
	JZ	ENCL4	;YES
	CMP	AH,[BX]	;NULL CHAR?
	JNZ	ENCL2	;NO, LOOP AGAIN
;
;   FOUND NULL AT END OF TEXT
ENCL3:	MOV	AX,DX	;COUNTERS ARE EQUAL
	JMP	DPUSH
;
;   FOUND TERMINATOR CHARACTER
ENCL4:	MOV	AX,DX
	INC	AX	;COUNT+1
	JMP	DPUSH
	PAGE
	; At line     LINE ~500
 	HEADER({EMIT},{EMIT},{ DOCOL})
	DW	PEMIT
	DW	ONE,OUTT
	DW	PSTOR,SEMIS
;
 	HEADER({KEY},{KEY},{$+2})
	JMP	PKEY
;
 	HEADER({?TERMINAL},{QTERM},{$+2})
	JMP	PQTER
;
 	HEADER({CR},{CR},{$+2})
	JMP	PCR
	PAGE
 	HEADER({CMOVE},{LCMOVE   },{$+2})
	CLD             ;INC DIRECTION
	MOV	BX,SI	;SAVE IF
	POP	CX	;COUNT
	POP	DI	;DEST
	POP	SI	;SOURCE
	MOV	AX,DS
	MOV	ES,AX	;ES <- DS
	REP	MOVSB	;THAT'S THE MOVE
	MOV	SI,BX	;GET BACK IP
	JMP	NEXT
;
 	HEADER({U*},{USTAR},{$+2})
	POP	AX
	POP	BX
	MUL	BX	;UNSIGNED
	XCHG	AX,DX	;AX NOW = MSW
	JMP	DPUSH	;STORE DOUBLE WORD
;
 	HEADER({U/},{USLAS},{$+2})
	POP	BX	;DIVISOR
	POP	DX	;MSW OF DIVIDEND
	POP	AX	;LSW OF DIVIDEND
	CMP	DX,BX	;DICIDE BY 0?
	JNB	DZERO	; ERROR - ZERO DIVIDE
	DIV	BX	;16 BIT DIVIDE
	JMP	DPUSH	;STORE QUOT/REM
;
;	DIVIDE BY ZERO ERROR - SHOW MAX NUMBERS
DZERO:	MOV	AX,-1
	MOV	DX,AX
	JMP	DPUSH	;STORE QUOT/REM
	PAGE
 	HEADER({AND},{ANDD},{$+2})
	POP	AX
	POP	BX
	AND	AX,BX
	JMP	APUSH
;
 	HEADER({OR},{ORR},{$+2})
	POP	AX      ; (S1) <- (S1) OR (S2)
	POP	BX
	OR	AX,BX
	JMP	APUSH
;
 	HEADER({XOR},{XORR},{$+2})
	POP	AX      ; (S1) <- (S1) XOR (S2)
	POP	BX
	XOR	AX,BX
	JMP	APUSH
	PAGE
 	HEADER({SP@},{SPAT},{$+2})
	MOV	AX,SP   ; (S1) <- (SP)
	JMP	APUSH
;
 	HEADER({SP!},{SPSTO},{$+2})
	MOV	BX,[UP]   ;USER VAR BASE ADDR
	MOV	SP,[6+BX]        ;RESET PARAM STACK POINTER
	JMP	NEXT
;
 	HEADER({RP@},{RPAT},{$+2	;(S1) <- (RP)})
	MOV	AX,BP	;RETURN STACK ADDR
	JMP	APUSH
;
 	HEADER({RP!},{RPSTO},{$+2})
	MOV	BX,[UP]   ;(AX) <- USR VAR BASE
	MOV	BP,[8+BX]        ;RESET RETURN STACK PTR
	JMP	NEXT
;
	PAGE
 	HEADER({;S},{SEMIS},{$+2})
	MOV	SI,[BP]	;(IP) <- (R1)
	INC	BP
	INC	BP	;ADJUST STACK
	JMP	NEXT
;
 	HEADER({LEAVE},{LLEAV   },{ $+2     })
        ;LIMIT <- INDEX
	MOV	AX,[BP]	;GET INDEX
	MOV	[2+BP],AX        ;STORE IT AT LIMIT
	JMP	NEXT
	PAGE
;
 	HEADER({>R},{TOR},{$+2})
        ; (R1) <- (S1)
	POP	BX	;GET STACK PARAMETER
	DEC	BP
	DEC	BP	;MOVE RETURN STACK DOWN
	MOV	[BP],BX	;ADD TO RETURN STACK
	JMP	NEXT
;
 	HEADER({R>},{FROMR},{$+2})
        ;(S1) <- (R1)
	MOV	AX,[BP]	; GET RETURN STACK VALUE
	INC	BP	;DELETE FROM STACK
	INC	BP
	JMP	APUSH
;
 	HEADER({R},{RR},{IDO+2})
	PAGE
 	HEADER({0=},{ZEQU},{$+2})
	POP	AX
	OR	AX,AX	;DO TEST
	MOV	AX,1	;TRUE
	JZ	ZEQU1	;IT'S 0
	DEC	AX	;FALSE
ZEQU1:	JMP	APUSH
;
 	HEADER({0<},{ZLESS},{$+2})
	POP	AX
	OR	AX,AX	;SET FLAGS
	MOV	AX,1	;TRUE
	JS	ZLESS1
	DEC	AX	;FALSE
ZLESS1:	JMP	APUSH
;
 	HEADER({+},{PLUS},{$+2})
	POP	AX      ;(S1) <- (S1) + (S2)
	POP	BX
	ADD	AX,BX
	JMP	APUSH
	PAGE
 	HEADER({D+},{DPLUS},{$+2})
	POP	AX	; YHW
	POP	DX	; YLW
	POP	BX	; XHW
	POP	CX	; XLW
	ADD	DX,CX	; SLW
	ADC	AX,BX	; SHW
	JMP	DPUSH
;
 	HEADER({MINUS},{MINUS},{$+2})
	POP	AX
	NEG	AX
	JMP	APUSH
;
 	HEADER({DMINUS},{DMINU},{$+2})
	POP	BX
	POP	CX
	SUB	AX,AX
	MOV	DX,AX
	SUB	DX,CX	; MAKE 2'S COMPLEMENT
	SBB	AX,BX	; HIGH WORD
	JMP	DPUSH
	PAGE
;
 	HEADER({OVER},{OVER},{$+2})
	POP	DX
	POP	AX
	PUSH	AX
	JMP	DPUSH
;
 	HEADER({DROP},{DROP},{$+2})
	POP	AX
	JMP	NEXT
;
 	HEADER({SWAP},{SWAP},{$+2})
	POP	DX
	POP	AX
	JMP	DPUSH
;
 	HEADER({DUP},{DUPE},{$+2})
	POP	AX
	PUSH	AX
	JMP	APUSH
	PAGE
 	HEADER({2DUP},{TDUP},{$+2})
	POP	AX
	POP	DX
	PUSH	DX
	PUSH	AX
	JMP	DPUSH
;
 	HEADER({+!},{PSTOR},{$+2})
	POP	BX	;ADDRESS
	POP	AX	;INCREMENT
	ADD	[BX],AX
	JMP	NEXT
;
 	HEADER({TOGGLE},{TOGGL},{$+2})
	POP	AX	;BIT PATTERN
	POP	BX	;ADDR
	XOR	[BX],AL	;
	JMP	NEXT
;
 	HEADER({@},{FETCH      },{    $+2})
	POP	BX
	MOV	AX,[BX]
	JMP	APUSH
	PAGE
 	HEADER({C@},{CAT},{$+2})
	POP	BX
	MOV	AL,[BX]
	SUB	AH,AH
	JMP	APUSH
;
 	HEADER({2@},{TAT},{$+2})
	POP	BX	;ADDR
	MOV	AX,[BX]	;MSW
	MOV	DX,[2+BX]        ;LSW
	JMP	DPUSH
;
 	HEADER({!},{STORE},{$+2})
	POP	BX	;ADDR
	POP	AX	;DATA
	MOV	[BX],AX
	JMP	NEXT
;
 	HEADER({C!},{CSTOR},{$+2})
	POP	BX	;ADDR
	POP	AX	;DATA
	MOV	[BX],AL
	JMP	NEXT
;
 	HEADER({2!},{TSTOR},{$+2})
	POP	BX	;ADDR
	POP	AX	;MSW
	MOV	[BX],AX
	POP	AX	;LSW
	MOV	[2+BX],AX
	JMP	NEXT
;
 	HEADER({L@},{LAT     },{ $+2})
	POP	BX	;MEM LOC
	POP	CX	;SEG REG VAL
	MOV	DX,DS
	MOV	DS,CX
	MOV	AX,[BX]
	MOV	DS,DX
	JMP	APUSH
;
 	HEADER({L!},{LSTORE},{$+2})
	POP	BX
	POP	CX
	MOV	DX,DS
	MOV	DS,CX
	POP	AX
	MOV	[BX],AX
	MOV	DS,DX
	JMP	NEXT
	PAGE
	; At line     LINE ~1000
;
 	HEADER({:},{COLON},{DOCOL},1)
	DW	QEXEC
	DW	SCSP
	DW	CURR
	DW	FETCH
	DW	CONT
	DW	STORE
	DW	CREAT
	DW	RBRAC
	DW	PSCOD
DOCOL:	INC	DX	;W=W+1
	DEC	BP
	DEC	BP	;(RP) <- (RP)-2
	MOV	[BP],SI	;R1 <- (RP)
	MOV	SI,DX	;(IP) <- (W)
	JMP	NEXT
;
 	HEADER({;},{SEMI},{DOCOL},1)
	DW	QCSP
	DW	COMP
	DW	SEMIS
	DW	SMUDG
	DW	LBRAC
	DW	SEMIS
	PAGE
 	HEADER({CONSTANT},{CON},{DOCOL})
	DW	CREAT
	DW	SMUDG
	DW	COMMA
	DW	PSCOD
DOCON:	INC	DX	;PFA
	MOV	BX,DX
	MOV	AX,[BX]	;GET DATA
	JMP	APUSH
;
 	HEADER({VARIABLE},{VAR},{DOCOL})
	DW	CON
	DW	PSCOD
DOVAR:	INC	DX	;(DE) <- PFA
	PUSH	DX
	JMP	NEXT
;
 	HEADER({USER},{USER},{DOCOL})
	DW	CON
	DW	PSCOD
DOUSE:	INC	DX	;PFA
	MOV	BX,DX
	MOV	BL,[BX]
	SUB	BH,BH
	MOV	DI,[UP]   ;USER VAR ADDRESS
	LEA	AX,[BX+DI]	;ADDR OF VARIABLE
	JMP	APUSH
	PAGE
 	HEADER({0},{ZERO},{$+2})
	XOR	AX,AX
	JMP	APUSH
;
 	HEADER({1},{ONE},{$+2})
	MOV	AX,1
	JMP	APUSH
;
 	HEADER({2},{TWO},{$+2})
	MOV	AX,2
	JMP	APUSH
;
 	HEADER({3},{THREE},{$+2})
	MOV	AX,3
	JMP	APUSH
;
 	HEADER({BL},{BLS},{DOCON})
;	THIS IS ONLY A SPAC
	DW	20H
;
 	HEADER({C/L},{CSLL},{DOCON})
	DW	64
;
 	HEADER({FIRST},{FIRST},{DOCON})
	DW	BUF1
;
 	HEADER({LIMIT},{LIMIT},{DOCON})
	DW	EM
;
 	HEADER({B/BUF},{BBUF},{DOCON})
	DW	KBBUF
;
 	HEADER({B/SCR},{BSCR},{DOCON})
	DW	400H/KBBUF
;
 	HEADER({+ORIGIN},{PORIG},{DOCOL})
	DW	LIT
	DW	ORIG
	DW	PLUS
	DW	SEMIS
	PAGE
;
 	HEADER({S0},{SZERO},{DOUSE})
	DW	6
;
 	HEADER({R0},{RZERO},{DOUSE})
	DW	8
;
 	HEADER({TIB},{TIB},{DOUSE})
	DW	0AH
;
 	HEADER({WIDTH},{WIDTHE  },{DOUSE})
	DW	0CH
;
        HEADER({WARNING},{WARN},{DOUSE})
	DW	0EH
;
 	HEADER({FENCE},{FENCE},{DOUSE})
	DW	10H
;
 	HEADER({DP},{DP},{DOUSE})
	DW	12H
;
 	HEADER({VOC-LINK},{VOCL},{DOUSE})
	DW	14H
;
 	HEADER({BLK},{BLK},{DOUSE})
	DW	16H
	PAGE
;
 	HEADER({IN},{INN},{DOUSE})
	DW	18H
;
 	HEADER({OUT},{OUTT},{DOUSE})
	DW	1AH
;
 	HEADER({SCR},{SCR},{DOUSE})
	DW	1CH
;
 	HEADER({OFFSET},{OFSET},{DOUSE})
	DW	0
;
 	HEADER({CONTEXT},{CONT  },{DOUSE})
	DW	20H
;
 	HEADER({CURRENT},{CURR},{DOUSE})
	DW	22H
;
 	HEADER({STATE},{STATE},{DOUSE})
	DW	24H
;
 	HEADER({BASE},{BASE},{DOUSE})
	DW	26H
;
 	HEADER({DPL},{DPL},{DOUSE})
	DW	28H
;
 	HEADER({FLD},{LFLD     },{  DOUSE})
	DW	2AH
;
 	HEADER({CSP},{CSPP},{DOUSE})
	DW	2CH
;
 	HEADER({R#},{RNUM},{DOUSE})
	DW	2EH
;
 	HEADER({HLD},{HLD},{DOUSE})
	DW	30H
;
;========== END USER VARIABLES =============;
	PAGE
;
 	HEADER({1+},{ONEP},{$+2})
	POP	AX
	INC	AX
	JMP	APUSH
;
 	HEADER({2+},{TWOP},{$+2})
	POP	AX
	ADD	AX,2
	JMP	APUSH
;
 	HEADER({HERE},{HERE},{DOCOL})
	DW	DP
	DW	FETCH
	DW	SEMIS
;
 	HEADER({ALLOT},{ALLOT},{DOCOL})
	DW	DP
	DW	PSTOR
	DW	SEMIS
;
 	HEADER({,},{COMMA       },{DOCOL})
	DW	HERE
	DW	STORE
	DW	TWO
	DW	ALLOT
	DW	SEMIS
;
 	HEADER({C,},{CCOMM},{DOCOL})
	DW	HERE
	DW	CSTOR
	DW	ONE
	DW	ALLOT
	DW	SEMIS
;
 	HEADER({-},{SUBB},{$+2})
	POP	DX	;S1
	POP	AX
	SUB	AX,DX
	JMP	APUSH	;S1 = S2 - S1
;
 	HEADER({=},{EQUAL},{DOCOL})
	DW	SUBB
	DW	ZEQU
	DW	SEMIS
;
 	HEADER({<},{LESS},{$+2})
	POP	DX	;S1
	POP	AX	;S2
	MOV	BX,DX
	XOR	BX,AX	;TEST FOR EQUAL SIGNS
	JS	LES1	;SIGNS ARE NOT THE SAME
	SUB	AX,DX
LES1:	OR	AX,AX	;TEST SIGN BIT
	MOV	AX,0	;ASSUME FALSE
	JNS	LES2	;NOT LESS THAN
	INC	AX	;TRUE (1)
LES2:	JMP	APUSH
;
 	HEADER({U<},{ULESS},{DOCOL,TDUP})
	DW	XORR,ZLESS
	DW	ZBRAN
	DW	OFFSET ULES1-$	;IF
	DW	DROP,ZLESS
	DW	ZEQU
	DW	BRAN
	DW	OFFSET ULES2-$
ULES1	DW	SUBB,ZLESS	;ELSE
ULES2	DW	SEMIS		;ENDIF
;
 	HEADER({>},{GREAT},{DOCOL})
	DW	SWAP
	DW	LESS
	DW	SEMIS
;
 	HEADER({ROT},{ROT},{$+2})
	POP	DX	;S1
	POP	BX	;S2
	POP	AX	;S3
	PUSH	BX
	JMP	DPUSH
;
 	HEADER({SPACE},{SPACE},{DOCOL})
	DW	BLS
	DW	EMIT
	DW	SEMIS
;
 	HEADER({-DUP},{DDUP},{DOCOL})
	DW	DUPE
	DW	ZBRAN	; IF
	DW	OFFSET DDUP1-$
	DW	DUPE	;ENDIF
DDUP1	DW	SEMIS
;
 	HEADER({TRAVERSE},{TRAV        },{DOCOL})
	DW	SWAP
TRAV1	DW	OVER	;BEGIN
	DW	PLUS
	DW	LIT,7FH
	DW	OVER
	DW	CAT
	DW	LESS
	DW	ZBRAN	;UNTIL
	DW	OFFSET TRAV1-$
	DW	SWAP
	DW	DROP
	DW	SEMIS
;
 	HEADER({LATEST},{LATES},{DOCOL})
	DW	CURR
	DW	FETCH
	DW	FETCH
	DW	SEMIS
;
 	HEADER({LFA},{LFA},{DOCOL})
	DW	LIT,4
	DW	SUBB
	DW	SEMIS
 	HEADER({CFA},{CFA},{DOCOL})
	DW	TWO
	DW	SUBB
	DW	SEMIS
;
 	HEADER({NFA},{NFA},{DOCOL})
	DW	LIT,5
	DW	SUBB
	DW	LIT,0FFFFH
	DW	TRAV
	DW	SEMIS
;
 	HEADER({PFA},{PFA},{DOCOL})
	DW	ONE
	DW	TRAV
	DW	LIT,5
	DW	PLUS
	DW	SEMIS
	PAGE
	; At line     LINE ~1500
 	HEADER({!CSP},{SCSP},{DOCOL})
	DW	SPAT
	DW	CSPP
	DW	STORE
	DW	SEMIS
;
 	HEADER({?ERROR},{QERR},{DOCOL})
	DW	SWAP
	DW	ZBRAN	;IF
	DW	OFFSET QERR1-$
	DW	ERROR
	DW	BRAN	;ELSE
	DW	OFFSET QERR2-$
QERR1	DW	DROP	;ENDIF
QERR2	DW	SEMIS
;
 	HEADER({?COMP},{QCOMP},{DOCOL})
	DW	STATE
	DW	FETCH
	DW	ZEQU
	DW	LIT,11H
	DW	QERR
	DW	SEMIS
	PAGE
 	HEADER({?EXEC},{QEXEC},{DOCOL})
	DW	STATE
	DW	FETCH
	DW	LIT,12H
	DW	QERR
	DW	SEMIS
;
 	HEADER({?PAIRS},{QPAIR},{DOCOL})
	DW	SUBB
	DW	LIT,13H
	DW	QERR
	DW	SEMIS
;
 	HEADER({?CSP},{QCSP},{DOCOL})
	DW	SPAT
	DW	CSPP
	DW	FETCH
	DW	SUBB
	DW	LIT,14H
	DW	QERR
	DW	SEMIS
;
 	HEADER({?LOADING},{QLOAD},{DOCOL})
	DW	BLK
	DW	FETCH
	DW	ZEQU
	DW	LIT,16H
	DW	QERR
	DW	SEMIS
	PAGE
 	HEADER({COMPILE},{COMP},{DOCOL})
	DW	QCOMP
	DW	FROMR
	DW	DUPE
	DW	TWOP
	DW	TOR
	DW	FETCH
	DW	COMMA
	DW	SEMIS
;
 	HEADER({[},{LBRAC},{DOCOL},1)
	DW	ZERO
	DW	STATE
	DW	STORE
	DW	SEMIS
;
 	HEADER({]},{RBRAC},{DOCOL})
	DW	LIT,0C0H
	DW	STATE
	DW	STORE
	DW	SEMIS
	PAGE
 	HEADER({SMUDGE},{SMUDG},{DOCOL})
	DW	LATES
	DW	LIT,20H
	DW	TOGGL
	DW	SEMIS
;
 	HEADER({HEX},{HEX},{DOCOL})
	DW	LIT,16
	DW	BASE
	DW	STORE
	DW	SEMIS
;
 	HEADER({DECIMAL},{DECA},{DOCOL})
	DW	LIT,10               
	DW	BASE
	DW	STORE
	DW	SEMIS
;
 	HEADER({(;CODE)},{PSCOD},{DOCOL})
	DW	FROMR
	DW	LATES
	DW	PFA
	DW	CFA
	DW	STORE
	DW	SEMIS
;
 	HEADER({;CODE},{SEMIC},{DOCOL},1)
	DW	QCSP
	DW	COMP
	DW	PSCOD
	DW	LBRAC
SEMI1	DW	NOOP	; ( ASSEMBLER )
	DW	SEMIS
;
 	HEADER({<BUILDS},{BUILD},{DOCOL})
	DW	ZERO
	DW	CON
	DW	SEMIS
;
 	HEADER({DOES>},{DOES},{DOCOL})
	DW	FROMR
	DW	LATES
	DW	PFA
	DW	STORE
	DW	PSCOD
DODOE:	XCHG	BP,SP	;GET RETURN STACK
	PUSH	SI	; (RP) <- (IP)
	XCHG	BP,SP
	INC	DX	;PFA
	MOV	BX,DX
	MOV	SI,[BX]	;NEW CFA
	INC	DX
	INC	DX
	PUSH	DX	;PFA
	JMP	NEXT
;
 	HEADER({COUNT},{COUNT},{DOCOL})
	DW	DUPE
	DW	ONEP
	DW	SWAP
	DW	CAT
	DW	SEMIS
;
 	HEADER({TYPE},{TYPES},{DOCOL})
	DW	DDUP
	DW	ZBRAN	; IF
	DW	OFFSET TYPE1-$
	DW	OVER
	DW	PLUS
	DW	SWAP
	DW	XDO	; DO
TYPE2	DW	IDO
	DW	CAT
	DW	LIT,7FH
	DW	ANDD	;STRIP 80H FROM LAST CHAR
	DW	EMIT
	DW	XLOOP	; LOOP
	DW	OFFSET TYPE2-$
	DW	BRAN	; ELSE
	DW	OFFSET TYPE3-$
TYPE1	DW	DROP	; ENDIF
TYPE3	DW	SEMIS
;
 	HEADER({-TRAILING},{DTRAI},{DOCOL})
	DW	DUPE
	DW	ZERO
	DW	XDO	;DO
DTRA1	DW	OVER
	DW	OVER
	DW	PLUS
	DW	ONE
	DW	SUBB
	DW	CAT
	DW	BLS
	DW	SUBB
	DW	ZBRAN	;IF
	DW	OFFSET DTRA2-$
	DW	LLEAV
	DW	BRAN	; ELSE
	DW	OFFSET DTRA3-$
DTRA2	DW	ONE
	DW	SUBB	; ENDIF
DTRA3	DW	XLOOP	; LOOP
	DW	OFFSET DTRA1-$
	DW	SEMIS
	PAGE
	; At line     LINE ~2000
 	HEADER_SGQ({(.")},{PDOTQ    },{DOCOL})
	DW	RR
	DW	COUNT
	DW	DUPE
	DW	ONEP
	DW	FROMR
	DW	PLUS
	DW	TOR
	DW	TYPES
	DW	SEMIS
;
 	HEADER_SGQ({."},{DOTQ    },{ DOCOL},1)
	DW	LIT,22H
	DW	STATE
	DW	FETCH
	DW	ZBRAN	; IF
	DW	OFFSET DOTQ1-$
	DW	COMP
	DW	PDOTQ
	DW	WORDS
	DW	HERE
	DW	CAT
	DW	ONEP
	DW	ALLOT
	DW	BRAN	; ELSE
	DW	OFFSET DOTQ2-$
DOTQ1	DW	WORDS
	DW	HERE
	DW	COUNT
	DW	TYPES	; ENDIF
DOTQ2	DW	SEMIS
	PAGE
 	HEADER({EXPECT},{EXPEC},{DOCOL})
	DW	OVER
	DW	PLUS
	DW	OVER
	DW	XDO	; DO
EXPE1	DW	KEY
	DW	DUPE
	DW	LIT,0EH
	DW	PORIG
	DW	FETCH
	DW	EQUAL
	DW	ZBRAN	; IF
	DW	OFFSET EXPE2-$
	DW	DROP
	DW	DUPE
	DW	IDO
	DW	EQUAL
	DW	DUPE
	DW	FROMR
	DW	TWO
	DW	SUBB
	DW	PLUS
	DW	TOR
	DW	ZBRAN	; IF
	DW	OFFSET EXPE6-$
	DW	LIT
	DW	BELL
	DW	BRAN	; ELSE
	DW	OFFSET EXPE7-$
EXPE6	DW	LIT
	DW	BSOUT	; ENDIF
EXPE7	DW	BRAN	; ELSE
	DW	OFFSET EXPE3-$
EXPE2	DW	DUPE
	DW	LIT,0DH
	DW	EQUAL
	DW	ZBRAN	; IF
	DW	OFFSET EXPE4-$
	DW	LLEAV
	DW	DROP
	DW	BLS
	DW	ZERO
	DW	BRAN	; ELSE
	DW	OFFSET EXPE5-$
EXPE4	DW	DUPE	; ENDIF
EXPE5	DW	IDO
	DW	CSTOR
	DW	ZERO
	DW	IDO
	DW	ONEP
	DW	STORE	; ENDIF
EXPE3	DW	EMIT
	DW	XLOOP	; LOOP
	DW	OFFSET EXPE1-$
	DW	DROP
	DW	SEMIS
;
 	HEADER({QUERY},{QUERY},{DOCOL})
	DW	TIB
	DW	FETCH
	DW	LIT,50H
	DW	EXPEC
	DW	ZERO
	DW	INN
	DW	STORE
	DW	SEMIS
	PAGE
	
;       Special header putting an ASCII NULL in the dictionary.
 	HEADER_NULL({(NULL)},{NULL    },{ DOCOL})
	DW	BLK
	DW	FETCH
	DW	ZBRAN	; IF
	DW OFFSET NULL1-$
	DW	ONE
	DW	BLK
	DW	PSTOR
	DW	ZERO
	DW	INN
	DW	STORE
	DW	BLK
	DW	FETCH
	DW	BSCR
	DW	ONE
	DW	SUBB
	DW	ANDD
	DW	ZEQU
	DW	ZBRAN	; IF
	DW	OFFSET NULL2-$
	DW	QEXEC
	DW	FROMR
	DW	DROP	; ENDIF
NULL2	DW	BRAN	; ELSE
	DW	OFFSET NULL3-$
NULL1	DW	FROMR
	DW	DROP	; ENDIF
NULL3	DW	SEMIS
;
 	HEADER({FILL},{FILL},{$+2})
	POP	AX	; FILL CHAR
	POP	CX	; FILL COUNT
	POP	DI	; BEGIN ADDR
	MOV	BX,DS
	MOV	ES,BX	; ES <- DS
	CLD		; INC DIRECTION
	REP	STOSB	;STORE BYTE
	JMP	NEXT
;
 	HEADER({ERASE},{ERASEE},{DOCOL})
	DW	ZERO
	DW	FILL
	DW	SEMIS
;
 	HEADER({BLANKS},{BLANK},{DOCOL})
	DW	BLS
	DW	FILL
	DW	SEMIS
;
 	HEADER({HOLD},{HOLD},{DOCOL})
	DW	LIT,-1
	DW	HLD
	DW	PSTOR
	DW	HLD
	DW	FETCH
	DW	CSTOR
	DW	SEMIS
;
 	HEADER({PAD},{PAD},{DOCOL})
	DW	HERE
	DW	LIT,84
	DW	PLUS
	DW	SEMIS
;
 	HEADER({WORD},{WORDS},{DOCOL})
	DW	BLK
	DW	FETCH
	DW	ZBRAN	; IF
	DW	OFFSET WORD1-$
	DW	BLK
	DW	FETCH
	DW	BLOCK
	DW	BRAN	; ELSE
	DW	OFFSET WORD2-$
WORD1	DW	TIB
	DW	FETCH      ; ENDIF
WORD2	DW	INN
	DW	FETCH
	DW	PLUS
	DW	SWAP
	DW	ENCL
	DW	HERE
	DW	LIT,22H
	DW	BLANK
	DW	INN
	DW	PSTOR
	DW	OVER
	DW	SUBB
	DW	TOR
	DW	RR
	DW	HERE
	DW	CSTOR
	DW	PLUS
	DW	HERE
	DW	ONEP
	DW	FROMR
	DW	LCMOVE
	DW	SEMIS
	PAGE
 	HEADER({(NUMBER)},{PNUMB},{DOCOL})
PNUM1	DW	ONEP	; BEGIN
	DW	DUPE
	DW	TOR
	DW	CAT
	DW	BASE
	DW	FETCH
	DW	DIGIT
	DW	ZBRAN	; WHILE
	DW	OFFSET PNUM2-$
	DW	SWAP
	DW	BASE
	DW	FETCH
	DW	USTAR
	DW	DROP
	DW	ROT
	DW	BASE
	DW	FETCH
	DW	USTAR
	DW	DPLUS
	DW	DPL
	DW	FETCH
	DW	ONEP
	DW	ZBRAN	; IF
	DW	OFFSET PNUM3-$
	DW	ONE
	DW	DPL
	DW	PSTOR	; ENDIF
PNUM3	DW	FROMR
	DW	BRAN	; REPEAT
	DW	OFFSET PNUM1-$
PNUM2	DW	FROMR
	DW	SEMIS
	PAGE
 	HEADER({NUMBER},{NUMB},{DOCOL})
	DW	ZERO
	DW	ZERO
	DW	ROT
	DW	DUPE
	DW	ONEP
	DW	CAT
	DW	LIT,2DH
	DW	EQUAL
	DW	DUPE
	DW	TOR
	DW	PLUS
	DW	LIT,-1
NUMB1	DW	DPL	; BEGIN
	DW	STORE
	DW	PNUMB
	DW	DUPE
	DW	CAT
	DW	BLS
	DW	SUBB
	DW	ZBRAN	; WHILE
	DW	OFFSET NUMB2-$
	DW	DUPE
	DW	CAT
	DW	LIT,2EH
	DW	SUBB
	DW	ZERO
	DW	QERR
	DW	ZERO
	DW	BRAN	; REPEAT
	DW	OFFSET NUMB1-$
NUMB2	DW	DROP
	DW	FROMR
	DW	ZBRAN	; IF
	DW	OFFSET NUMB3-$
	DW	DMINU	; ENDIF
NUMB3	DW	SEMIS
	PAGE
 	HEADER({-FIND},{DFIND},{DOCOL})
	DW	BLS
	DW	WORDS
	DW	HERE
	DW	CONT
	DW	FETCH
	DW	FETCH
	DW	PFIND
	DW	DUPE
	DW	ZEQU
	DW	ZBRAN	;IF
	DW	OFFSET DFIN1-$
	DW	DROP
	DW	HERE
	DW	LATES
	DW	PFIND	;ENDIF
DFIN1	DW	SEMIS
;
 	HEADER({(ABORT)},{PABOR},{DOCOL})
	DW	ABORT
	DW	SEMIS
;
 	HEADER({ERROR},{ERROR},{DOCOL})
	DW	WARN
	DW	FETCH
	DW	ZLESS
	DW	ZBRAN	;IF
	DW	OFFSET ERRO1-$
	DW	PABOR	;ENDIF
ERRO1	DW	HERE
	DW	COUNT
	DW	TYPES
	DW	PDOTQ
	DB	2
	DB	'? '
	DW	MESS
	DW	SPSTO
;
;	CHANGE FROM FIG MODEL
;	DW INN,FETCH,BLK,FETCH
;
	DW	BLK,FETCH
	DW	DDUP
	DW	ZBRAN	; IF
	DW	OFFSET ERRO2-$
	DW	INN,FETCH
	DW	SWAP	;ENDIF
ERRO2	DW	QUIT
;
 	HEADER({ID.},{IDDOT},{DOCOL})
	DW	PAD
	DW	LIT,20H
	DW	LIT,5FH
	DW	FILL
	DW	DUPE
	DW	PFA
	DW	LFA
	DW	OVER
	DW	SUBB
	DW	PAD
	DW	SWAP
	DW	LCMOVE
	DW	PAD
	DW	COUNT
	DW	LIT,1FH
	DW	ANDD
	DW	TYPES
	DW	SPACE
	DW	SEMIS
	PAGE
 	HEADER({CREATE},{CREAT},{DOCOL})
	DW	DFIND
	DW	ZBRAN	;IF
	DW	OFFSET CREA1-$
	DW	DROP
	DW	NFA
	DW	IDDOT
	DW	LIT,4
	DW	MESS
	DW	SPACE	;ENDIF
CREA1	DW	HERE
	DW	DUPE
	DW	CAT
	DW	WIDTHE
	DW	FETCH
	DW	MIN
	DW	ONEP
	DW	ALLOT
	DW	DUPE
	DW	LIT,0A0H
	DW	TOGGL
	DW	HERE
	DW	ONE
	DW	SUBB
	DW	LIT,80H
	DW	TOGGL
	DW	LATES
	DW	COMMA
	DW	CURR
	DW	FETCH
	DW	STORE
	DW	HERE
	DW	TWOP
	DW	COMMA
	DW	SEMIS
	PAGE
 	HEADER({[COMPILE]},{BCOMP},{DOCOL},1)
	DW	DFIND
	DW	ZEQU
	DW	ZERO
	DW	QERR
	DW	DROP
	DW	CFA
	DW	COMMA
	DW	SEMIS
;
        HEADER({LITERAL},{LITER},{DOCOL},1)
	DW	STATE
	DW	FETCH
	DW	ZBRAN	;IF
	DW	OFFSET LITE1-$
	DW	COMP
	DW	LIT
	DW	COMMA	;ENDIF
LITE1	DW	SEMIS
	PAGE
;
 	HEADER({DLITERAL},{DLITE},{DOCOL},1)
	DW	STATE
	DW	FETCH
	DW	ZBRAN	; IF
	DW	OFFSET DLIT1-$
	DW	SWAP
	DW	LITER
	DW	LITER	; ENDIF
DLIT1	DW	SEMIS
;
 	HEADER({?STACK},{QSTAC},{DOCOL})
	DW	SPAT
	DW	SZERO
	DW	FETCH
	DW	SWAP
	DW	ULESS
	DW	ONE
	DW	QERR
	DW	SPAT
	DW	HERE
	DW	LIT,80H
	DW	PLUS
	DW	ULESS
	DW	LIT,7
	DW	QERR
	DW	SEMIS
	PAGE
	; At line     LINE ~2500
 	HEADER({INTERPRET},{INTER},{DOCOL})
INTE1	DW	DFIND	;BEGIN
	DW	ZBRAN	;IF
	DW	OFFSET INTE2-$
	DW	STATE
	DW	FETCH
	DW	LESS
	DW	ZBRAN	;IF
	DW	OFFSET INTE3-$
	DW	CFA
	DW	COMMA
	DW	BRAN	;ELSE
	DW	OFFSET INTE4-$
INTE3	DW	CFA
	DW	EXEC	;ENDIF
INTE4	DW	QSTAC
	DW	BRAN	;ELSE
	DW	OFFSET INTE5-$
INTE2	DW	HERE
	DW	NUMB
	DW	DPL
	DW	FETCH
	DW	ONEP
	DW	ZBRAN	;IF
	DW	OFFSET INTE6-$
	DW	DLITE
	DW	BRAN	;ELSE
	DW	OFFSET INTE7-$
INTE6	DW	DROP
	DW	LITER	;ENDIF
INTE7	DW	QSTAC	;ENDIF
INTE5	DW	BRAN	;AGAIN
	DW	OFFSET INTE1-$
	PAGE
 	HEADER({IMMEDIATE},{IMMED},{DOCOL})
	DW	LATES
	DW	LIT,40H
	DW	TOGGL
	DW	SEMIS
;
 	HEADER({VOCABULARY},{VOCAB},{DOCOL})
	DW	BUILD
	DW	LIT
	DW	0A081H
	DW	COMMA
	DW	CURR
	DW	FETCH
	DW	CFA
	DW	COMMA
	DW	HERE
	DW	VOCL
	DW	FETCH
	DW	COMMA
	DW	VOCL
	DW	STORE
	DW	DOES
DOVOC	DW	TWOP
	DW	CONT
	DW	STORE
	DW	SEMIS
	PAGE
;
;   THE 'TASK-7' IS A COLD START VALUE ONLY.
;   IT IS CHANGED EACH TIME A DEFINITION IS
;   APPENDED TO THE 'FORTH' VOCABULARY.
;
 	HEADER({FORTH},{FORTH},{DODOE},1)
	DW	DOVOC
	DW	0A081H
	DW	TASK-7	;COLD START VALUE ONLY
	DW	0	; END OF VOCABULARY LIST
;
 	HEADER({DEFINITIONS},{DEFIN},{DOCOL})
	DW	CONT
	DW	FETCH
	DW	CURR
	DW	STORE
	DW	SEMIS
;
 	HEADER({(},{PAREN},{DOCOL},1)
	DW	LIT,')'
	DW	WORDS
	DW	SEMIS
	PAGE
 	HEADER({QUIT},{QUIT},{DOCOL})
	DW	ZERO
	DW	BLK
	DW	STORE
	DW	LBRAC
QUIT1	DW	RPSTO	;BEGIN
	DW	CR
	DW	QUERY
	DW	INTER
	DW	STATE
	DW	FETCH
	DW	ZEQU
	DW	ZBRAN	;IF
	DW	OFFSET QUIT2-$
	DW	PDOTQ
	DB	2
	DB	'OK'	;ENDIF
QUIT2	DW	BRAN	;AGAIN
	DW	OFFSET QUIT1-$
;
 	HEADER({ABORT},{ABORT},{DOCOL})
	DW	SPSTO
	DW	DECA
	DW	QSTAC	; IT DID TO & INCL THIS
	DW	CR
	DW	DOTCPU
	DW	PDOTQ
	DB	20
	DB	'IBM-PC Fig-Forth '
	DB	FIGREL+30H,ADOT,FIGREV+30H
	DW	FORTH
	DW	DEFIN
	DW	QUIT
	PAGE
;	WARM START VECTOR COMES HERE
;
WRM:	MOV	SI,OFFSET WRM1
	JMP	NEXT
;
WRM1	DW	WARM
;
 	HEADER({WARM},{WARM},{DOCOL})
	DW	MTBUF
	DW	ABORT
;
;	COLD START VECTOR COMES HERE
;
LCLD:    MOV     SI,OFFSET CLD1  ; (IP) <-
	MOV	AX,0
	MOV	DS,AX		;TO VECTOR AREA
	MOV	BX,08CH
	LEA	AX,[WRM]
	MOV	[BX],AX		;JUMP TO WRM ON <CTRL-BREAK>
	INC	BX
	INC	BX
	MOV	[BX],CS
	MOV	AX,CS
	MOV	DS,AX		; SET DATA SEG
	MOV	SP,_WORD_PTR[ORIG+12H]    ;PARAM. STACK
	MOV	SS,AX		; SET STACK SEGMENT
	MOV	ES,AX		; SET EXTRA SEG
	CLD			; DIR = INC
	MOV	BP,[RPP]          ; RETURN STACK
	JMP	NEXT
;
CLD1	DW	COLD
;
 	HEADER({COLD},{COLD},{DOCOL})
	DW	MTBUF
	DW	FIRST
	DW	USE,STORE
	DW	FIRST
	DW	PREV,STORE
	DW	DRZER
	DW	LIT,0
	DW	LIT,EPRINT
	DW	STORE
	DW	LIT
	DW	ORIG+12H
	DW	LIT,UP
	DW	FETCH
	DW	LIT,6
	DW	PLUS
	DW	LIT,10H
	DW	LCMOVE
	DW	LIT,ORIG+0CH
	DW	FETCH
	DW	LIT,FORTH+6
	DW	STORE
	DW	ABORT
	PAGE
 	HEADER({S->D},{STOD},{$+2})
	POP	DX	;S1
	SUB	AX,AX
	OR	DX,DX
	JNS	STOD1	;POS
	DEC	AX	;NEG
STOD1:	JMP	DPUSH
;
 	HEADER({+-},{PM},{DOCOL})
	DW	ZLESS
	DW	ZBRAN	;IF
	DW	OFFSET PM1-$
	DW	MINUS	;ENDIF
PM1	DW	SEMIS
;
 	HEADER({D+-},{DPM},{DOCOL})
	DW	ZLESS
	DW	ZBRAN	;IF
	DW	OFFSET DPM1-$
	DW	DMINU	;ENDIF
DPM1	DW	SEMIS
;
 	HEADER({ABS},{ABS1},{DOCOL})
	DW	DUPE
	DW	PM
	DW	SEMIS
;
 	HEADER({DABS},{DABS},{DOCOL})
	DW	DUPE
	DW	DPM
	DW	SEMIS
;
 	HEADER({MIN},{MIN},{DOCOL,TDUP})
	DW	GREAT
	DW	ZBRAN	;IF
	DW	OFFSET MIN1-$
	DW	SWAP	;ENDIF
MIN1	DW	DROP
	DW	SEMIS
;
 	HEADER({MAX},{MAX},{DOCOL,TDUP})
	DW	LESS
	DW	ZBRAN	;IF
	DW	OFFSET MAX1-$
	DW	SWAP	;ENDIF
MAX1	DW	DROP
	DW	SEMIS
	PAGE
 	HEADER({M*},{MSTAR},{DOCOL,TDUP})
	DW	XORR
	DW	TOR
	DW	ABS1
	DW	SWAP
	DW	ABS1
	DW	USTAR
	DW	FROMR
	DW	DPM
	DW	SEMIS
;
 	HEADER({M/},{MSLAS},{DOCOL})
	DW	OVER
	DW	TOR
	DW	TOR
	DW	DABS
	DW	RR
	DW	ABS1
	DW	USLAS
	DW	FROMR
	DW	RR
	DW	XORR
	DW	PM
	DW	SWAP
	DW	FROMR
	DW	PM
	DW	SWAP
	DW	SEMIS
;
 	HEADER({*},{STAR},{DOCOL})
	DW	MSTAR
	DW	DROP
	DW	SEMIS
;
 	HEADER({/MOD},{SLMOD},{DOCOL})
	DW	TOR
	DW	STOD
	DW	FROMR
	DW	MSLAS
	DW	SEMIS
;
 	HEADER({/},{SLASH},{DOCOL})
	DW	SLMOD
	DW	SWAP
	DW	DROP
	DW	SEMIS
;
 	HEADER({MOD},{MODD},{DOCOL})
	DW	SLMOD
	DW	DROP
	DW	SEMIS
;
 	HEADER({*/MOD},{SSMOD},{DOCOL})
	DW	TOR
	DW	MSTAR
	DW	FROMR
	DW	MSLAS
	DW	SEMIS
;
 	HEADER({*/},{SSLA},{DOCOL})
	DW	SSMOD
	DW	SWAP
	DW	DROP
	DW	SEMIS
;
 	HEADER({M/MOD},{MSMOD},{DOCOL})
	DW	TOR
	DW	ZERO
	DW	RR
	DW	USLAS
	DW	FROMR
	DW	SWAP
	DW	TOR
	DW	USLAS
	DW	FROMR
	DW	SEMIS
	PAGE
 	HEADER({(LINE)},{PLINE},{DOCOL})
	DW	TOR
	DW	LIT,64
	DW	BBUF
	DW	SSMOD
	DW	FROMR
	DW	BSCR
	DW	STAR
	DW	PLUS
	DW	BLOCK
	DW	PLUS
	DW	LIT,64
	DW	SEMIS
;
 	HEADER({.LINE},{DLINE},{DOCOL})
	DW	PLINE
	DW	DTRAI
	DW	TYPES
	DW	SEMIS
;
 	HEADER({MESSAGE},{MESS},{DOCOL})
	DW	WARN
	DW	FETCH
	DW	ZBRAN	;IF
	DW	OFFSET MESS1-$
	DW	DDUP
	DW	ZBRAN	;IF
	DW	OFFSET MESS2-$
	DW	LIT,4
	DW	OFSET
	DW	FETCH
	DW	BSCR
	DW	SLASH
	DW	SUBB
	DW	DLINE
	DW	SPACE	;ENDIF
MESS2	DW	BRAN	;ELSE
	DW	OFFSET MESS3-$
MESS1	DW	PDOTQ
	DB	6
	DB	'MSG # '
	DW	DOT	;ENDIF
MESS3	DW	SEMIS
	PAGE
	; At line     LINE ~3000
;--------------------------------------------
;
;	8086/88 PORT FETCH AND STORE
;
;--------------------------------------------
;
;
; FETCH CHARACTER (BYTE) FROM PORT
 	HEADER({PC@},{PTCAT},{$+2})
	POP	DX	; PORT ADDR
	IN	AL,DX	; BYTE INPUT
	SUB	AH,AH
	JMP	APUSH
;
;
; STORE CHARACTER (BYTE) AT PORT
 	HEADER({PC!},{PTCSTO    },{$+2})
	POP	DX	;PORT ADDR
	POP	AX	;DATA
	OUT	DX,AL	; BYTE OUTPUT
	JMP	NEXT
;
; FETCH WORD FROM PORT
 	HEADER({P@},{PTAT},{$+2})
	POP	DX	;PORT ADDR
	IN	AX,DX	;WORD INPUT
	JMP	APUSH
;
; STORE WORD AT PORT
 	HEADER({P!},{PTSTO     },{$+2})
	POP	DX	;PORT ADDR
	POP	AX	;DATA
	OUT	DX,AX	;WORD OUTPUT
	JMP	NEXT
;
BPS	EQU	512	;BYTES PER SECTOR
MXDRV	EQU	2	; MAX # DRIVES
;
;       ;ADDR OF NEXT BUFR TO USE
 	HEADER({USE},{USE},{DOVAR})
	DW BUF1
;
;       ;ADDR OF PREV USED BUFR
 	HEADER({PREV},{PREV},{DOVAR})
	DW	BUF1
;
;       ;# SECTORS/BLOCK
 	HEADER({SEC/BLK},{SPBLK},{DOCON})
	DW	KBBUF/BPS
        PAGE
        ;NO. OF BUFFERS
 	HEADER({#BUFF},{NOBUF},{DOCON})
        DW      NBUF
;
 	HEADER({+BUF},{PBUF},{DOCOL})
	DW	LIT,CO
	DW	PLUS,DUPE
	DW	LIMIT,EQUAL
	DW	ZBRAN
	DW	OFFSET PBUF1-$
	DW	DROP,FIRST
PBUF1	DW	DUPE,PREV
	DW	FETCH,SUBB
	DW	SEMIS
;
 	HEADER({UPDATE},{UPDAT},{DOCOL,PREV})
	DW	FETCH,FETCH
	DW	LIT,8000H
	DW	ORR
	DW	PREV,FETCH
	DW	STORE,SEMIS
;
 	HEADER({EMPTY-BUFFERS},{MTBUF},{DOCOL,FIRST})
	DW	LIMIT,OVER
	DW	SUBB,ERASEE
	DW	SEMIS
	PAGE
 	HEADER({DR0},{DRZER},{DOCOL,ZERO})
	DW	OFSET,STORE
	DW	SEMIS
;
;
; NOTE: THIS WORD WON'T WORK IF ONLY
;	USING SINGLE BUFFER
 	HEADER({BUFFER},{BUFFE},{DOCOL,USE})
	DW	FETCH,DUPE
	DW	TOR
BUFF1	DW	PBUF
	DW	ZBRAN
	DW	OFFSET BUFF1-$
	DW	USE,STORE
	DW	RR,FETCH
	DW	ZLESS
	DW	ZBRAN
	DW	OFFSET BUFF2-$
	DW	RR,TWOP
	DW	RR,FETCH
	DW	LIT,7FFFH
	DW	ANDD,ZERO
	DW	RSLW
BUFF2	DW	RR,STORE
	DW	RR,PREV
	DW	STORE,FROMR
	DW	TWOP,SEMIS
	PAGE
 	HEADER({BLOCK},{BLOCK},{DOCOL,OFSET})
	DW	FETCH,PLUS
	DW	TOR,PREV
	DW	FETCH,DUPE
	DW	FETCH,RR
	DW	SUBB
	DW	DUPE,PLUS
	DW	ZBRAN
	DW	OFFSET BLOC1-$
BLOC2	DW	PBUF,ZEQU
	DW	ZBRAN
	DW	OFFSET BLOC3-$
	DW	DROP,RR
	DW	BUFFE,DUPE
	DW	RR,ONE
	DW	RSLW
	DW	TWO,SUBB
BLOC3	DW	DUPE,FETCH
	DW	RR,SUBB
	DW	DUPE,PLUS
	DW	ZEQU
	DW	ZBRAN
	DW	OFFSET BLOC2-$
	DW	DUPE,PREV
	DW	STORE
BLOC1	DW	FROMR,DROP
	DW	TWOP,SEMIS
	PAGE
WERR	DB  	'DISK WRITE ERROR  $'
RERR	DB  	'DISK READ ERROR   $'
;
SSEC	PROC	NEAR
;	( ADDR  SEC# -- )
;	THIS ROUTINE WILL SELECT THE HEAD & DRIVE
	POP	DI	;SAVE RETURN
	POP	AX	;SECTOR #
	CMP	AX,SEC_DSK	;B DRIVE?
	JB	LDR0
	SUB	AX,SEC_DSK
	MOV	DX,AX	;LOAD LOGICAL SECTOR #
	MOV	AL,1	;SELECT DR B
	JMP	GSEC1
LDR0:    MOV     DX,AX   ;DR A
	MOV	AL,0	;SELECT DR A
GSEC1:	POP	BX	;TRANSFER ADDR
	MOV	CX,1	;READ 1 SECTOR
	PUSH	DI	;GET THAT RETURN BACK
	RET
_ENDP SSEC    ENDP
;
 	HEADER({RSEC},{RSEC},{$+2})
	CALL	SSEC
	PUSH	SI	;PRESERVE INTERPRETER POINTER
	PUSH	BP	;RETURN POINTER
	INT	25H
	JNC	DOK	;NO ERRORS
	LEA	DX,[RERR]
	JMP	DERR
;
 	HEADER({WSEC},{WSEC},{$+2})
	CALL	SSEC
	PUSH	SI
	PUSH	BP
	INT	26H
	JNC	DOK
	LEA	DX,[WERR]
DERR:	PUSH	AX
	MOV	AH,9	;STRING WRITE FNCN
	INT	21H
	POP	AX	;ERROR CODE IN AX
;  WRITE ERROR MESSAGE HERE
;
DOK:	POPF		;POP FLAGS
	POP	BP	;RETURN STACK
	POP	SI	;INTERPRETER PNTR
	JMP	NEXT
;
;
;	( ADDR  SECTOR#  FLAG (0=W, 1=R) --- )
 	HEADER({R/W},{RSLW	},{DOCOL})
	DW	ZBRAN
	DW	OFFSET RSLW1-$
	DW	RSEC
	DW	BRAN
	DW	OFFSET RSLW2-$
RSLW1	DW	WSEC
RSLW2	DW	SEMIS
	PAGE
 	HEADER({FLUSH},{FLUSH	},{DOCOL})
	DW	NOBUF,ONEP
	DW	ZERO,XDO
FLUS1	DW	ZERO,BUFFE
	DW	DROP
	DW	XLOOP
	DW	OFFSET FLUS1-$
	DW	SEMIS
;
 	HEADER({LOAD},{LOAD	},{DOCOL,BLK})
	DW	FETCH,TOR
	DW	INN,FETCH
	DW	TOR,ZERO
	DW	INN,STORE
	DW	BSCR,STAR
	DW	BLK,STORE	;BLK <- SCR * B/SCR
	DW	INTER	;INTERPRET FROM OTHER
SCREEN	DW	FROMR,INN
	DW	STORE
	DW	FROMR,BLK
	DW	STORE
	DW	SEMIS
	PAGE
 	HEADER({-->},{ARROW	},{DOCOL},1)
	DW	QLOAD
	DW	ZERO
	DW	INN
	DW	STORE
	DW	BSCR
	DW	BLK
	DW	FETCH
	DW	OVER
	DW	MODD
	DW	SUBB
	DW	BLK
	DW	PSTOR
	DW	SEMIS
	PAGE
;
;------------------------------------
; QUERY KEYBOARD FOR KEY PRESSED
;------------------------------------
;
; ( TRUE = CHAR READY, FALSE = NO CHAR )
;
; CALLED FROM  "?TERMINAL"
;
; USE 'KEY' TO GET KEY VALUE
;
PQTER:	CALL	CSTAT	;TEST FOR KEY
	OR	AL,AL	;ANY KEY?
	JZ	PQTER1	;NO
	MOV	AL,1	;TRUE = CHAR FOUND
PQTER1:	MOV	AH,0	;MAKE 16 BITS
	JMP	APUSH	;SAVE STATUS
;
;----------------------------
; CONSOLE INPUT ROUTINE
;----------------------------
;
; WAITS FOR A KEYBOARD CHAR
;
; CTRL-P WILL TOGGLE PRINTER ECHO FLAG
;
; CALLED FROM 'KEY'
;
PKEY:	CALL	CI	;CONSOLE INPUT
	CMP	AL,DLE	;PRINTER TOGGLE?
	JNE	PKEY1	;NO
	XOR _BYTE      [EPRINT], 1        ;TOGGLE ECHO
	JMP	PKEY	;GET ANOTHER KEY
PKEY1:	MOV	AH,0	;MAKE 16 BITS
	JMP	APUSH	;SAVE KEY VALUE
;
;---------------------------------------
; CONSOLE/PRINTER CHAR OUTPUT
;---------------------------------------
;
; CALLED FROM 'EMIT'
;
PEMIT	DW	$+2
	POP	AX	;GET CHAR
	CALL	POUT	;CHAR OUTPUT
	JMP	NEXT
	PAGE
;------------------------------
; CRLF TO CONSOLE/PRINTER
;------------------------------
;
; CALLED FROM 'CR'
;
PCR:	MOV	AL,ACR
	CALL	POUT	;CHAR OUTPUT
	MOV	AL,LF
	CALL	POUT
	JMP	NEXT
;
;-------------------------------------
; TRUE CONSOLE/PRINTER OUTPUT ROUTINE
;-------------------------------------
;
POUT	PROC	NEAR
	CALL	CHO	;CONSOLE OUT
	TEST _BYTE   [EPRINT],1        ;PRINTER ECHO?
	_EXTRANOP     ; In NASM there is a NOP here 
		      ;  to get the same code layout as with MASM
	JZ	POUT1	;OFF
	CALL	LO	;LIST OUTPUT
POUT1:	RET
_ENDP POUT    ENDP
;
; PRINTER ECHO FLAG
;
; VALUE: 0 = OFF, 1 = ON
;
EPRINT	DB	0,0
;
;------------------------
; GET KEYBOARD STATUS
;------------------------
;
; RETURNS KEYBOARD STATUS
;
;
; EXIT: REG AL = 0 IF NO KEY PRESSED
;       REG AL = CHAR IF  KEY PRESSED
;
CSTAT	PROC	NEAR
	PUSH	DX
	MOV	DX,0FFH
	MOV	AX,0600H
	INT	21H
	POP	DX
STATRT: RET
_ENDP CSTAT   ENDP
;
;-------------------------
; CONSOLE INPUT
;-------------------------
;
; WAITS FOR KEY FROM KEYBOARD
;
CI	PROC	NEAR
	MOV	AH,0	; READ CHAR FUNCTION
	INT	16H
	RET
_ENDP CI      ENDP
	PAGE
;--------------------
; CONSOLE OUTPUT
;--------------------
;
; OUTPUTS CHAR IN REG AL TO CONSOLE
;
; EXIT:	REG AL = CHAR
;
CHO	PROC	NEAR
	PUSH	DX
	PUSH	AX	;SAVE CHAR
	MOV	DL,AL	;CHAR TO WRITE
	MOV	AH,2	;CHAR OUT FUNCTION
	INT	21H	;DOS
	POP	AX
	POP	DX
	RET
_ENDP CHO     ENDP
;
;----------------------
;	LIST OUTPUT
;----------------------
;
; OUTPUTS CHAR IN REG AL TO
; LIST DEVICE (PRINTER)
;
; EXIT: REG AL = CHAR
;
LO	PROC	NEAR
	PUSH	AX	;SAVE CHAR
	PUSH	DX
	MOV	DX,PRINTER_NO
	MOV	AH,0	;PRINT CHAR
	INT	17H
	POP	DX
	POP	AX
	RET
_ENDP LO      ENDP
	PAGE
	; At line     LINE ~3500
 	HEADER({'},{TICK	},{DOCOL},1)
	DW	DFIND
	DW	ZEQU
	DW	ZERO
	DW	QERR
	DW	DROP
	DW	LITER
	DW	SEMIS
;
 	HEADER({FORGET},{FORG	},{DOCOL})
	DW	CURR
	DW	FETCH
	DW	CONT
	DW	FETCH
	DW	SUBB
	DW	LIT,18H
	DW	QERR
	DW	TICK
	DW	DUPE
	DW	FENCE
	DW	FETCH
	DW	LESS
	DW	LIT,15H
	DW	QERR
	DW	DUPE
	DW	NFA
	DW	DP
	DW	STORE
	DW	LFA
	DW	FETCH
	DW	CONT
	DW	FETCH
	DW	STORE
	DW	SEMIS
	PAGE
 	HEADER({BACK},{BACK	},{DOCOL})
	DW	HERE
	DW	SUBB
	DW	COMMA
	DW	SEMIS
;
 	HEADER({BEGIN},{BEGIN	},{DOCOL},1)
	DW	QCOMP
	DW	HERE
	DW	ONE
	DW	SEMIS
;
 	HEADER({ENDIF},{ENDIFF	},{DOCOL},1)
	DW	QCOMP
	DW	TWO
	DW	QPAIR
	DW	HERE
	DW	OVER
	DW	SUBB
	DW	SWAP
	DW	STORE
	DW	SEMIS
	PAGE
 	HEADER({THEN},{THEN	},{DOCOL},1)
	DW	ENDIFF
	DW	SEMIS
;
 	HEADER({DO},{DO	},{DOCOL},1)
	DW	COMP
	DW	XDO
	DW	HERE
	DW	THREE
	DW	SEMIS
;
 	HEADER({LOOP},{LOOPC	},{DOCOL},1)
	DW	THREE
	DW	QPAIR
	DW	COMP
	DW	XLOOP
	DW	BACK
	DW	SEMIS
	PAGE
 	HEADER({+LOOP},{PLOOP	},{DOCOL},1)
	DW	THREE
	DW	QPAIR
	DW	COMP
	DW	XPLOO
	DW	BACK
	DW	SEMIS
;
 	HEADER({UNTIL},{UNTIL	},{DOCOL},1)
	DW	ONE
	DW	QPAIR
	DW	COMP
	DW	ZBRAN
	DW	BACK
	DW	SEMIS
;
 	HEADER({END},{ENDD	},{DOCOL},1)
	DW	UNTIL
	DW	SEMIS
	PAGE
        HEADER({AGAIN},{AGAIN	},{DOCOL},1)
	DW	ONE
	DW	QPAIR
	DW	COMP
	DW	BRAN
	DW	BACK
	DW	SEMIS
;
 	HEADER({REPEAT},{REPEA	},{DOCOL},1)
	DW	TOR
	DW	TOR
	DW	AGAIN
	DW	FROMR
	DW	FROMR
	DW	TWO
	DW	SUBB
	DW	ENDIFF
	DW	SEMIS
;
 	HEADER({IF},{IFF	},{DOCOL},1)
	DW	COMP
	DW	ZBRAN
	DW	HERE
	DW	ZERO
	DW	COMMA
	DW	TWO
	DW	SEMIS
	PAGE
 	HEADER({ELSE},{ELSEE	},{DOCOL},1)
	DW	TWO
	DW	QPAIR
	DW	COMP
	DW	BRAN
	DW	HERE
	DW	ZERO
	DW	COMMA
	DW	SWAP
	DW	TWO
	DW	ENDIFF
	DW	TWO
	DW	SEMIS
;
 	HEADER({WHILE},{WHILE	},{DOCOL},1)
	DW	IFF
	DW	TWOP
	DW	SEMIS
	PAGE
 	HEADER({SPACES},{SPACS	},{DOCOL})
	DW	ZERO
	DW	MAX
	DW	DDUP
	DW	ZBRAN
	DW	OFFSET SPAX1-$
	DW	ZERO
	DW	XDO	;DO
SPAX2	DW	SPACE
	DW	XLOOP	;LOOP
	DW	OFFSET SPAX2-$
SPAX1	DW	SEMIS
;
 	HEADER({<#},{BDIGS	},{DOCOL})
	DW	PAD
	DW	HLD
	DW	STORE
	DW	SEMIS
;
 	HEADER({#>},{EDIGS	},{DOCOL})
	DW	DROP
	DW	DROP
	DW	HLD
	DW	FETCH
	DW	PAD
	DW	OVER
	DW	SUBB
	DW	SEMIS
	PAGE
 	HEADER({SIGN},{SIGN	},{DOCOL})
	DW	ROT
	DW	ZLESS
	DW	ZBRAN	;IF
	DW	OFFSET SIGN1-$
	DW	LIT,2DH
	DW	HOLD	;ENDIF
SIGN1	DW	SEMIS
;
 	HEADER({#},{DIG	},{DOCOL})
	DW	BASE
	DW	FETCH
	DW	MSMOD
	DW	ROT
	DW	LIT,9
	DW	OVER
	DW	LESS
	DW	ZBRAN	;IF
	DW	OFFSET DIG1-$
	DW	LIT,7
	DW	PLUS	;ENDIF
DIG1	DW	LIT,30H
	DW	PLUS
	DW	HOLD
	DW	SEMIS
;
 	HEADER({#S},{DIGS	},{DOCOL})
DIGS1	DW	DIG	;BEGIN
	DW	OVER
	DW	OVER
	DW	ORR
	DW	ZEQU
	DW	ZBRAN	;UNTIL
	DW	OFFSET DIGS1-$
	DW	SEMIS
;
 	HEADER({D.R},{DDOTR    },{DOCOL})
	DW	TOR
	DW	SWAP
	DW	OVER
	DW	DABS
	DW	BDIGS
	DW	DIGS
	DW	SIGN
	DW	EDIGS
	DW	FROMR
	DW	OVER
	DW	SUBB
	DW	SPACS
	DW	TYPES
	DW	SEMIS
;
 	HEADER({.R},{DOTR	},{DOCOL})
	DW	TOR
	DW	STOD
	DW	FROMR
	DW	DDOTR
	DW	SEMIS
	PAGE
 	HEADER({D.},{DDOT	},{DOCOL})
	DW	ZERO
	DW	DDOTR
	DW	SPACE
	DW	SEMIS
;
 	HEADER({.},{DOT	},{DOCOL})
	DW	STOD
	DW	DDOT
	DW	SEMIS
;
 	HEADER({?},{QUES	},{DOCOL})
	DW	FETCH
	DW	DOT
	DW	SEMIS
;
 	HEADER({U.},{UDOT	},{DOCOL})
	DW	ZERO
	DW	DDOT
	DW	SEMIS
	PAGE
	; At line     LINE ~4000
 	HEADER({VLIST},{VLIST	},{DOCOL})
	DW	LIT,80H
	DW	OUTT
	DW	STORE
	DW	CONT
	DW	FETCH
	DW	FETCH
VLIS1	DW	OUTT	;BEGIN
	DW	FETCH
	DW	CSLL
	DW	GREAT
	DW	ZBRAN	;IF
	DW	OFFSET VLIS2-$
	DW	CR
	DW	ZERO
	DW	OUTT
	DW	STORE	;ENDIF
VLIS2	DW	DUPE
	DW	IDDOT
	DW	SPACE
	DW	SPACE
	DW	PFA
	DW	LFA
	DW	FETCH
	DW	DUPE
	DW	ZEQU
	DW	QTERM
	DW	ORR
	DW	ZBRAN	;UNTIL
	DW	OFFSET VLIS1-$
	DW	DROP
	DW	SEMIS
;
; EXIT TO PC-DOS
 	HEADER({BYE},{BYE	},{$+2})
	INT	27H	;I'M HISTORY
	PAGE
 	HEADER({LIST},{LISTC	},{DOCOL,DECA})
	DW	CR,DUPE
	DW	SCR,STORE
	DW	PDOTQ
	DB	6,'SCR # '
	DW	DOT
	DW	LIT,10H
	DW	ZERO,XDO
LIST1	DW	CR,IDO
	DW	LIT,3
	DW	DOTR,SPACE
	DW	IDO,SCR
	DW	FETCH,DLINE
	DW	QTERM	; ?TERMINAL
	DW	ZBRAN
	DW	OFFSET LIST2-$	;IF
	DW	LLEAV
LIST2	DW	XLOOP
	DW	OFFSET LIST1-$	;ENDIF
	DW	CR,SEMIS
;
;	INDEX
;
	DB	85H
	DB	'INDE'
	DB	'X'+80H
	DW	LISTC-7
INDEX	DW	DOCOL
	DW	LIT,FF
	DW	EMIT,CR
	DW	ONEP,SWAP
	DW	XDO
INDE1	DW	CR,IDO
	DW	LIT,3
	DW	DOTR,SPACE
	DW	ZERO,IDO
	DW	DLINE,QTERM
	DW	ZBRAN
	DW	OFFSET INDE2-$
	DW	LLEAV
INDE2	DW	XLOOP
	DW	OFFSET INDE1-$
	DW	SEMIS
	PAGE
;	TRIAD
;
	DB	85H
	DB	'TRIA'
	DB	'D'+80H
	DW	INDEX-8
TRIAD	DW	DOCOL
	DW	LIT,FF
	DW	EMIT
	DW	LIT,3
	DW	SLASH
	DW	LIT,3
	DW	STAR
	DW	LIT,3
	DW	OVER,PLUS
	DW	SWAP,XDO
TRIA1	DW	CR,IDO
	DW	LISTC
	DW	QTERM	; ?TERMINAL
	DW	ZBRAN
	DW	OFFSET TRIA2-$	;IF
	DW	LLEAV   ;LEAVE
TRIA2	DW	XLOOP	;ENDIF
	DW	OFFSET TRIA1-$
	DW	CR
	DW	SEMIS
;
;	.CPU
;
; PRINT CPU TYPE (8088)
;
	DB	84H
	DB	'.CP'
	DB	'U'+80H
	DW	TRIAD-8
DOTCPU	DW	DOCOL
	DW	BASE,FETCH
	DW	LIT,36
	DW	BASE,STORE
	DW	LIT,22H
	DW	PORIG,TAT
	DW	DDOT
	DW	BASE,STORE
	DW	SEMIS
	PAGE
_COMMENT 

	    CODE LEVEL "MATCH" DEFINITIONS

 STACK PARAMETERS:

 ( cursor:addr   byte:left   str:addr  str:len
	   ---   flag  new:cursor:offset         )

 This version of MATCH will handle string lengths
      up to 65535 bytes in length.

_ENDCOMMENT
	DB	85H	; MATCH
	DB	'MATC'
	DB	'H'+80H
	DW	DOTCPU-7
MATCH	DW	$+2
	MOV	DI,SI	; SAVE IP
	POP	CX	; STRING COUNT
	POP	BX	;STRING ADDR
	POP	DX	;BYTES LEFT TO SEARCH
	POP	SI	;CURSOR ADDR
	PUSH	SI	;SAVE COPY
MAT1:	LODSB		;GET FIRST BYTE
	CMP	AL,[BX]	;MATCH?
	JNZ	MAT3	;NO
	PUSH	BX	;SAVE STRING ADDR
	PUSH	CX	; &   STRING COUNT
	PUSH	SI	; &   CURSOR ADDR
; TRY TO MATCH REMAINING CHARS IN STRING
;
MAT2:	DEC	CX	;STR. COUNT -1
	JZ	MATCHOK	;EXIT - MATCH FOUND
	DEC	DX	;BYTES LEFT -1
	JZ	NOMATCH	;EXIT - NO MATCH
	INC	BX	;NEXT STR CHAR ADDR
	LODSB		;GET FIRST BYTE
	CMP	AL,[BX]	;MATCH?
	JZ	MAT2	;YES, GET MORE
; NO MATCH YET
	POP	SI
	POP	CX
	POP	BX	;RESTORE POINTERS
MAT3:	DEC	DX	;BYTE LEFT COUNT -1
	JNZ	MAT1	;START OVER
	JMP	MAT4	;EXIT...NO MATCH
MATCHOK:
NOMATCH:
	POP	CX	;ADJUST STACK
	POP	CX	;FOR EXIT
	POP	CX
; EXIT HERE: DX = TRUE/FALSE FLAG ( 0=NO MATCH)
;
MAT4:	MOV	AX,SI	;NEW CURSOR ADDR
	POP	SI	;GET STARTING ADDR
	SUB	AX,SI	;COMPUTE CURSOR OFFSET
	MOV	SI,DI	;GET BACK UP
	JMP	DPUSH	; BYE..BYE
	PAGE
;
;**** LAST DICTIONARY WORD ****
;            T A S K
;
	DB	84H
	DB	'TAS'
	DB	'K'+80H
	DW	MATCH-8
TASK	DW	DOCOL
	DW	SEMIS
;
INITDP	EQU	$	;SHOW END OF DICTIONARY
;
_COMMENT 

The remaining memory ( up to 'EM' ) is 
used for:

	1. EXTENSION DICTIONARY
	2. PARAMETER STACK
	3. TERMINAL INPUT BUFFER
	4. RETURN STACK
	5. USER VARIABLE AREA
	6. DISK BUFFERS


_ENDCOMMENT
					
 CSEG    ENDS
_ENDP  ORIG    ENDP
	PAGE
_COMMENT 

  MISC. NOTES AND SCATTERED THOUGHTS

- This source will assemble on all platforms where NASM is available by the
  command line:
  nasm -fbin fig86.asm -o fig86.exe
  The result will run on MSDOS systems only.

- When in FORTH, <Ctrl> P  will echo all output to the
  printer.

- Use the installation manual.  Descriptions for all FIG
  words are given.  Those ERROR messages you get in FORTH
  correspond to the relative line numbers in blocks
  4 and 5 of the installation manual's model.  

- Remember that all the FORTH words in this version are
  upper case letters.  Use <CAPS LOCK> when in FORTH.

- Changing variable EM will allow you to create a larger
  dictionary space.  However I suggest you develop and
  DEBUG with EM set to 4000H.  Setting it to a larger value
  will result in a larger FORTH.EXE file, and you may
  need to run EXE2BIN ( Chap 10, DOS 2.0 ) to get enough
  disk space.  Once you are satisfied with what you have,
  then by all means take that extra memory.

- Reading the section on batch files may speed up your
  developement.  See the example files that came with
  the Macro Assembler.

- Subscribe to FORTH Dimensions.  It is a valuable source
  of system and application ideas.  Talking with fellow
  FORTH programmers is sure to stir up some exciting ideas.
  Consider joining a FIG chapter.  See the back of FORTH
  Dimensions for more info.

- <Ctrl-Break> will vector to WARM start ( Label WRM: )

_ENDCOMMENT

	END	ORIG

