;{               ciforth : a generic I86 ISO FORTH by HCC FIG}
;{ $Id$}
;{ Copyright (2000): Albert van der Horst, HCC FIG Holland by GNU Public License}
;
;{HCC FIG Holland : Hobby Computer Club, Forth Interest Group  Holland}
        PAGE  66,106
 TITLE   ciforth $Revision$
;
; For the generic system (to generate ciforth in an other configuration than this one):
;     http://home.hccnet.nl/a.w.m.van.der.horst/ci86gnr.html
;
; If this is a configured assembly file, it should be accompagnied with configured
; documentation (texinfo, ps, html.)
; WITHOUT THE DOCUMENTATION: GIVE UP! GET THE REAL THING!
; You have a configured system, if there are NO curly brackets on the next line.
; {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {}
;
; Configuration of this particular version:
; _BITS32_(32)_BITS16_(16){}-bits _REAL_({real mode })_PROTECTED_({protected mode })
; _BOOTED_({standalone })_HOSTED_LINUX_({running under Linux })dnl
_HOSTED_DPMI_({running under DPMI (OS/2 or MS-Windows)
; _CLASSIC_({with classic figforth I/O })_MODERN_({with modern MSDOS I/O })_USEBIOS_({Using the BIOS for I/O })
})dnl
_HOSTED_MSDOS_({running under MSDOS
; _CLASSIC_({with classic figforth I/O })_MODERN_({with modern MSDOS I/O })_USEBIOS_({Using the BIOS for I/O })
}) _LINUX_C_({;  with c-routines for I/O})_LINUX_N_({;  with native forth I/O})
; Normally ciforth doesn't observe ISO >IN{}_ISO_IN_({{, but this one does}}).
; Contains :
; (there may be no items here.)
_SECURITY_({{;        Security words
}})dnl
_LOAD_({{;         Loadable words, i.e. all of ISO CORE, more than is needed
;           for a self contained kernel.
}})dnl
_SOURCEFIELD_({{; A field in the header to point to source
}})dnl
_FEWBLOCKS_({{; number of blocks limited to 256
}})dnl
;
 _HEADER_ASM
_COMMENT
        A generic version of ISO FORTH for IBM type standard PC's
                Albert van der Horst
                HCC Forth user group
                The Netherlands
                www.forth.hccnet.nl

              based on
              FIG-FORTH
   implemented by:  Charlie Krajewski
                    205 ( BIG ) Blue Rd.
                    Middletown, CT  06457

  The listing has been made possible by the
  prior work of:
               Thomas Newman, Hayward, Ca.

 : other_acknowledgements
         John_Cassidy
         Kim_Harris
         George_Flammer
         Robert_D._Villwock ;

 : for tools
         Richard M. Stallman
         Linus Torvalds

No one who programs with FORTH can afford to be without:
  "Starting Forth  by Leo Brodie" and "Thinking Forth by Leo Brodie".
   Both out of print.

This Forth is a descendant in the 300+ (RCS)- generations from fig-Forth.

For nostalgic reasons the following comment has never been removed:
   Although there is much to be said for typing in your own
   listing and getting it running, there is much to be said
   not typing in your own listing.  If you feel that 100+
   pages of plinking is nutty, contact me for availability
   of a disc with source & executable files.  Obtainable at
   a bargain basement price, prepare yourself for bargain
   basement support.

All publications of the FORTH Interest Group are public domain.
They may be further distributed by the inclusion of this
credit notice:
               This publication has been made available by:

               FORTH Interest Group
               P.O. Box 1105
               San Carlos, Ca.  94070
[I feel obliged to keep this last one in (AH). Note that although it is
based on fig-Forth no stone is left unturned.]
_ENDCOMMENT
        PAGE
; ########################################################################################
;                       PREPARATION (no code)
; ########################################################################################
FIGREL  EQU     4       ;{ FIG RELEASE #}
FIGREV  EQU     0       ;{ FIG REVISION #}
USRVER  EQU     0      ;{ USER VERSION NUMBER, a digit now}
;
;{      VERY ELEMENTARY .}
CW      EQU     M4_CELLWIDTH    ;{ Size of a cell in Forth, not in the bootcode.}
ERRORSCREEN EQU     M4_ERRORSCREEN    ;{ Size of a cell in Forth, not in the bootcode.}
;
;{      MEMORY LAYOUT.}
;{ These values can be changed at this single place. }
NBUF    EQU     8      ;{ NO. OF BUFFERS AKA SCREENS }
KBBUF   EQU     1024    ;{DATA BYTES PER DISK BUFFER}
US      EQU     40H*CW     ;{ USER VARIABLE SPACE}
EM      EQU     M4_EM    ;{Where the memory ends w.r.t. ORIG.}
_BITS16_({RTS     EQU     0100H    ;{ RETURN STACK & TERM BUFFER} })
_BITS32_({RTS     EQU  10000H    ;{ RETURN STACK & TERM BUFFER} })
;
_FEWBLOCKS_({PMASK   EQU     0FFH    ;{ Allow to access only 256 blocks from OFFSET}})
;
;{      ASCII CHARACTER EQUIVALENTS}
;
ABL     EQU     ' '     ;{ SPACE}
ACR     EQU     0DH     ;{ CR}
ASO     EQU     '['     ;{ SQUARE BRACKET OPEN }
ASC     EQU     ']'     ;{ SQUARE BRACKET CLOSE }
ADOT    EQU     '.'     ;{ PERIOD}
ALF      EQU     0AH     ;{ LINE FEED, USED INTERNALLY AS}
                        ;{ LINE ENDER}
AFF      EQU     0CH     ;{ FORM FEED}
BELL    EQU     07H     ;{ ^G}
BSIN    EQU     08H     ;{ INPUT DELETE CHARACTER}
BSOUT   EQU     08H     ;{ OUTPUT BACKSPACE ( ^H )}
;
;{      HEADER RELATED EQUATES}
B_DUMMY   EQU     01H     ;{ dea is dummy, from vocabulary link}
B_INVIS   EQU     02H     ;{ dea is invisible, "smudged".}
B_IMMED   EQU     04H     ;{ dea is a immediate.}
B_DENOT   EQU     08H     ;{ dea is a denotation.}
C_HOFFSET EQU     0       ;{ Offsets of code field in cells, w.r.t. dea}
D_HOFFSET EQU     1       ;{ Same for data field}
F_HOFFSET EQU     2       ;{ Same for flag field}
L_HOFFSET EQU     3       ;{ Same for link field}
N_HOFFSET EQU     4       ;{ Same for name field}
_SOURCEFIELD_({S_HOFFSET EQU     5       ;{ Same for source field}}, {dnl})
PH_OFFSET EQU     M4_HS   ;{ Past header field: Start of data area. }
BD_OFFSET EQU     M4_HS+1 ;{ Start of BODY for CREATEd word.}
;
_EQULAYOUT_({
_HIGH_BUF_({
BUF1    EQU     EM-(KBBUF+2*M4_CELLWIDTH)*NBUF      ;{ FIRST DISK BUFFER}
STRUSA  EQU     BUF1-US         ;{ User area}
});_END_({ _HIGH_BUF_})
_LOW_BUF_({
STRUSA  EQU     EM-US         ;{ User area at end }
});_END_({ _LOW_BUF_})

STRTIB  EQU     STRUSA-RTS      ;{ Start return stack area}
                                ;{ Under this : data stack}
INITR0  EQU     STRUSA         ;{ Grows down}
INITS0  EQU     STRTIB          ;{ Growns down}
});_END_({ _EQULAYOUT_})

_CLASSIC_({
DRIVE   EQU     0       ;{ Use floppy A for blocks.}
});_END_({_CLASSIC_})

_USEBIOS_({
DRIVE   EQU     0       ;{ Use floppy A for blocks.}
_COMMENT
DRIVE   EQU     80H     ;{ Use drive C for blocks.}
_ENDCOMMENT
});_END_({_USEBIOS_})

BPS     EQU     512             ;{Bytes/sector, common to all of MSDOS}
SPB     EQU     KBBUF/BPS
;
_RWLBA_({
;{ PHYSICAL DISK PARAMETERS}
;{Most of this makes no sense but it is required in a bootsector,}
NFAT    EQU     0     ;{ Number of FATS}
SECROOT EQU     0H   ;{ Sectors for root directory entry.}
MEDIA   EQU    0F8H      ;{ Descriptor byte. Anachronism.}
SECFAT  EQU     0       ;{ Sectors per FAT}
SPT     EQU     0     ;{Sectors/track}
HEADS   EQU     0     ;{Number of heads }
TRKS    EQU     0    ;{Number of tracks}
SPDRV   EQU     HEADS*TRKS*SPT    ;{ sectors/drive}
});_END_({_RWLBA_})

_RWSECTRK_({
;{ PHYSICAL DISK PARAMETERS}
;
;{ Disk parameters: }
;{ HD drive 3" }
TRKS    EQU     80    ;{Number of tracks}
SPT     EQU     18    ;{Sectors/track}
HEADS   EQU     2     ;{Number of heads }
NFAT    EQU     2     ;{ Number of FATS}
SECROOT EQU     0EH   ;{ Sectors for root directory entry.}
SECFAT  EQU     9     ;{ Sectors per FAT}
MEDIA   EQU    0F0H   ;{ Descriptor byte. Used for selecting between A: and C:.}

_COMMENT
;{ HD drive 5" }
TRKS    EQU     80      ;{Number of tracks}
SPT     EQU     15      ;{Sectors/track}
HEADS   EQU     2       ;{Number of heads }
NFAT    EQU     2       ;{ Number of FATS}
SECROOT EQU     ?       ;{ Sectors for root directory entry.}
SECFAT  EQU     7       ;{ Sectors per FAT}
MEDIA   EQU    0F0H     ;{ Descriptor byte. Used for selecting between A: and C:.}
_ENDCOMMENT

_COMMENT
;{ Hard drive }
;{This works supposedly with all reasonably modern drives. }
TRKS    EQU     1       ;{Number of tracks, dummy}
SPT     EQU     63      ;{Sectors/track}
HEADS   EQU     255     ;{Number of heads }
NFAT    EQU     2       ;{ Number of FATS}
SECROOT EQU     0       ;{ Sectors for root directory entry, dummy.}
SECFAT  EQU     0       ;{ Sectors per FAT, dummy}
MEDIA   EQU    0F8H     ;{ Descriptor byte. Used for selecting between A: and C:.}
_ENDCOMMENT

;{ Bios specific equates.}
BOOTADDRESS     EQU     M4_BIOSBOOT ;{ PC jumps to 0:7C00 to boot}
        ;{ Skip boot sector,fats and root dir and first sector of file.}
_RESPECTDOS_({
SECSTRT EQU     1+NFAT*SECFAT + SECROOT + 1
});_END_({_RESPECTDOS_})
_NO_RESPECTDOS_({
;{ The disk need not be recognized by MSDOS}
;{ Usable for generating a bootable floppy simple.}
;{ Always used for hard disk.}
SECSTRT EQU     1
});_END_({_NO_RESPECTDOS_})
;{ END  OF PHYSICAL DISK PARAMETERS}
});_END_({_RWSECTRK_})
_BOOTLBA_({
;{ The first gigabyte of the disk is divided chunks, }
;{ the size of the core memory to alternately boot from, as a backup.}
CHUNKSIZE       EQU     80H * 100000H ;{ 128 Mb. }
;{Size in sectors. }
MAXCHUNK        EQU    1024 *100000H /CHUNKSIZE
});_END_({_BOOTLBA_})

_HOSTED_DPMI_({
;{DPMI segment defines.}
;{We can't aim for better than level privilege level 3.}
IDENTIFY_TOGGLE EQU 040H   ;{ The Big and Granularity bits are complemented}
                            ;{ on switching to 32 bits mode in 6th byte.}
});_END_({_HOSTED_DPMI_})
_SWITCH_({
;{ Segments   @ Valid in real mode % Valid in protected mode }
;{ Names starting in A_ are linear, physical (32 bit), absolute addresses }
RSTSIZE     EQU     10000H  ;{ For real mode stack. }
GDTSIZE         EQU     8000H   ;{ For GDT-table.}
IDTSIZE         EQU     0800H   ;{ For IDT-table. Not yet used. }
A_FORTH0     EQU     M4_LOADADDRESS - M4_ORG ; { Physical address of Forth's CS:0 = SS:0 = ES:0 . }

A_SWITCH        EQU     M4_SWITCHORG
A_RST       EQU     A_SWITCH + 10000H
A_GDT             EQU     A_RST + RSTSIZE
A_IDT             EQU     A_GDT + GDTSIZE  ; { reserved but not yet used. }
;A_LOWDP         EQU     A_IDT + IDTSIZE ; { Must become this. }
 A_LOWDP         EQU     A_GDT + IDTSIZE

;{ @ Real mode place for the stack.}
;{ This is such that after switching to real mode an isolated }
;{ Stack is available }
SS_RST      EQU     A_RST/10H ;
SWITCHSEGMENT     EQU     A_SWITCH/10H ;{ @ DS and CS for real code }
; {Add this to go from GDT_CS addresses to GDT_SWITCH addresses.}
M4_SWITCHOFFSET EQU  ( A_FORTH0 - M4_SWITCHORG)

;{ The GDT_.. are offsets in the GDT table. They can be arbitrarily choosen }
;{ as far as the GDT goes as long as they are a multiple of 08H }
;{ Switching sometimes restricts these to a particular value.}
GDT_SWITCH       EQU    SWITCHSEGMENT  ;{ % Switching segment, must be same for switching to work! }
GDT_CS EQU 10H  ;{ % The protected mode code segment }
GDT_SS16 EQU 10H  ;{ % To access the real mode stack segment from protected. }
; { In fact we set the DS immediately after switching.}
GDT_SS         EQU     SS_RST ;{ % The protected mode data segment}
GDT_DS         EQU     SS_RST ;{ % The protected mode data segment}
GDT_SEGMENT    EQU     A_GDT/10H       ;{ @ General descriptor table.}

IDENTIFY_16 EQU 008FH   ;{ Identification of 16 bit data/code segment, byte 6}
IDENTIFY_32 EQU 00CFH   ;{ Identification of 32 bit data/code segment, byte 6}
IDENTIFY_INT EQU 8E00H  ;{ Identification of an interrupt descriptor, byte 5}
IDENTIFY_XR  EQU 9A00H  ;{ Identification of a code segment, execute read, byte 5}
IDENTIFY_RW  EQU 9200H  ;{ Identification of a data segment, read write, byte 5}

GDTLEN EQU GDTSIZE-1      ; {Intel peculiarity.}
BOOTOFFSET EQU 0
});_END_({ _SWITCH_})

_HOSTED_LINUX_({
include(constant.m4)
RAWIO           EQU     (ECHO _OR_ ICANON)
        global  _start        ; Entry point. dnl
_LINUX_C_({Called from c. Remainder c-routines to be called from here.})
        extern  c_type,c_expec,c_key,c_qterm
        extern  c_rslw, c_block_exit, c_block_init, c_debug
        global  ciforth
});_END_({ _HOSTED_LINUX_})

_HOSTED_LINUX_({
        section forth progbits write exec alloc
        PAGE
});_END_({ _HOSTED_LINUX_})

; ########################################################################################
;                      BOOTCODE    (optional, always real mode)
; ########################################################################################

; {All bootcode must be relocatable and its memory references absolute.}
; {Not for the sake of booting, but to allow MSDOS to start the program too. }

        CSEG    SEGMENT PARA PUBLIC 'CODE'
        ASSUME CS:CSEG,DS:CSEG,SS:CSEG,ES:CSEG
    _ABSOLUTELOAD_({ ORG     M4_ORG})
    _BOOTED_(_REAL_({ORG     100H
ORIG:                         ; {Accommodate also .exe files} }))
ORG0:

_BOOTSECTRK_({
        JMP     SHORT BOOT
        NOP
        ;{ MSDOS programmers reference (thru 6, 3.9)}
        DB    "DFW--EXP"
LBPS    DW         BPS
        DB         1
RESSECTORS  DW     01H
        DB         NFAT
        DW BPS*SECROOT/32
        DW         HEADS*TRKS*SPT    ;{ sectors/drive}
LMEDIA  DB         MEDIA
        DB         SECFAT, 0H
LSPT    DW         SPT
LHEADS  DW       HEADS
HIDDENSECS    DD        0H
HUGESECS      DD         000H
      ;{ BIOS parameter block ends here}
        DB 000H, 000H, 029H                  ;{ Required magic.}
        DB         004H, 01CH, 040H,  00BH
        DB    "           "
        DB    "FAT12   "

;{       Read the sector with number in CX (Counting from 0) to ES:BX.}
;{       Keep BX, CX  }
READSECTOR:
        PUSH    CX
        PUSH    BX
        MOV     AX,CX
        MOV     CL,[LSPT]
        DIV     CL
        MOV     CL,AH
        INC     CL      ;{ Sectors counting from 1!}
        XOR     AH,AH   ; {Rid of remainder}
        MOV     CH,[LHEADS]
        DIV     CH
        MOV     DH,AH   ;{ Head number}
        MOV     CH,AL   ;{ Only small disks <256 cylinders}
;       MOV     DL,DRIVE                                            *
        MOV     AX,0201H   ;{ Read absolute one sector}
        INT(13H)                 ;{BIOS disk access.}
        POP     BX
        POP     CX
        RET

RETRY:
        CALL    DISPLAYW
        XOR     AX,AX   ;{ Reset}
;       MOV     DL,DRIVE
        INT(13H)                 ;{BIOS disk access.}
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
        MOV     AX,CX
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
BOOT:
        MOV     AL, [LMEDIA]
        CMP     AL, 0F8H        ; {Fixed disk.}
        JZ     ENDIF1A
        MOV     DL, 0H          ; {Floppy.}
ENDIF1A:

        MOV     AL,'D'
        CALL    DISPLAY
        MOV AX,CS
        AND AX,AX       ;{ Z = BOOTING ?}
        JZ   ENDIF1B
        JMP  NOBOOT
ENDIF1B:
        MOV     AL,'F'
        CALL    DISPLAY
        MOV     AH,00   ;{ Reset}
;       MOV     DL,DRIVE
        INT(13H)                 ;{BIOS disk access.}
        JB      RETRY

        ;{ The first file copied to a freshly formatted floppy will}
        ;{ be at SECSTRT (See also genboot.bat)}
        MOV     CX,SECSTRT      ; {Counting from zero}
        MOV     AX,BOOTADDRESS/10H ; {Bootsegment}
        MOV     ES,AX
        MOV     BX,BPS
BEGIN1: CALL    READSECTOR
        INC     CX
        ADD     BX,BPS
        JB      RETRY
        CMP     BX,RELATIVE_WRT_ORIG(TEXTEND)
        JB      BEGIN1

        MOV     AL,'{W}'
        CALL    DISPLAY
        CALL    DISPLAYCR

        MOV     AL, [LHEADS]     ;{Copy from boot sector to Forth.}
        MOV     [LFHEADS],AL
        MOV     AL, [LSPT]
        MOV     [LFSPT],AL,
        MOV     AL, [LMEDIA]
        MOV     [LFDRIVE], DL

        JMP     ENDBOOT
});_END_({ _BOOTSECTRK_})

_BOOTLBA_({
        JMP     SHORT BOOT
        NOP
        ;{ MSDOS programmers reference (thru 6, 3.9)}
        DB    "DFW---HD"
LBPS    DW         BPS
        DB         1
RESSECTORS  DW     01H
        DB         NFAT
        DW BPS*SECROOT/32
        DW         SPDRV
        DB         MEDIA
        DB         SECFAT, 0H
        DW         SPT
        DW       HEADS
HIDDENSECS    DD        0H
HUGESECS      DD         000H
      ;{ BIOS parameter block ends here}
        DB 000H, 000H, 029H                  ;{ Required magic.}
        DB         004H, 01CH, 040H,  00BH
        DB    "           "
        DB    "RAW     "

BOOTLBA:  DB      10H, 0
;{ Rounds down, we already have 1 sec. For HD always load 64K.}
;{ Bootstrap for ci has to reside in this first part.}
        DW      0FFFFH/BPS
        DW      BPS             ;{ OFFSET AND SEGMENT}
        DW      SWITCHSEGMENT
STARTSECTOR: ;{ HD Start sector, do be choosen by key press.}
        DD      1       ;{ Start}
        DD      0       ;{ M.S. 32 BITS}

HDREAD:
        MOV     AX,SWITCHSEGMENT
        MOV     DS,AX
        MOV     SI,RELATIVE_WRT_ORIG(BOOTLBA) ; {DS:SI absolute address of lba.}
        MOV     AX,4200H  ;{   Read extended                                }
        MOV     DX,0080H  ;{   Disk C                                 }
        INT     13H
        RET
RETRY:
        CALL    DISPLAYW
        MOV     AL,' '
        MOV     AH,00   ;{ Reset}
        MOV     DL,80            ;{Drive 80 (hd C:)}
        INT(13H)                 ;{BIOS disk read function}
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
        MOV     AX,CX
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
BOOT:
        MOV     AL,'D'
        CALL    DISPLAY
        MOV AX,CS
        AND AX,AX       ;{ Z = BOOTING ?}
        JNZ  NOBOOT
        MOV     AL,'F'
        CALL    DISPLAY
        MOV     AH,00   ;{ Reset}
        MOV     DL,80            ;{Drive 80 (hd C:)}
        INT(13H)                 ;{BIOS disk read function}
        JB      RETRY
        CALL    GETKEY
        JNB     ENDIF
        PUSH    AX
        CALL    DISPLAY
        POP    AX
        SUB     AL, '0'
        JB     ENDIF
        CMP     AL, MAXCHUNK
        JNB     ENDIF
        AND     EAX, 0FFH
        MOV     ECX, CHUNKSIZE/BPS
        MUL     ECX
        INC     EAX
        MOV     [STARTSECTOR],EAX
ENDIF:  CALL    HDREAD
        JB      RETRY
        MOV     AL,'{W}'
        CALL    DISPLAY
        CALL    DISPLAYCR
        JMP     ENDBOOT

});_END_({ _BOOTLBA_})
_BOOTED_({
; Debug code, could be dispensed with in an ideal world.
DISPLAYCR:
        MOV     AL,ACR
        CALL    DISPLAY
        MOV     AL,ALF
        JMP DISPLAY

DISPLAYPC:      POP     AX
        PUSH    AX
DISPLAYW:       PUSH    AX              ;{ Display AX in hex }
        MOV     AL,AH
        CALL    DISPLAYHEX
        POP     AX
        ;{ CALL DISPLAYHEX ; RET}
DISPLAYHEX:     PUSH    AX              ;{ Display AL in hex }
        MOV     CL,4
        SAR     AL,CL
        CALL    DISPLAYHD
        POP     AX
        ;{ CALL DISPLAYHD ; RET}
DISPLAYHD:      AND     AL,0FH          ;{ Display AL as one hex digit}
        DAA
        MOV     AH,AL
        MOV     CL,5
        SHR     AH,CL
        ADC     AL,30H
        ;{ CALL DISPLAY ; RET}
DISPLAY:XOR     BH,BH           ;{ Display AL as an ASCII char}
        MOV     AH,0EH
        INT(10H)
        RET
GETKEY: MOV     AH, 01H       ;{ If CARRY, a key sits in AL. }
        INT(16H)
        JNB     ENDIF1
        MOV     AH, 00H       ;{ Consume the key. }
        INT(16H)
ENDIF1:  RET
});_END_({ _BOOTED_})
NOBOOT:         ; {Skip till here if not booting.}

_ABSOLUTELOAD_({
;{ Apparently we may have to move the code, e.g. if started from MSDOS.}
;{ Prepare return to MSDOS using the original code segment.}
        MOV     AX,CS
        MOV     DS,AX
        CALL    HERE1
HERE1:  POP     BX
        MOV     CX,BX
        ADD     BX,RETDOSV-HERE1+1        ;{ Independant of load address.}
        ADD     CX,RETDOS-HERE1
        MOV     [BX],CX
        INC     BX
        INC     BX
        MOV     [BX],AX
        JMP ENDBOOT     ;

;{ Returns to DOS, provided we started from dos as a .COM.}
;{ Use far jump restoring CS to .COM value. }
RETDOS:
        MOV     AX,CS
        MOV     DS,AX
        MOV     ES,AX
        MOV     SS,AX
        MOV     AH,4CH
        INT     21H    ;{ Only works if cs is the same as while starting.}

});_END_({ _ABSOLUTELOAD_})
ENDBOOT:

; ########################################################################################
;                       ADJUST CODE SEGMENT REGISTER (still real mode)
; ########################################################################################
;{ Required start of .COM program.}
    _HOSTED_MSDOS_(_REAL_({ORG     100H
ORIG:                         ; {Accommodate also .exe files} }))

; ########################################################################################
;                       MOVE CODE TO ITS PLACE (still real mode)
; ########################################################################################
_ABSOLUTELOAD_({
; {  Take care of the situation where booting code is actually started up by  }
; {  MSDOS. This is no problem as long as the code is moved to where it would }
; {  be if booted. If the code is at its place, nothing really happens here.  }
; {  Furthermore all protected code started by MSDOS must be at an absolute address.}
        STD     ; Start at the end going back.
        MOV     CX,TEXTEND-HERE5 ; Amount to move
        CALL  HERE6
HERE6:  POP     AX                 ; { Calculate address of the first byte to move}
        ADD     AX,TEXTEND-HERE6-1
        MOV     SI,AX           ; {Relocatable address, w.r.t code segment.}
        MOV     AX,CS
        MOV     DS,AX
        MOV     AX, A_FORTH0/10H ; Destination segment
        MOV     ES, AX
        MOV     DI, TEXTEND-1
        REPNZ
        MOVSB
        PUSH    ES    ; {Corrected code segment}
        MOV BX, HERE5
        PUSH BX     ; {Correct program counter}
        RETF        ; {Returning to here5 now}
HERE5:
        MOV     AX,CS
        MOV     DS,AX
        MOV     ES,AX
        MOV     SS,AX
        CLD     ; {Reset direction to going up.}

});_END_({_ABSOLUTELOAD_})
; ########################################################################################
;                       FILL GDT AND SWITCH TO PROTECTED MODE/32 BITS (optional)
; ########################################################################################
_SWITCH_({
        JMP    PROTECT
GDTLOAD DW     GDTLEN
        DD     A_GDT
PROTECT:
;{Prepare. Remember STOSW uses ES:DI                              }
        MOV     AX,GDT_SEGMENT ;{ GDT segment}
        MOV     ES,AX
        MOV     DI,0
        MOV     AX,GDTLEN
        STOSW
;{ The switch segment.         }
;{ Switch between real and (16-bit) protected mode is done,}
;{ while using this segment (Relocatable code only).}
;{ GDT_SWITCH can to an extent be choosen arbitraryly,}
;{ as long as here we ensure that the real mode address  }
;{ is equal to the protected mode address. }
;{ You can only switch while staying at the same physical address}
;{ when you are currently executing in the range GDT_SWITCH:[0:FFFFH] }
        MOV     BX,GDT_SWITCH
        MOV     DI,BX
        MOV     AX,0FFFFH
        STOSW
        SHL     BX,4     ; { Turn segment register into IP}
        MOV     AX,BX
        STOSW
        MOV     AX,IDENTIFY_XR
        STOSW
        MOV     AX,IDENTIFY_16
        STOSW
_COMMENT
;{ The protected mode view of the real stack segment. }
;{ GDT_SS16 is arbitrary.}
        MOV     BX,GDT_SS16
        MOV     DI,BX
        MOV     AX,0FFFFH
        STOSW
        MOV     EAX,A_RST
        STOSW           ; {Only 16 bits}
        SHR     EAX,8
        ADD     AX,IDENTIFY_RW
        STOSW
        MOV     AX,IDENTIFY_16
        STOSW
_ENDCOMMENT
;{ GDT_DS/GDT_SS to an extent be choosen arbitraryly,}
;{ The real mode view of GDT_SS is valid, isolated and reserved for real stack.}
;{ DS is reset after switching anyway.}
;{ Accomodate a 24 bit start address, a maximal limit, large pages. }
        MOV     DI,GDT_SS ;{Identical to GDT_DS}
        MOV     AX,0FFFFH
        STOSW
        MOV     EAX,A_FORTH0
        STOSW           ; {Only 16 bits}
        SHR     EAX,8
        ADD     AX,IDENTIFY_RW
        STOSW
        MOV     AX,IDENTIFY_PROT
        STOSW
;{ PREPARE-CS 16/32 BITS                                                   }
        MOV     DI,GDT_CS
        MOV     AX,0FFFFH
        STOSW
        MOV     EAX,A_FORTH0
        STOSW           ; {Only 16 bits}
        SHR     EAX,8
        ADD     AX,IDENTIFY_XR
        STOSW
        MOV     AX,IDENTIFY_PROT
        STOSW

        LGDT    [GDTLOAD]
});_END_({ _SWITCH_})

_HOSTED_MSDOS_({
        PUSH    DS
        MOV     AX,0
        MOV     DS,AX
        LEA     AX,[WRM]
        LEA     BX,[4*23H]
        MOV     [BX],AX         ;{Jump to WRM on <CTRL-BREAK>}
        INC     BX
        INC     BX
        MOV     AX,CS
        MOV     _CELL_PTR[BX], AX
        POP     DS
ENDREADJUST:
});_END_({ _HOSTED_MSDOS_})
_BOOTED_({
        JMP     ENDREADJUST
        _NEW_ORG(01FEH)
        ;{ Signature. Last piece of boot sector. }
        DB         055H, 0AAH
ENDREADJUST:
});_END_({ _BOOTED_})

_SWITCH_({
;{ Remember: we are now in the real mode for a protected model.}
;{ Make sure we are in the switch segment, such that we can switch.}
        MOV   BX,CS      ;{ Reality.}
        MOV AX, GDT_SWITCH ;{ Dream.}
        PUSH AX     ; {Correct code segment}
        SUB AX,BX      ;{ Discrepancy between dream and reality}
        MOV CX,10h     ;{ How much units would that be for the IP?}
        CWD
        MUL CX
        CALL  HERE3
HERE3:  POP   BX         ;{ Reality.}
        SUB BX,AX    ;
        ADD BX,THERE4-HERE3
        PUSH BX     ; {Corrected program counter}
        RETF        ; {Returning to THERE4 now}

_BITS16_({THERE4:})

_BITS32_({
;{ 32 bit protected mode is no good unless the A20 address line works.}
;{ The following tedious code is copied from the nuni startup code}
;{ for linux. }
KB_WAIT:
        IN AL,64H
        AND AL,2
        JNZ KB_WAIT
        RET
THERE4:
        CALL KB_WAIT
        MOV AL,0D1H
        OUT 064H,AL            ;{ Enable a20}
        CALL KB_WAIT
        MOV AL,0DFH
        OUT 060H,AL
});_END_({ _BITS32_})
});_END_({ _SWITCH_})
; ########################################################################################
;                       PREPARE FOR USING DPMI (OPTIONAL)
; ########################################################################################
_HOSTED_DPMI_({

; Required start of .COM program.
    ORG     100H
ORIG:                         ; Accommodate also .exe files
            MOV     BX,4000H            ;BX=paragraphs needed (64K)
            MOV     AH,4Ah              ;Modify memory allocation
            INT     21h
; These are real mode descriptors !
            MOV     _CELL_PTR[SaveCS],CS           ; Once and for all
            MOV     _CELL_PTR[SaveDS],DS
            MOV     _CELL_PTR[SaveES],ES           ; Still pointing to PSP (!?)
            MOV     _CELL_PTR[SaveSS],SS
            XOR     AX,AX
            MOV     SP,AX
;
; Check to see if DPMI is available, and make the switch if it is
; If one is, the stat info is stored.
            MOV     BL,1
            MOV     AX,1687h            ;Get DPMI host address
            INT     2Fh                 ;Multiplex interrupt

            CMP     AX,0                ;Was it there?
            JNE     ERRMSG              ;Nope, so exit

            AND     BL,1                ;Test bit 1 (32-bit OK?)
            MOV     [Flag32],BL
            MOV     [ProcType],CL
            MOV     [VerNum],DX
            MOV     [MemNeeded],SI
            MOV     [DPMIentry+0],DI
            MOV     [DPMIentry+2],ES

            MOV     AX,0                ;In case no memory needed
            MOV     BX,[MemNeeded]        ;Get number of paragraphs needed by host
            CMP     BL,0                ;Any allocation needed?
            JE      Plunge              ;No, so continue
            MOV     AH,48h              ;Allocate memory
            INT     21h
            MOV     BL,2
            JC      ERRMSG              ;Could not allocate

Plunge:     MOV     ES,AX
            MOV     AX,0        ;{Always 16 bit mode, to start.}
            _CALL_FAR_INDIRECT(DPMIentry) ;Switch to protected mode
            MOV     BL,3
            JC      ERRMSG      ;still in real mode

            JMP     DPMISUCCESS
; Data used by check DPMI.

Flag32      DB      00
ProcType    DB      00
VerNum      DW      0000
MemNeeded   DW      0000
DPMIentry   DW      0000,0000
Scratch     _RESB(8)

;Error-- called from diverse places.
           MOV     AL, BL ; {Use the infamous errorlevel.}
ERRMSG:
           MOV     AH,4CH
           INT     21H
; The error number is patched!
EMsg       DB      'ciforth DPMI : ERROR #',ACR,ALF
EMsgS      EQU     $-EMsg


; If we reach this point, we are operating in protected mode
DPMISUCCESS:
; -------------- Alias descriptors for CS and DS --------
            MOV     AX,000AH            ;{Alias for LDT descriptor.}
            MOV     BX,CS
            INT     31H
            MOV     BL,4
            MOV     CX,AX
            JC      ERRMSG             ;{Could not allocate.}

            MOV     AX,000AH            ;{Alias for LDT descriptor.}
            MOV     BX,CS
            INT     31H
            MOV     BL,5
            MOV     DX,AX
ERRMSG2:    JC      ERRMSG             ;{Could not allocate.}

; -------------- Adapt the segments to 32 bits --------
; Throughout this section : CX is an alias for CS , DX for DS.

            LEA     DI,[Scratch]
            MOV     AX,000BH            ;{Get Description.}
            MOV     BX,CX
            INT     31H
            MOV     BL,6
            JC      ERRMSG2
            MOV     AL,[DI+6]
_BITS32_({  XOR     AL, IDENTIFY_TOGGLE },{dnl})
            MOV     AL,0FAH
            MOV     [DI+5],AL
            MOV     [DI+6],AL
            MOV     AX,000CH            ;{Set Description.}
            MOV     BX,CX
            INT     31H
            MOV     BL,7
            JC      ERRMSG2

            MOV     AX,000BH            ;{Get Description.}
            MOV     BX,DX
            INT     31H
            MOV     BL,8
            JC      ERRMSG2
            MOV     AL,[DI+6]
_BITS32_({  XOR     AL, IDENTIFY_TOGGLE },{dnl})
            MOV     [DI+6],AL
            MOV     AX,000CH            ;{Set Description.}
            MOV     BX,DX
            INT     31H
            MOV     BL,9
            JC      ERRMSG2

; -------------- Use the alias descriptors for CS and DS --------
            MOV     ES,CX       ;{CX -> ES -> CS}.
            ES
            JMP     SWITCHSEG
SWITCHSEG:
            MOV     DS,DX
            MOV     ES,DX
            MOV     SS,DX
; ######################### DPMI END ###############################################################

});_END_({_HOSTED_DPMI_})
_BITS32_({
;{************************}
include(width32.m4)
;{************************}}
,{dnl})
_SWITCH_({
        CLI     ;{ Wait for stacks to be setup.}
        JMPHERE_FROM_REAL
        MOV     AX,GDT_SS
        MOV     SS,AX
REP1:
_BITS32_({
        INC AX                  ;{ Wait until a20 works(!)}
        MOV [TESTVALUE],AX
        CMP AX,[100000H + TESTVALUE] ; { 2^20 beyond}
        JE REP1
        JMP PASTTEST
TESTVALUE: DD   0
PASTTEST:
});_END_({ _BITS32_})
});_END_({ _SWITCH_})

; ########################################################################################
;                       FORTH GLUE CODE (optional, except for the jump)
; ########################################################################################

_LINUX_C_({
SAVE_LINUX:     DD      0,0,0,0,0 ; SP, BP, SI, DI, BX
RETURN_LINUX:
        MOV     ESP,_CELL_PTR[SAVE_LINUX+_CELLS(0)]
        MOV     EBP,_CELL_PTR[SAVE_LINUX+_CELLS(1)]
        MOV     ESI,_CELL_PTR[SAVE_LINUX+_CELLS(2)]
        MOV     EDI,_CELL_PTR[SAVE_LINUX+_CELLS(3)]
        MOV     EBX,_CELL_PTR[SAVE_LINUX+_CELLS(4)]
        RET     ; Assuming the old stack has not been disturbed.It shouldn't.
ciforth:
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(0)],ESP
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(1)],EBP
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(2)],ESI
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(3)],EDI
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(4)],EBX
        LEA     ECX,[ESP+_CELLS(1)]
        XOR     EAX,EAX
        CMP     EAX,_CELL_PTR[ECX]
        JZ     ENDIF1
        JMP     WRM         ; Warm start
ENDIF1:

});_END_({_LINUX_C_})

_LINUX_N_({
ciforth:
_start:
});_END_({_LINUX_N_})

        CLD                     ;{ DIR = INC}
        _LINUX_N_({MOV     _CELL_PTR[USINI+_CELLS(31)],SPO}) ;{Remember ARGS.}
        MOV     SPO,_CELL_PTR[USINI+_CELLS(2)]    ;{PARAM. STACK}
        MOV     RPO,_CELL_PTR[USINI+_CELLS(3)]    ;{RETURN STACK}
        MOV     HIP,_OFFSET CLD1  ;{ (IP) <-}
        _NEXT
;
CLD1:   DC      COLD    ; { This is a piece of headerless high level code.}
;
; ########################################################################################
;                       FORTH ITSELF (entry point : BOOTUP)
; ########################################################################################
;
_COMMENT
   FORTH REGISTERS
   The names under FORTH are used in the generic source.

   FORTH   8088     FORTH PRESERVATION RULES
   -----   ----     ----- ------------ -----
dnl Note how the following is to pass through m4
   {HIP}   HIP      High level Interpreter Pointer.  Must be preserved
                    across FORTH words.

   {WOR}   WOR      Working register.  When entering a word
                    via its code field the DEA is passed in {WOR}.

   {SPO}   SPO      Parameter stack pointer.  Must be preserved
                    across FORTH words.

   {RPO}   RPO      Return stack pointer.  Must be preserved across
                    FORTH words.

            AX      General register.  Used to pass data from
                    FORTH words, see label APUSH or macro {_APUSH}

            DX      General register.  Used to pass more data from
                    FORTH words, see label DPUSH or macro {_DPUSH}

            BX      General purpose register.

            CX      General purpose register.

            CS      Segment register. Must be preserved
                    across FORTH words.

            DS      ditto

            SS      ibid

            ES      Temporary segment register only used by
                    a few words. However it MUST remain equal to
                    DS, such that string primitives can be used
                    with impunity.

----------------------------------------------------------
_ENDCOMMENT
        PAGE
_COMMENT
---------------------------------------------

   COMMENT CONVENTIONS
   ------- -----------

   =       IS EQUAL TO
   <-      ASSIGNMENT

  NAME        =  Address of name
  (NAME)      =  Contents of name

  CFA         =  CODE FIELD: a pointer to executable code
  DFA         =  PARAMETER FIELD: a pointer into
  FFA         =  FLAG FIELD: contains flags
  LFA         =  LINK FIELD: a pointer
  NFA         =  NAME FIELD: a pointer to a variable number of chars
  PHA         =  POST {HEADER} ADDRESS

  S1          =  Parameter stack - 1st cell
  S2          =  Parameter stack - 2nd cell
  R1          =  Return stack    - 1st cell
  R2          =  Return stack    - 2nd cell

  LSB         =  Least significant bit
  MSB         =  Most  significant bit
  LB          =  Low byte
  HB          =  High byte
  LW          =  Low  cell

------------------------------------------------------------
_ENDCOMMENT
_OLDDEBUG_({
        PAGE
_COMMENT
             DEBUG SUPPORT

THIS ROUTINE WILL ALLOW YOU TO STEP THRU FORTH PROGRAMS
EVERY TIME 'NEXT' IS EXECUTED.

IN ORDER TO USE THE STEP FEATURE YOU MUST DO THE FOLLOWING:

        1.  PATCH THE INSTRUCTION IN 'NEXT' WITH A JUMP
            TO 'TNEXT'

        2.  PATCH YOUR BREAKPOINT ROUTINE AT
            LABEL   'BREAK'

        3.  SET VARIABLES, `BIP' & `BIPE' TO THE
            ADDRESSES YOU WANT TO STEP THRU.

THE CONTENTS OF THE 2 VARIABLES 'BIP` AND `BIPE'
ARE INTERPRETED AS FOLLOWS:

BIP     BIPE    DEBUG-CONDITION
---     ----    ---------------

  0        X    OFF
 -1        X    TRACE ALL `NEXT' CALLS
ADDR1      0    TRACE `ADDR1' ONLY
ADDR1  ADDR2    TRACE `ADDR1' TO `ADDR1'

NOTE:   THE ABOVE ADDRESSES CAN'T POINT TO A
        `CODE FIELD ADDRESS'.
        X = DON'T CARE

-----------------------------------------------------
_ENDCOMMENT

BIP     DC      0       ;{ BREAKPOINT START ADDRESS}
BIPE    DC      0       ;{ BREAKPOINT END ADDR}
        PAGE
;{      THIS IS THE `NEXT' WITH DEBUG SUPPORT}

TNEXT:  PUSHF           ;{SAVE REGISTER}
        PUSH    AX
        MOV     AX,[BIP]  ;{ BREAKPOINT START ADDR}
        OR      AX,AX   ;{ ZERO?}
        JZ      TNEXT2  ;{ NO BREAKPOINT}
        CMP     AX,-1
        JZ      TNEXT1  ;{ STEP ALL POINTS}
        CMP     AX,HIP   ;{ IN BREAKPOINT RANGE?}
        JZ      TNEXT1  ;{ STEP THIS LOCATION}
        JA      TNEXT2  ;{ NO}
        MOV     AX,[BIPE] ;{ BREAKPOINT END ADDR}
        OR      AX,AX   ;{ ZERO?}
        JZ      TNEXT2  ;{ ONLY 1 LOCATION}
        CMP     AX,HIP   ;{ IN RANGE STILL?}
        JB      TNEXT2  ;{ NO}

;{      PAUSE ON ADDRESS}
;
TNEXT1: POPF
;
;{********  ADD YOUR BREAKPOINT HERE  **********}
;
BREAK:  JMP     SHORT   TNEXT3  ;{CONT WITH PROGRAM}
;
;{      NO BREAKPOINT PAUSE - RESTORE REGISTERS}
;
TNEXT2: POP     AX
        POPF
TNEXT3: LODSW           ;{ AX <- (IP)}
        MOV     WOR,AX
        JMP     SHORT   NEXT1
});_END_({_OLDDEBUG_ })
        PAGE
_PC_({
_NEWDEBUG_({
DISPLAYSI:
        _SWITCH_({JMPHERE_FROM_FORTH})
        PUSH    HIP
        PUSH    RPO
        PUSH    WOR
        MOV     AX,WOR
        CALL    DISPLAYW
        MOV     AX,' '
        CALL    DISPLAY
        MOV     AX,HIP
        CALL    DISPLAYW
        CALL    DISPLAYCR
;        MOV     AH,10H
;        INT     16H
        POP    WOR
        POP    RPO
        POP    HIP
        _SWITCH_({JMPHERE_FROM_OS})
        RET
;
});_END_({_NEWDEBUG_ })
});_END_({_PC_ })
;
_OLDDEBUG_({ _COMMENT
    Patch the code from NEXT:  ( using a debugger ) with a
    `JMP TNEXT' for tracing through high level FORTH words.
_ENDCOMMENT });_END_({_OLDDEBUG_ })
;{ In 32 bit versions there may be no jumps to NEXT at all }
;{ The label NEXT1 is rarely relevant (for _OLDDEBUG_) }
DPUSH:  PUSH    DX      ;{ Fall through.}
APUSH:  PUSH    AX
NEXT:
_LINUX_C_({
_NEWDEBUG_({
         PUSH    HIP
         CALL    c_debug
         POP     HIP
});_END_({_NEWDEBUG_ })
});_END_({_LINUX_C_})
        LODSW           ;{AX <- (IP)}
NEXT1:  MOV     WOR,AX   ;{ (WOR) <- (IP)}
_PC_({_NEWDEBUG_({ CALL    DISPLAYSI})})
        JMP     _CELL_PTR[WOR]    ;{ TO `CFA'}
;
;{       Dictionary starts here.}

DP0:
; Vocabularies all end in a link to 0.
; Only the word FORTH links to the DENOTATION wordlist,
; that in turn links to 0.

define({_LINKOLD},0)dnl
worddocsafe( {DICTIONARY},{'},{tick},{--- addr},{ISO,FIG,I,L0},
{Used in the form: .
forthsamp({' nnnn})
Leaves the dictionary entry address of dictionary word forthsamp({nnnn}).
This also serves as an execution token.
If the word is not found after a search of
forthcode({SEARCH-ORDER}) and forthcode({CURRENT}) , an appropriate error message is given.
This word is intended for interpret mode,  but in ciforth it works as
well in compilation mode _VERBOSE_({{, because it is considered a denotation. So
' and the word following is a unit that behaves
as a constant.}})
It is recommended that this word is not postponed. _VERBOSE_({{Use explicit
parsing and searching instead.}})},
{{FOUND},{>CFA},{>DFA},{>FFA},{>LFA},{>NFA},{>SFA},{EXECUTE}} ,
{{ : APE 1 2 ; ' APE EXECUTE  ' APE ID. . .},{APE 2 1},
{ : AAPE 1 2 ; 'AAPE EXECUTE  'AAPE ID. . .},{AAPE 2 1},
{'APEEE },{'APEEE ?  MSG # 11 : WORD IS NOT FOUND},
{CR},{}
},
enddoc)
HEADER({'},{TICK},{DOCOL}, , B_IMMED + B_DENOT)
        DC      LPWORD, LDUP, TOR
        DC      FOUND
        DC      LDUP, ZEQU
        DC      LIT, 11, QERR
        DC      LDUP, TNFA, FETCH, FETCH ; { Get precise length.}
        DC      FROMR, EQUAL, ZEQU
        DC      LIT, 11, QERR ; { to prevent match for denotation.}
        DC      LITER
        DC      SEMIS
;
worddoc( {DENOTATIONS},{DEN&},{char_follows}, {--- c},{CI},
{Leave forthvar({c}) the non blank char that follows.
Skip another blank character.},
{},
{{&H .},{48 },
{&X  .},{58 },
{: GS1 &H ; GS1 .},{48 },
{: GS2 &X ; GS2 .},{58 }}, enddoc)
HEADER({&},{DCHAR},{DOCOL}, , B_IMMED + B_DENOT)
        DC      INBRS
        DC      SWAP, DROP
        DC      LDUP, QBL
        DC      LIT, 10, QERR
        DC      LITER
        _SECURITY_({DC      QDELIM})
        DC      SEMIS
;
worddoc( {DENOTATIONS},{DEN^},{control_follows}, {--- b},{CI},
{Leave forthvar({b}) the control character value of the char that follows
_VERBOSE_({{i.e. forthsamp({^A}) results in 1 and so on}}).
Skip another blank character.},
{},
{{^C .},{3 },
{^I  .},{9 },
{: GS1 ^C ; GS1 .},{3 },
{: GS2 ^I ; GS2 .},{9 }}, enddoc)
HEADER({^},{DCTL},{DOCOL}, , B_IMMED + B_DENOT)
        DC      INBRS
        DC      SWAP, DROP
        DC      LDUP, QBL
        DC      LIT, 10, QERR
        DC      LIT, '@', LSUB
        DC      LITER
        _SECURITY_({DC      QDELIM})
        DC      SEMIS
;
worddocsafe( {DENOTATIONS},{DEN0},{den_zero}, {--- s/d},{CI},
{Implements forthcode({NUMBER}) for numbers that start with
forthkey({0}) . There are those for all decimal and hex digits.
_VERBOSE_({ ISO compatibility would demand that denotators for
all capitals are present, but one can always use a leading
zero.})
},
{},
{{048 .},{48 },
{: GS1 058 ; GS1 .},{58 }},
{{0000,0048 .},{48 },
{: GS1 0000,058 ; GS1 .},{58 }},
{{10048. D.},{10048 }},
enddoc)
HEADER({0},{DEN0},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({1},{DEN1},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({2},{DEN2},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({3},{DEN3},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({4},{DEN4},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({5},{DEN5},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({6},{DEN6},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({7},{DEN7},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({8},{DEN8},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({9},{DEN9},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({A},{DENA},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({B},{DENB},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({C},{DENC},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({D},{DEND},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({E},{DENE},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
HEADER({F},{DENF},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
;
worddoc( {DENOTATIONS},{DEN-},{den_minus}, {--- s/d},{CI},
{Implements forthcode({NUMBER}) for numbers that start with forthkey({-}) .},
{},
{{-48 .},{-48 },
{: GS1 -58 ; GS1 .},{-58 }}, enddoc)
HEADER({-},{DENM},{DOCOL}, , B_IMMED + B_DENOT)
        DC      PNUMB, DNEGA, SDLITE
        DC      SEMIS
;
worddoc({DENOTATIONS},{DEN+},{den_plus}, {--- s/d},{CI},
{Implements forthcode({NUMBER}) for numbers that start with forthkey({+}) .},
{},
{{+48 .},{48 },
{: GS1 +58 ; GS1 .},{58 }}, enddoc)
HEADER({+},{DENP},{DOCOL}, , B_IMMED + B_DENOT)
        DC      PNUMB, SDLITE
        DC      SEMIS
;
worddocsafe( {DENOTATIONS},{DEN"},{den_quote}, {--- sc},{CI},
{Leave a forthkey({"}) delimited string.},
{},
{{"APE" TYPE},{APE},
{: GS1 "NOOT" ; GS1 TYPE},{NOOT}},
enddoc)
HEADER({"},{DENQ},{DOCOL}, , B_IMMED + B_DENOT)
        DC      LIT, SKIP, COMMA        ;  'SKIP , HERE >R 0 ,
        DC      HERE, TOR, ZERO, COMMA
DENQ1:
        DC      LIT, '"', PPARS         ;           BEGIN &" (PARSE)
        DC      INBRS, LDUP, LIT, '"', EQUAL ;           IN[] DUP &" =
        _0BRANCH(DENQ2)                 ;           WHILE
        DC      TDROP, ONEP,            ;           2DROP 1+ R@ $+!
        DC      LDUP, ALLOT, RR, SPTOR
        _BRANCH(DENQ1)                  ;           REPEAT
DENQ2:
        DC      QBL, ZEQU,
        DC      LIT, 10, QERR           ;           ?BLANK 0= 5 ?ERROR
        DC      DROP,                   ;                DROP R@ $+!
        DC      LDUP, ALLOT, RR, SPTOR
_ALIGNED_({ DC LALIGN}, {dnl})
        DC      FROMR, SFET, DLITE      ;           R> $@ POSTPONE DLITERAL ;
        DC      SEMIS
;
dnl Remember the top of the denotation chain.
define({_STARTOFDENOTATIONS_},_LINKOLD)dnl
worddoc( {WORDLISTS},{FORTH},{forth},{},{ISO,FIG,I,L1},
{The name of the primary vocabulary. Execution adds
forthcode({FORTH}) to the forthcode({SEARCH-ORDER}) forthsamp({word}) list.
Until additional user word list 's are created, new user definitions
become a part of forthcode({FORTH}) . forthcode({FORTH}) is
immediate, so it will execute during the creation of a
colon-definition, to select this forthdefi({word list}) at compile time.},
{{VOCABULARY}},
{ { VOCABULARY JOHN JOHN ' FORTH >WID SEARCH-ORDER @ = .},{0},
  { FORTH ' FORTH >WID SEARCH-ORDER @ = .},{_T_} },
enddoc)
dnl Force a pointer to the denotations in FORTH 's link field.
define({_LINKOLD}, DENOTBODY )dnl
; The FORTH vocabulary is the only one not to link to zero.
; It links to the DENOTATION vocabulary.
HEADER({FORTH},{FORTH},{DODOE}, , B_IMMED)
        DC      DOVOC
        DC      0       ;{ END OF VOCABULARY LIST}
HEADER( , , ,0, B_DUMMY,_DEA(TASK))
;
dnl Reset the link chain at this to start the ENVIRONMENT wordlist.
define({_LINKOLD},0)dnl
;
worddoc({ENVIRONMENTS},{CORE},{core}, {--- f},{ISO},
{An environment query whether the CORE wordset is present.},
{{ENVIRONMENT?}},
{{"CORE" ENVIRONMENT? . .},{_T_ 0}},
enddoc)
HEADER({CORE},{CORE},{DOCOL})
        DC      ZERO    ;{ Not (fully) present.}
        DC      SEMIS
;
worddoc({ENVIRONMENTS},{CPU},{cpu}, {--- d},{CI},
{An environment query returning the cpu-type to be printed as a
base-36 number. },
{{ENVIRONMENT?}},
_BITS32_({{{"CPU" ENVIRONMENT? . 24 BASE ! D. },{_T_ 80386}},})
_REAL_({{{"CPU" ENVIRONMENT? . 24 BASE ! D. },{_T_ 8088}},})
enddoc)
HEADER({CPU},{CPU},{DOCOL})
_PROTECTED_({
       _BITS32_({DC      LIT, 0CD1856H, ZERO})      ;{ '80386'}
       _BITS16_({DC      LIT, 1856H, LIT, 0CDH})    ;{ '80386'}
});_END_({ _PROTECTED_})
_REAL_({
       DC      LIT, 0B328H, LIT, 5H      ;{ '8088'     }
})
        DC      SEMIS
;
worddoc({ENVIRONMENTS},{VERSION},{version}, {--- sc},{CI},
{An environment query giving the version of this Forth as string constant.
},
{{ENVIRONMENT?}},
dnl Expect nothing to be typed, because the testing filters out RCS stuff.
{{"VERSION" ENVIRONMENT? . CR TYPE },{_T_ }},
enddoc)
HEADER({VERSION},{VERSION},{DOCOL})
_COMMENT
;{       If this is there it is an official release}
        DC      SKIP
        DC      22
IBMPC:  DB      'IBM-PC ciforth'
        DB      FIGREL+40H,ADOT,FIGREV+30H,ADOT,USRVER+30H
        DC      LIT, IBMPC, LIT, 22
_ENDCOMMENT
;{       If this is there it is a beta release}
        _STRINGINLINE({beta $RCSfile$ $Revision$ })
        DC      SEMIS
;
worddoc({ENVIRONMENTS},{NAME},{name}, {--- sc},{CI},
{An environment query giving the name of this Forth as string constant.
},
{{ENVIRONMENT?}},
{{"NAME" ENVIRONMENT? . TYPE },{_T_ ciforth}},
enddoc)
HEADER({NAME},{NAME},{DOCOL})
        _STRINGINLINE({ciforth})
        DC      SEMIS
;
worddoc({ENVIRONMENTS},{SUPPLIER},{supplier}, {--- sc},{CI},
{An environment query giving the SUPPLIER of this Forth as string constant.
},
{{ENVIRONMENT?}},
{{"SUPPLIER" ENVIRONMENT? . TYPE },{_T_ Albert van der Horst}},
enddoc)
HEADER({SUPPLIER},{SUPPLIER},{DOCOL})
        _STRINGINLINE({Albert van der Horst})
        DC      SEMIS
;
dnl Remember the top of the environment chain.
define({_STARTOFENVIRONMENTS_},_LINKOLD)dnl
dnl Reset the link chain at this to start the FORTH wordlist.
dnl out of the normal search.
define({_LINKOLD},FORTH)dnl
;
worddoc( {WORDLISTS},{DENOTATION},{denotation},{},{CI},
{The name of the forthcode({DENOTATION}) vocabulary. The
associated forthdefi({word list}) contains prefix words, called
forthdefi({denotation}) definitions. If a word is not found in
the current search order, FORTH will lookup its prefix in this
word list _VERBOSE_({{, such as to find numbers and strings}}).
If found the parse pointer is moved back to immediately after
the prefix, and the corresponding denotation definition
executed. This word list must be used with care as a
forthcode({SEARCH-ORDER}) word list; and only as a
forthcode({CURRENT}) whenever you want to add a denotation.
_VERBOSE_({{The word forthcode({FORTH}) is hidden by the word
forthcode({F}). Use forthsample({{ONLY FORTH}}) to regain
control.}})
},
{{VOCABULARY}},
{{: AUX1 [COMPILE] DENOTATION DEFINITIONS ;},{},
{: AUX2 [COMPILE] FORTH DEFINITIONS ;},{},
{: GS1 AUX1 LATEST ID. AUX2 ; GS1},{"}},
enddoc)
HEADER({DENOTATION},{DENOT},{DODOE}, , B_IMMED)
        DC      DOVOC
        DC      _DEA(FORTH)     ;{ NEXT VOCABULARY }
DENOTBODY:
HEADER( , , ,0, B_DUMMY, _STARTOFDENOTATIONS_)
;
worddoc( {WORDLISTS},{ENVIRONMENT},{environment},{},{CI},
{The name of the forthcode({ENVIRONMENT}) vocabulary. The associated forthdefi({word list})
contains environment queries. The names of words
present in forthcode({ENVIRONMENT}) are recognized by
forthcode({ENVIRONMENT?}). This word list is not intended to
be used as a forthcode({SEARCH-ORDER}) word list; and only as a
forthcode({CURRENT}) whenever you want to add an environment
query.},
{{VOCABULARY}},
{{: GS1 [COMPILE] ENVIRONMENT DEFINITIONS LATEST ID. [COMPILE] dnl
FORTH DEFINITIONS ; GS1},{SUPPLIER}},
enddoc)
HEADER({ENVIRONMENT},{ENV},{DODOE}, , B_IMMED)
        DC      DOVOC
        DC      _DEA(DENOT)       ;{ NEXT VOCABULARY }
HEADER( , , ,0, B_DUMMY, _STARTOFENVIRONMENTS_)
;
worddoc( {MISC},{NOOP},{no_operation},{},{},
{Do nothing. Primarily useful as a placeholder.
},{},
{{NOOP},{}}, enddoc)
CODE_HEADER({NOOP},{NOOP})
       _NEXT
;
_OLDDEBUG_({ ;{ Rather unclear what this is supposed to.}
NOP0:   DC      $+_CELLS(1)
        JMP NEXT
NOP1:   DC      $+_CELLS(1)
        JMP NEXT
NOP2:   DC      $+_CELLS(1)
        JMP NEXT
});_END_({_OLDDEBUG_ })
;
worddoc( {COMPILING~},{LIT},{lit},{--- n},{FIG,C2,L0},
{Within a colon-definition, forthcode({LIT}) is compiled followed by a
_BITS_ bit literal number given during compilation.
Later execution of forthcode({LIT}) causes the contents of this
next dictionary cell to be pushed to the stack.},{{LITERAL}},
{{: TL LIT [ 123 , ] ; TL .},{123}}, enddoc)
CODE_HEADER({LIT},{LIT})
        LODSW           ;{ AX <- LITERAL}
        _PUSH          ;{ TO TOP OF STACK}
;
worddoc( {MISC},{EXECUTE},{execute},{xt -},{ISO,FIG,L0},
{Execute the definition whose forthdefi({execution token}) is
given by forthvar({xt}) . _VERBOSE_({{The
forthdefi({code field address}) serves as an execution token.
(It even has offset 0, but one should not assume that a
forthdefi({DEA}) is an execution token in portable code.)}})},
{{'},{>CFA}},
{{ ' BL >CFA EXECUTE .},{20},
{ ' BL EXECUTE .},{20}}, enddoc)
CODE_HEADER({EXECUTE},{EXEC})
        POP     WOR      ;{ GET XT}
        JMP     _CELL_PTR[WOR + _CELLS(C_HOFFSET)]  ;{(IP) <- (PFA)}
;
_LOAD_({
worddoc( {CONTROL},{RECURSE},,{(varies)},{ISO},
{Do a recursive call of the definition being compiled.},
{{:}},
{
{: GI6 DUP IF DUP >R 1 - RECURSE R> . THEN ;},{},
{3 GI6 .}, {1 2 3 0},
},
enddoc)
HEADER({RECURSE}, {RECURSE}, {DOCOL}, ,{B_IMMED})
        DC      LATEST, COMMA
        DC      SEMIS
;
});_END_({_LOAD_})
worddoc( {CONTROL~},{BRANCH},{branch},{},{FIG,C2,L0},
{The run-time proceedure to unconditionally branch. An in-line
offset is added to the interpretive pointer forthcode({IP}) to
branch ahead or back. forthcode({BRANCH}) is compiled by
forthcode({ELSE}) , forthcode({AGAIN}) , forthcode({REPEAT})
.},
{{0BRANCH}},
{{ : GS1 1 BRANCH [ 0 CELL+ , ] BL BL ; GS1 . . },
{20 1}},
enddoc)
HEADER({BRANCH},{BRAN}, {_VAR_FIELD(SKIP)})
;
worddoc( {CONTROL},{SKIP},{skip},{},{C2,L0},
{Skip over an area in memory, where the length is given in the next cell.
This length doesn't include the length cell, so it is compatible with
forthcode({$@}) .
_VERBOSE_({Internal, used for nested compilation. })},
{{BRANCH}},
{{ : GS1 1 SKIP [ 0 CELL+ , ] BL BL ; GS1 . .},
{20 1}},
enddoc)
CODE_HEADER({SKIP},{SKIP})
BRAN1:  LODSW
_ALIGNED_({
        DEC     AX
        OR      AL, M4_CELLWIDTH - 1
        INC     AX
},{dnl});_END_({_ALIGNED_})
        ADD     HIP,AX
        _NEXT
;
worddoc( {CONTROL~},{0BRANCH},{zero_branch},{f ---},{FIG,C2},
{The run-time proceedure to conditionally branch. If forthvar({f}) is false
(zero), the following in-line parameter is added to the interpretive
pointer to branch ahead or back. Compiled by forthcode({IF}) , forthcode({UNTIL}) , and forthcode({WHILE}) .
},{{BRANCH}},
{{ : GS1 1 0 0BRANCH [ 0 CELL+ , ] BL BL ; GS1 . .}, {20 1},
{ : GS2 1 1 0BRANCH [ 0 CELL+ , ] BL BL ; GS2 . .}, {20 20}},
enddoc)
CODE_HEADER({0BRANCH},{ZBRAN})
        POP     AX      ;{ GET STACK VALUE}
        OR      AX,AX   ;{ ZERO?}
        JZ      BRAN1   ;{ YES, BRANCH}
        LEA     HIP,[HIP+_CELLS(1)]
        _NEXT
;
worddocsafe( {CONTROL~},{(LOOP)},{paren_loop},{},{C2},
{The run-time proceedure compiled by LOOP which increments the loop
index and tests for loop completion.
},{{LOOP}},
{{." See LOOP"},{See LOOP}},
enddoc)
CODE_HEADER({(LOOP)},{XLOOP})
        MOV     BX,1    ;{ INCREMENT}
XLOO1:  ADD     [RPO],BX ;{ INDEX = INDEX + INCR}
        MOV     AX,[RPO] ;{ GET NEW INDEX}
        SUB     AX,[RPO+_CELLS(1)]        ;{ COMPARE WITH LIMIT}
        XOR     AX,BX   ;{ TEST SIGN}
        JS      BRAN1   ;{ KEEP LOOPING}
;
;{  END OF `DO' LOOP}
        LEA     RPO,[RPO+_CELLS(3)]  ;{ ADJ RETURN STACK}
        LEA     HIP,[HIP+_CELLS(1)]       ;{ BYPASS BRANCH OFFSET}
        _NEXT
;
worddocsafe( {CONTROL~},{(+LOOP)},{paren_plus_loop},{n ---},{C2},
{The run-time proceedure compiled by forthcode({+LOOP}), which increments the loop
index by n and tests for loop completion.},{{+LOOP}},
{{." Via +LOOP"},{Via +LOOP}},
enddoc)
CODE_HEADER({(+LOOP)},{XPLOO})
        POP     BX      ;{ GET LOOP VALUE}
        JMP SHORT     XLOO1
;
worddocsafe( {CONTROL~},{(DO)},{paren_do},{},{C},
{The run-time proceedure compiled by forthcode({DO}) which
prepares the return stack, where the looping bookkeeping is kept.},{{DO}},
{{( See DO)},{}},
enddoc)
CODE_HEADER({(DO)},{XDO})
        LODSW
        ADD     AX,HIP  ;{Make absolute}
        POP     DX      ;{ INITIAL INDEX VALUE}
        POP     BX      ;{ LIMIT VALUE}
        XCHG    RPO,SPO   ;{ GET RETURN STACK}
        PUSH    AX      ;{ Target location.}
        PUSH    BX
        PUSH    DX
        XCHG    RPO,SPO   ;{ GET PARAMETER STACK}
        _NEXT
;
worddocsafe( {CONTROL~},{(?DO)},{paren_question_do},{},{C},
{The run-time proceedure compiled by forthcode({?DO}) which
prepares the return stack, where the looping bookkeeping is kept.},{{?DO}},
{{( See ?DO)},{}},
enddoc)
CODE_HEADER({(?DO)},{XQDO})
        LODSW
        ADD     AX,HIP  ;{Make absolute}
        POP     DX      ;{ INITIAL INDEX VALUE}
        POP     BX      ;{ LIMIT VALUE}
        CMP     DX,BX
        JZ      QXDO1
        XCHG    RPO,SPO   ;{ GET RETURN STACK}
        PUSH    AX      ;{ Target location.}
        PUSH    BX
        PUSH    DX
        XCHG    RPO,SPO   ;{ GET PARAMETER STACK}
        _NEXT
QXDO1:  MOV     HIP,AX
        _NEXT
;
worddoc( {CONTROL},{I},{i},{--- n},{ISO,FIG,C,L0},
{Used within a do-loop to copy the loop index to the stack.},
{{DO},{LOOP},{+LOOP}},
{ { : GS1 DO I . LOOP 0 . ; 2 -2 GS1},{-2 -1 0 1 0},
  { : GS2 DO I . LOOP 0 . ; 4 0 GS2},{0 1 2 3 0} },
enddoc)
CODE_HEADER({I},{IDO})
        MOV     AX,[RPO] ;{ GET INDEX VALUE}
        _PUSH          ;{ TO PARAMETER STACK}
;
worddoc( {CONTROL},{J}, ,{--- n},{ISO,FIG,C,L0},
{Used within a nested do-loop to copy the loop index of the
outer do-loop to the stack.},
{{DO},{LOOP},{+LOOP}},
{ { : GS1 DO 1 0 DO J . LOOP LOOP ; 2 -2 GS1},{-2 -1 0 1},
  { : GS2 DO 1 0 DO J . LOOP LOOP ; 4 0 GS2},{0 1 2 3} },
enddoc)
CODE_HEADER({J},{JDO})
        MOV     AX,[RPO+_CELLS(3)] ;{ GET INDEX VALUE}
        _PUSH          ;{ TO PARAMETER STACK}
;
worddoc( {CONTROL},{UNLOOP},{unloop},{--- n},{ISO,I,C,L0},
{Discard the loop parameters. Must be
used when the regular end of the
loop is by-passed.},
{{DO},{LOOP},{+LOOP},{(BACK},{(FORWARD}},
{
{ : GS1 DO I . I 3 = IF UNLOOP EXIT THEN LOOP ; 10 0 GS1},
{0 1 2 3},
dnl This only words for SECURITY off.
dnl { : GS2 DO I . I 3 - 0BRANCH [ (FORWARD SWAP ] LOOP  EXIT dnl
dnl [ FORWARD) ] UNLOOP ; 10 0 GS2},
dnl {0 1 2 3},
},
enddoc)
HEADER({UNLOOP},{UNLOOP}, {DOCOL}, ,{B_IMMED})
        DC      LIT, RDROP, COMMA
        DC      LIT, RDROP, COMMA
        DC      LIT, RDROP, COMMA
        DC      SEMIS
;
worddoc( {INIT},{+ORIGIN},{plus_origin},{n --- addr},{},
{Leave the memory address relative by forthvar({n}) bytes to
the area from which the user variables are initialised, so one
can access or modify the boot-up parameters. During run time
user variables are fetched from the current user area, via a
pointer at forthsamp({0 +ORIGIN }) . This can be swapped to get
a fresh set of user variables, for multi-asking. One can access
or modify the boot-up parameters, prior to saving a customised
boot image. It will also change the initialisation by
forthcode({COLD}). },
{{USER}},
{{0A 0 CELL+ * +ORIGIN @ ' ENVIRONMENT = .}, {_T_}},
enddoc)
HEADER({+ORIGIN},{PORIG},{DOCOL})
        DC      LIT
        DC      USINI
        DC      PLUS
        DC      SEMIS
;
;{      Initialisation block for user variables through VOC-LINK}
;{       <<<<< must be in same order as user variables >>>>>}
;
USINI:  DC      STRUSA  ;{ User area currently in use, cold value same as next.}
        DC      STRUSA  ;{ INIT (U0) user area of the main task 1}
        DC      INITS0  ;{ INIT (S0)         2}
        DC      INITR0  ;{ INIT (R0)         3}
        DC      STRTIB  ;{ INIT (TIB)        4}
        DC      BSIN    ;{ RUBOUT: get rid of latest char 5}
        DC      0       ;{ AVAILABLE         6}
        DC      1       ;{ INIT (WARNING)     7}
        DC      INITDP  ;{      INIT (FENCE)  8}
        DC      INITDP  ;{      INIT (DP)     9}
        DC      _DEA(ENV) ;{       INIT (VOC-LINK) 10}
_LINUX_C_({
        DC      0       ;{ INIT (OFFSET) }
});_END_({_LINUX_C_})
_LINUX_N_({
        DC      0       ;{ INIT (OFFSET) }
});_END_({_LINUX_N_})
_RWFILE_({
        DC      0       ;{ INIT (OFFSET) }
});_END_({_RWFILE_})
_CLASSIC_({
_COMMENT
;{ This will steer clear of a forth executable, provided it is}
;{ the first file on the floppy. }
;{ (X-1)/S+1 rounds up to whole `S', this is used several times. }
;{ The 2 is rounding plus the extra sector in .EXE files.}
;{ However it deviates much from the classic model and requires}
;{ that the disk parameters are available (not only for USEBIOS)}
        DC      (RELATIVE_WRT_ORIG(TEXTEND)-1)/KBBUF+1 ; +1 for EXE
_ENDCOMMENT
;{ So for now just the classic, swap disk after booting.}
        DC      0       ;{ INIT (OFFSET) }
});_END_({_CLASSIC_})
_RWSECTRK_({
_NO_RESPECTDOS_({
        DC      40H     ;{ INIT (OFFSET) }
});_END_({_NO_RESPECTDOS_})
_RESPECTDOS_({
;{ This will reserve place for dos information, such that the floppy}
;{ can be accessed from DOS and makes sure blocks are not allocated}
;{ within the forth system itself. }
;{ BPS subtracted because SECSTRT corresponds with one sector into source. }
;{ Round up both parts separately.}
;       You need a filler file of one sector,
;       if this  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv even (for a 3" drive).
        DC      (SECSTRT+((RELATIVE_WRT_ORIG(TEXTEND)-1-BPS)/BPS+1)-1)/SPB+1     ;{ INIT (OFFSET) }
});_END_({_RESPECTDOS_})

});_END_({_RWSECTRK_})
_RWLBA_({
;{ This will reserve place for the system itself, on the first part of a }
;{ hard disk. No problem to just reserve whole memory.}
        DC      64      ;{ Kbyte.}
});_END_({_RWLBA_})
;
        DC      0, 0            ;{ WHERE             12 13 }
        DC      0, STRTIB       ;{REMAINDER   14 15 }
_SWITCH_({
; {Swap the following with DP to allocate in conventional memory.}
         DC     TEXTEND         ; {LOW-DP        16}
; {Leave space to start conventional programs}
         DC     80000H          ; {LOW-EM        17}
});_END_({ _SWITCH_})
        _RESB(US-($ - USINI))        ;{ All user can be initialised.}
;
;{      <<<<< end of data used by cold start >>>>>}
worddoc( {FORMATTING~},{DIGIT},{digit},{c n1 --- n2 tf (ok) c n1 --- ff (bad)},{},
{Converts the ascii character forthvar({c}) (using base forthvar({n1}) ) to its binary
equivalent forthvar({n2}) , accompanied by a true flag. If the conversion is
invalid, leaves only a false flag.},{},
{ {31 0A DIGIT . .},{1 1},
  {41 0A DIGIT .},{0},
  {41 10 DIGIT . .},{1 A} },
enddoc)
CODE_HEADER({DIGIT},{DIGIT})
        POP     DX      ;{NUMBER BASE}
        POP     AX      ;{ASCII DIGIT}
        SUB     AL,'0'
        JB      DIGI2   ;{NUMBER ERROR}
        CMP     AL,9
        JBE     DIGI1   ;{NUMBER = 0 THRU 9}
        SUB     AL,7
        CMP     AL,10   ;{NUMBER 'A' THRU 'Z'?}
        JB      DIGI2   ;{NO}
DIGI1:  CMP     AL,DL   ;{ COMPARE NUMBER TO BASE}
        JAE     DIGI2   ;{NUMBER ERROR}
        SUB     DX,DX   ;{ZERO}
        MOV     DL,AL   ;{NEW BINARY NUMBER}
        MOV     AL,1    ;{TRUE FLAG}
        _2PUSH          ;{ADD TO STACK}
;{   NUMBER ERROR}
DIGI2:  SUB     AX,AX   ;{FALSE FLAG}
        _PUSH
;
worddoc( {DICTIONARY~},{RESULT},{result},{--- addr},{},
{A variable containing the address of the result of searching
in one word list chain.},{{BLOCK}},
{{." Via MATCHING-WORD"},{Via MATCHING-WORD}},
enddoc)
HEADER({RESULT},{RESULT},{DOVAR}, )
        DC 0
;
worddoc( {DICTIONARY~},{MATCHING-WORDS},{matching_words},{sc addr2 --- addr1}, {},
{Intended to cooperate with forthcode({FOR-WORDS}) . Compares
the string constant forthvar({sc}) with the dea
forthvar({addr2}). If it is a match, it returns into
forthcode({RESULT}) this forthdefi({DEA}) and it exits
prematurely from forthcode({FOR-WORDS}).},
{{FIND}},
{{ : GS1 DUP >R DUP FOR-WORDS RESULT @ R> = ; dnl
"MATCHING-WORDS" ' MATCHING-WORDS GS1 .},{_T_}},
enddoc)
HEADER({MATCHING-WORDS},{MATCHING},{DOCOL})
        DC      TOR
        DC      RR, TFFA, FETCH
        DC      LIT, B_INVIS _OR_ B_DUMMY, LAND ;{Get flags.}
        DC      ZEQU
        _0BRANCH(MATS2)
;       DC      RR, IDDOT
        DC      RR, TNFA, FETCH, FETCH
        DC      OVER, LSUB
        DC      RR, TFFA, FETCH, LIT, B_DENOT, LAND ;{Get flag.}
        DC      OVER, ZLESS, LAND  ;{Ignorable length difference.}
        DC      ZEQU, LAND
        DC      ZEQU
        _0BRANCH(MATS2)
        DC      OVER
        DC      RR, TNFA, FETCH, SFET
        DC      CORA, ZEQU  ;{ Compare equals.}
        _0BRANCH(MATS2)
        DC      FROMR, FROMR
        DC      RDROP, ZERO, TOR ;{FORCE END}
        DC      TOR, TOR
        DC      RR, RESULT, STORE
MATS2:  DC      RDROP
        DC      SEMIS
;
worddoc( {PARSING},{?BLANK},{query_blank},{ch --- f },{},
{For the character forthsamp({ch}) return whether this is
considered to be white space into the flag forthvar({f}) .
At least the space, ascii null, the tab and the carriage return and line
feed characters are white space.},
{{BL},{SPACE}},
{{HEX 20 ?BLANK . 41 ?BLANK .},{_T_ 0}}, enddoc)
HEADER({?BLANK},{QBL},{DOCOL})
        DC      LBL, ONEP, LESS
        DC      SEMIS
;
worddoc( {PARSING},{IN[]},{in_next},{ ---addr chr},{CI L0},
{Parse the forthdefi({current input source}) leaving the next
character forthvar({chr}) and its address forthvar({addr}) . If
at the end of the input source, leave a pointer past the end
and a zero. Advance the input pointer to the next character.
},
{{BLK},{WORD},{IN}},
{{IN[] A   EMIT TIB @ 8000 OVER + WITHIN .},{A{}_T_} },
enddoc)
HEADER({IN[]},{INBRS},{DOCOL})
        DC      SRC, CELLP, TFET
        DC      OVER, EQUAL
        _0BRANCH(INBRS1)
        DC      ZERO
        _BRANCH(INBRS2)
INBRS1:
        DC      LDUP
        _ISO_IN_({DC      SRC, FETCH, PLUS ;{ Make IN >IN.}})
        DC      CFET
        DC      ONE, LIN, PSTORE
INBRS2:
        DC      SEMIS
;
worddocsafe( {PARSING},{(WORD)},{m_parse},{--- sc},{CI L0},
{Parse the forthdefi({current input source}) for a word, i.e.
observing forthcode({?BLANK}) . Skip leading delimiters then
advance the input pointer to past the next delimiter or past
the end of the input source. Leave the word found as a string
constant forthvar({sc}) . _VERBOSE_({As it goes with string
constants, you may not alter its content, nor assume anything
is appended. Note that this is more deserving of the name
``WORD'' than what is in the ISO standard, cf. forthsamp({:
LINE LINEFEED WORD ;}). })},
{{BLK},{WORD},{IN}},
{{: GS2 (WORD) . C@ EMIT ; GS2 CELLO},{5 C},
{HEX : GS1 (WORD) . C@ EMIT ; GS1   QQ},{2 Q}}, enddoc)
HEADER({(WORD)},{LPWORD},{DOCOL})
        DC      ZERO ; { Dummy to drop }
PWORD0: DC      DROP
        DC      INBRS, QBL
        DC      OVER, SRC, CELLP, FETCH, LSUB ;{ At end?}
        DC      LAND, ZEQU
        _0BRANCH(PWORD0)

        DC      ZERO ; { Dummy to drop }
PWORD1: DC      DROP
        DC      INBRS, QBL
        _0BRANCH(PWORD1)

        DC      OVER, LSUB
        _ISO_IN_({DC      SWAP, SRC, FETCH, PLUS, SWAP})
        DC      SEMIS
;
worddocsafe( {PARSING~},{(PARSE)},{paren_parse},{ ch --- sc },{},
{Scan the forthdefi({current input source}) for the character forthvar({ch}) .
Return forthvar({sc}): a string from the current position in the
input stream, ending before the first such character,
or at the end of the current input source if it isn't
there. The character is consumed.
_VERBOSE_({{As it goes with string constants, you may not alter
its content, nor assume anything is appended.}})
_VERBOSE_({So no leading delimiters are skipped.})
_VERBOSE_({The difference with an ISO forthsamp({PARSE}) is that
ISO considers control characters a match for a blank.})},
{{WORD},{WORD}},
{{ : GS1 5A (PARSE) . C@ EMIT ; GS1 QQZ},{2 Q}}, enddoc)
HEADER({(PARSE)},{PPARS},{DOCOL})
        DC      SRC, CELLP, TFET
        DC      OVER, LSUB
        _ISO_IN_({DC      SWAP, SRC, FETCH, PLUS, SWAP})
        DC      ROT, SSPLIT, TSWAP
        DC      ZEQU
        _0BRANCH(PPARS8)
        DC      DROP, SRC, CELLP, FETCH
PPARS8: _ISO_IN_({DC      SRC, FETCH, LSUB })
        DC      LIN, STORE
        DC SEMIS
;
worddoc( {PARSING},{SRC},{s_r_c},{addr --- },{},
{Return the address forthvar({addr})
of the forthdefi({current input source}) specification,
allocated in the user area. It consists of three cells: the
lowest and non-inclusive highest address of the parse area
_CIF_IN_({the non-inclusive highest address of the parse area
and a pointer to the next character to be parsed.})
_ISO_IN_({the number of characters and the current index in the
parse area.}) Changing forthsamp({SRC}) takes immediate effect,
and must be atomic, by using forthsamp({RESTORE-INPUT}),
or changing only the third cell.
The third cell has the alias
_CIF_IN_({forthsamp({IN}) .})
_ISO_IN_({forthsamp({>IN}) .})
_VERBOSE_({{Words like forthsamp({>IN BLK SOURCE SOURCE-ID}) are secondary,
and return their output by ``second-guessing'' forthsamp({SRC}) .}})},
{{BLK},{SOURCE-ID}},
{{SRC @ TIB @ 8000 OVER + WITHIN .},{_T_} },
enddoc)
HEADER({SRC},{SRC},{DOUSE}, _CELLS(27))      ;{ And 28 and 29.}
;
_LOAD_({
worddoc( {PARSING},{SOURCE},{source},{ --- addr n1},{ISO},
{Return the address and length of the forthdefi({current input source}) .
},
{{SRC},{SOURCE-ID}},
{{SOURCE DROP TIB @ 8000 OVER + WITHIN .},{_T_} },
enddoc)
HEADER({SOURCE},{SOURCE},{DOCOL})
        DC      SRC, FETCH
        DC      SRC, CELLP, FETCH
        DC      OVER, LSUB
        DC      SEMIS
;
worddoc( {INPUT},{>IN},{iso_in},{--- addr},{ISO},
{Return a variable that contains the offset from the start
within the current input text buffer (terminal or disc) from
which the next text will be accepted. All parsing words use and
move the value of forthcode({IN}). The variable
forthcode({>IN}) is not actually used and its content must be
fetched immediately.},
{{(>IN)},{IN}},
{{: GS1 >IN @ ; QUIT
GS1 .},{4}},
enddoc)
HEADER({>IN},{IIN},{DOCOL})
        DC      LIN, FETCH
_CIF_IN_({DC      SRC, FETCH, LSUB     })
        DC      PIIN, STORE
        DC      PIIN
        DC      SEMIS
;
});_END_({_LOAD_})
worddoc( {OUTPUT},{CR},{cr},{},{ISO,FIG,L0},
{Transmit character(s)
to the terminal, that result in
a "carriage return" and a "line feed".
_VERBOSE_({This means that the cursor is positioned at the start
of the next line, if needed the display is scrolled.})},{{OUT}},
{{ 41 EMIT CR 42 EMIT},{A
B}},
enddoc)
HEADER({CR},{CR},{DOCOL})
        DC      LIT,ALF
        DC      EMIT
        DC      ZERO, LOUT, STORE
        DC      SEMIS
;
worddoc( {MEMORY},{CMOVE},{cmove},{from to count --},{},
{Move the specified quantity of characters beginning at address
 forthsamp({from}) to address forthsamp({to}) . The contents of
address from is moved first proceeding toward high memory, such
that memory propagation occurrs. As the Intel 86-family is
byte-addressing there are no restrictions in ciforth. },
{},
{ {HERE 41 C, 42 C, 43 C, PAD 10 0 FILL PAD 3 CMOVE dnl
PAD COUNT EMIT COUNT EMIT C@ EMIT},{ABC},
{PAD DUP 1+ 2 CMOVE PAD COUNT EMIT COUNT EMIT C@ EMIT},{AAA} },
enddoc)
CODE_HEADER({CMOVE},{LCMOVE})
        CLD             ;{direction}
        MOV     BX,HIP   ;{save }
        POP     CX      ;{count}
        POP     DI      ;{dest}
        POP     SI      ;{source}
        REP     MOVSB
        MOV     HIP,BX   ;{get back }
        _NEXT
;
worddoc( {MEMORY},{MOVE},{move},{from to count --},{},
{Move the forthsamp({count})
bytes beginning at address forthsamp({from}) to
address forthsamp({to}), such that the destination area contains
what the source area contained, regardless of overlaps.
As the Intel 86-family is byte-addressing there are
no restrictions. },
{},
{ {HERE 41 C, 42 C, 43 C, PAD 10 0 FILL PAD 3 MOVE dnl
PAD COUNT EMIT COUNT EMIT C@ EMIT},{ABC},
{PAD DUP 1+ 2 MOVE PAD COUNT EMIT COUNT EMIT C@ EMIT},{AAB} },
enddoc)
CODE_HEADER({MOVE},{LMOVE})
        MOV     BX,HIP   ;{SAVE }
        POP     CX      ;{count}
        POP     DI      ;{dest}
        POP     SI      ;{source}
        CMP     SI,DI
        JC    MOVE1
        CLD             ;{INC DIRECTION}
        JMP SHORT MOVE2
MOVE1:  STD
        ADD     DI,CX
        DEC     DI
        ADD     SI,CX
        DEC     SI
MOVE2:
        REP     MOVSB   ;{THAT'S THE MOVE}
        CLD             ;{INC DIRECTION}
        MOV     HIP,BX   ;{GET BACK }
        _NEXT
;
worddoc( {MULTIPLYING},{UM*},{u_start},{u1 u2 --- ud},{ISO},
{A mixed magnitude math operation which leaves the double number
forthvar({ud}) : the unsigned product of two unsigned numbers
forthvar({u1}) and forthvar({u2}) .},
{{UM/MOD}, {M*}.{*}},
{ { -1 -1 UM* . INVERT .},{-2 -2},
  {DECIMAL 240 204 UM* D.},{48960} },
enddoc)
CODE_HEADER({UM*},{USTAR})
        POP     AX
        POP     BX
        MUL     BX      ;{UNSIGNED}
        XCHG    AX,DX   ;{AX NOW = MSW}
        _2PUSH          ;{STORE DOUBLE CELL}
;
worddoc( {MULTIPLYING},{UM/MOD},{u_slash},{ud u1 --- u2 u3},{ISO},
{Leave the unsigned remainder forthvar({u2}) and unsigned
quotient forthsamp({u3}) from the unsigned double dividend
forthvar({ud}) and unsigned divisor forthvar({u1}) .},
{{UM*},{SM/REM},{/}},
{
{DECIMAL 12.34 100 UM/MOD . .},{12 34}
},
enddoc)
CODE_HEADER({UM/MOD},{USLAS})
        POP     BX      ;{DIVISOR}
        POP     DX      ;{MSW OF DIVIDEND}
        POP     AX      ;{LSW OF DIVIDEND}
        DIV     BX      ;{16 BIT DIVIDE}
        _2PUSH          ;{STORE QUOT/REM}
;
worddoc( {LOGIC},{AND},{and},{n1 n2 --- n2},{ISO,FIG,L0},
{Leave the bitwise logical and of forthvar({n1}) and
forthvar({n2}) as forthsamp({n3}) .},
{{XOR},{OR}},
{ { 2 BASE !  11110000 11001100 AND .},{11000000} },
enddoc)
CODE_HEADER({AND},{LAND})
        POP     AX
        POP     BX
        AND     AX,BX
        _PUSH
;
worddoc( {LOGIC},{OR},{or},{n1 n2 --- or},{ISO,FIG,L0},
{Leave the bit-wise logical or of two _BITS_ bit
values.},{{AND},{XOR}},
{ { 2 BASE !  11110000 11001100 OR .},{11111100} },
enddoc)
CODE_HEADER({OR},{LOR})
        POP     AX      ;{ (S1) <- (S1) OR (S2)}
        POP     BX
        OR      AX,BX
        _PUSH
;
worddoc( {LOGIC},{XOR},{xor},{nl n2 --- xor},{L1},
{Leave the bitwise logical exclusive or of two
values.},{{AND},{OR}},
{ { 2 BASE !  11110000 11001100 XOR .},{111100} },
enddoc)
CODE_HEADER({XOR},{LXOR})
        POP     AX      ;{ (S1) <- (S1) XOR (S2)}
        POP     BX
        XOR     AX,BX
        _PUSH
;
worddoc( {LOGIC},{INVERT},{INVERT},{n1 --- n2},{L1},
{Invert all bits of forthvar({n1}) leaving forthsamp({n3}) .},
{{AND},{OR}},
{ { 2 BASE ! 11101101 INVERT 11111111 AND .},{10010} },
enddoc)
CODE_HEADER({INVERT},{INVER})
        POP     AX      ;{ (S1) <- (S1) XOR (S2)}
        NOT     AX
        _PUSH
;
worddocsafe( {STACKS},{DSP@},{d_s_p_fetch},{--- addr},{},
{Return the address forthvar({addr}) of the data stack position,
as it was before forthcode({DSP@}) was executed.
},
{{S0},{DSP!}},
{ {1  2  DSP@  @  . . . },{2 2 1} },
enddoc)
CODE_HEADER({DSP@},{SPFET})
        MOV     AX,SPO   ;{ (S1) <- (SP)}
        _PUSH
;
worddoc( {STACKS},{DSP!},{d_s_p_store},{addr --- },{},
{Initialize the data stack pointer with forthvar({addr}) .},
{{DSP@}},
{{  1 2 3 S0 @ DSP! DSP@ S0 @ = .},{_T_} },
enddoc)
CODE_HEADER({DSP!},{SPSTO})
        POP     AX
        MOV     SPO,AX        ;{RESET PARAM STACK POINTER}
        _NEXT
;
_LOAD_({
worddoc( {STACKS},{DEPTH},,{--- n1},{ISO},
{Leave into forthvar({n1}) the number of items on the data stack,
before forthsamp({n1}) was pushed.},
{{DSP@}},
{{  1 2 3 DEPTH .},{3} },
enddoc)
HEADER({DEPTH},{DEPTH},{DOCOL})
        DC      SZERO, FETCH
        DC      SPFET
        DC      LSUB
        DC      LIT, CW, SLASH
        DC      ONEM
        DC      SEMIS
;
});_END_({_LOAD_})
worddocsafe( {STACKS},{RSP@},{r_s_p_fetch},{--- addr},{},
{Return the address forthvar({addr}) of the current return
stack position, i.e. pointing the current topmost value.},
{{R0},{RSP!}},
{ {: GS1 1 >R  RSP@  @  . R> ; GS1},{1} },
enddoc)
CODE_HEADER({RSP@},{RPFET})      ;{(S1) <- (RP)}
        PUSH    RPO
        _NEXT
;
worddoc( {STACKS},{RSP!},{r_s_p_store},{addr ---},{},
{Initialize the return stack
pointer with forthvar({addr}).},
{{RSP@}},
{{." No test"},{No test} },
enddoc)
CODE_HEADER({RSP!},{RPSTO})
        POP     RPO
        _NEXT
;
worddoc( {CONTROL},{EXIT},{exit},{},{ISO},
{ Stop interpretation of the current definition. The return
stack must not be engaged, such as between forthcode({>R}) and
forthcode({R>}) , or forthcode({DO}) and forthcode({LOOP}) . In
ciforth it can also be used to terminate
interpretation from a
string, block or file, or a line from the current input stream.
},
{{(;)}},
{ {: GS1 1 EXIT 2 ; GS1 .},{1} },
enddoc)
CODE_HEADER({EXIT},{EXIT})
        MOV     HIP,[RPO] ;{(IP) <- (R1)}
        LEA     RPO,[RPO+_CELLS(1)]
        _NEXT
;
worddocsafe( {CONTROL},{{;}},{semicolon_s},{},{},
{ This is a synonym for forthcode({EXIT}). It is the run-time
word compiled at the end of a colon-definition which returns
execution to the calling proceedure. Stop interpretation of the
current definition. The return stack must not be engaged. },
{EXIT},
{ {: GS1 1 (;) 2 ; GS1 .},{1} },
enddoc)
HEADER({(;)},{SEMIS},{_VAR_FIELD(EXIT)})
;
worddoc( {CONTROL},{LEAVE},{leave},{},{ISO},
{Termination a do-loop by branching to directly behind the
end of a loop started by forthsamp({DO}) or forthsamp({?DO}) ,
so after the corresponding
forthcode({LOOP}) or forthcode({+LOOP}) .},{},
{ {: GS1 10 1 DO I 4 = IF LEAVE THEN I . LOOP ; GS1},{1 2 3} },
enddoc)
HEADER({LEAVE},{LLEAV},{DOCOL})  ;{LIMIT <- INDEX}
        DC      RDROP, RDROP, RDROP
        DC      SEMIS
;
worddoc( {STACKS},{>R},{to_r},{n ---},{ISO,FIG,C,L0},
{Remove a number from the computation stack and place as the most
accessable on the return stack. Use should be balanced with forthcode({R>}) in
the same definition.},{{R@}},
{ {: GS1 1 2 3 >R . R@ . R> . . ; GS1},{2 3 3 1} },
enddoc)
CODE_HEADER({>R},{TOR})        ;{ (R1) <- (S1)}
        POP     BX      ;{GET STACK PARAMETER}
        LEA     RPO,[RPO - _CELLS(1)]    ;{MOVE RETURN STACK DOWN}
        MOV     [RPO],BX ;{ADD TO RETURN STACK}
        _NEXT
;
worddoc( {STACKS},{R>},{r_from},{--- n},{ISO,FIG,L0},
{Remove the top value from the return stack and leave it on the
computation stack. },{{>R},{R@}},
{{." Via >R"},{Via >R}},
enddoc)
CODE_HEADER({R>},{FROMR})      ;{(S1) <- (R1)}
        MOV     AX,[RPO] ;{ GET RETURN STACK VALUE}
        LEA     RPO,[RPO + _CELLS(1)]
        _PUSH
;
worddoc( {STACKS},{RDROP},{r_drop},{---} ,{},
{Remove the top value from the return stack.},{{>R},{R@},{R>}},
{{." Via >R"},{Via >R}},
enddoc)
CODE_HEADER({RDROP},{RDROP})      ;{(S1) <- (R1)}
        LEA     RPO,[RPO+_CELLS(1)]
        _NEXT
;
worddocsafe( {STACKS},{R},{r_fetch},{--- n},{ISO},
{Copy the top of the return stack to the computation stack.},{{>R},{<R}},
{{." Via >R"},{Via >R}},
enddoc)
HEADER({R@},{RR},{_VAR_FIELD(IDO)})
;
worddoc( {LOGIC},{0=},{zero_equals},{n --- f},{ISO,FIG,L0},
{Leave a true flag forthvar({f}) is the number forthvar({n})
is equal to zero, otherwise leave a false flag.},{{=}},
{ {0 0= .},{_T_},
  {  1 0= .},{0},
  {  -1 0= .},{0} },
enddoc)
CODE_HEADER({0=},{ZEQU})
        POP     AX
        NEG     AX
        CMC
        SBB     AX,AX
        _PUSH
;
worddoc( {LOGIC},{0<},{zero_less},{n --- f},{ISO,FIG,L0},
{Leave a true flag if the number is less than zero (negative),
otherwise leave a false flag.},{{<}},
{ {0 0< .}, {0},
  {  1 0< .}, {0},
  {  -1 0< .}, {_T_} },
enddoc)
CODE_HEADER({0<},{ZLESS})
        POP     AX
        OR      AX,AX   ;{SET FLAGS}
        MOV     AX,0    ;{FALSE}
        JNS     ZLESS1
        DEC     AX      ;{TRUE}
ZLESS1: _PUSH
;
worddoc( {OPERATOR},{+},{plus},{n1 n2 --- sum},{ISO,FIG,L0},
{Leave the sum of forthvar({n1}) and forthvar({n2}) .},{{-},{*},{/},{MOD}},
{ { 0A BASE !  240 204 + .},{444} },
{}, enddoc)
CODE_HEADER({+},{PLUS})
        POP     AX      ;{(S1) <- (S1) + (S2)}
        POP     BX
        ADD     AX,BX
        _PUSH
;
worddoc( {DOUBLE},{D+},{d_plus},{d1 d2 --- dsum},{ISO,FIG},
{Leave the double number forthvar({dsum}): the sum of two
double numbers forthvar({d1}) and forthvar({d2}) .},
{{DNEGATE},{+}},
{ { DECIMAL  240. 204. D+ D.},{444},
  { DECIMAL  -240. -204. D+ D.},{-444} },
enddoc)
CODE_HEADER({D+},{DPLUS})
        POP     AX      ;{ YHW}
        POP     DX      ;{ YLW}
        POP     BX      ;{ XHW}
        POP     CX      ;{ XLW}
        ADD     DX,CX   ;{ SLW}
        ADC     AX,BX   ;{ SHW}
        _2PUSH
;
worddoc( {OPERATOR},{NEGATE},{negate},{n1 --- n2},{ISO,FIG,L0},
{Leave the two's complement of a number, i.e.
 forthvar({n2}) is forthsamp({-n1})},
{{-}},
{ {0 NEGATE .}, {0},
  {  1 NEGATE .}, {-1},
  {  -1 NEGATE .}, {1} },
enddoc)
CODE_HEADER({NEGATE},{NEGATE})
        POP     AX
        NEG     AX
        _PUSH
;
worddoc( {DOUBLE},{DNEGATE},{d_negate},{d1 --- d2},{ISO},
{forthvar({d2}) is the negation of forthvar({d1}).
},{{D+}},
{ {0. DNEGATE D.}, {0},
  {  1. DNEGATE D.}, {-1},
  {  -1. DNEGATE D.}, {1} },
enddoc)
CODE_HEADER({DNEGATE},{DNEGA})
        POP     BX
        POP     CX
        SUB     AX,AX
        MOV     DX,AX
        SUB     DX,CX   ;{ MAKE 2'S COMPLEMENT}
        SBB     AX,BX   ;{ HIGH CELL}
        _2PUSH
        PAGE
;
worddoc( {JUGGLING},{OVER},{over},{nl n2 --- nl n2 n1},{ISO,FIG,L0},
{Copy the second stack value, placing it as the new top.},
{{DUP}},
{{S0 @ DSP! 1 2 3 4 OVER .S},{
S[  1 2 3 4 3 ]} },
enddoc)
CODE_HEADER({OVER},{OVER})
        POP     DX
        POP     AX
        PUSH    AX
        _2PUSH
;
worddoc( {JUGGLING},{DROP},{drop},{n ---},{ISO,FIG,L0},
{Drop the number from the stack.},
{{DUP}},
{{S0 @ DSP! 1 2 3 4 DROP .S},{
S[  1 2 3 ]} },
enddoc)
CODE_HEADER({DROP},{DROP})
        POP     AX
        _NEXT
;
worddoc( {JUGGLING},{2DROP},{two_drop},{n1 n2 ---},{ISO},
{Drop the topmost two
numbers (or one double number)
 from the stack.},
{{DROP},{2DUP}},
{{S0 @ DSP! 1 2 3 4 2DROP .S},{
S[  1 2 ]} },
enddoc)
CODE_HEADER({2DROP},{TDROP})
        POP     AX
        POP     AX
        _NEXT
;
worddoc( {JUGGLING},{SWAP},{swap},{n1 n2 --- n2 n1},{ISO,FIG,L0},
{Exchange the top two values on the stack.},{{ROT}},
{{S0 @ DSP! 1 2 3 4 SWAP .S },{
S[  1 2 4 3 ]} },
enddoc)
CODE_HEADER({SWAP},{SWAP})
        POP     DX
        POP     AX
        _2PUSH
;
worddoc( {JUGGLING},{DUP},{dup},{n --- n n},{ISO,FIG,L0},
{Duplicate the value on the stack.},{{OVER}},
{{S0 @ DSP! 1 2 3 4 DUP .S},{
S[  1 2 3 4 4 ]} },
enddoc)
CODE_HEADER({DUP},{LDUP})
        POP     AX
        PUSH    AX
        _PUSH
;
worddoc( {JUGGLING},{2DUP},{two_dup},{d --- d d},{ISO},
{Duplicate the double number on the stack.},{{OVER}},
{{S0 @ DSP! 1 2 3 4 2DUP .S},{
S[  1 2 3 4 3 4 ]} },
enddoc)
CODE_HEADER({2DUP},{TDUP})
        POP     AX
        POP     DX
        PUSH    DX
        PUSH    AX
        _2PUSH
;
worddoc( {JUGGLING},{2SWAP},{two_swap},{d1 d2 --- d2 d1},{ISO},
{Exchange the top doubles on the stack.},{{ROT}},
{{S0 @ DSP! 1 2 3 4 2SWAP .S },{
S[  3 4 1 2 ]} },
enddoc)
CODE_HEADER({2SWAP},{TSWAP})
        POP     BX
        POP     CX
        POP     AX
        POP     DX
        PUSH     CX
        PUSH     BX
        _2PUSH
;
worddoc( {JUGGLING},{2OVER},{two_over},{d1 d2 --- d1 d2 d1},{ISO},
{Copy the second stack double, placing it as the new top.},
{{2DUP}},
{{S0 @ DSP! 1 2 3 4 2OVER .S},{
S[  1 2 3 4 1 2 ]} },
enddoc)
CODE_HEADER({2OVER},{TOVER})
        POP     BX
        POP     CX
        POP     AX
        POP     DX
        PUSH     DX
        PUSH     AX
        PUSH     CX
        PUSH     BX
        _2PUSH
;
worddoc( {MEMORY},{+!},{plus_store},{n addr ---},{ISO,FIG,L0},
{ Add forthvar({n}) to the value at the
address.},{{TOGGLE},{!}},
{{0 PAD ! 1 PAD +! PAD @ .},{1},
 {1 PAD ! -1 PAD +! PAD @ .},{0} },
enddoc)
CODE_HEADER({+!},{PSTORE})
        POP     BX      ;{ADDRESS}
        POP     AX      ;{INCREMENT}
        ADD     [BX],AX
        _NEXT
;
worddoc( {MEMORY},{TOGGLE},{toggle},{addr b --},{},
{Complement the contents of forthvar({addr}) by the bit pattern
forthvar({b}) .},
{{XOR},{+!} },
{{0 PAD ! PAD 1 TOGGLE PAD @ .},{1},
 {1 PAD ! PAD 1 TOGGLE PAD @ .},{0} },
enddoc)
CODE_HEADER({TOGGLE},{TOGGL})
        POP     AX      ;{BIT PATTERN}
        POP     BX      ;{ADDR}
        XOR     [BX],AX ;
        _NEXT
;
worddocsafe( {MEMORY},{@},{fetch},{addr --- n},{ISO,FIG,L0},
{Leave the _BITS_ bit contents forthvar({n})
of forthvar({addr}) .},
{{!},{C@},{2@},{P@},{PC@},{L@}},
{ {-23 PAD ! PAD @ .},{-23} },
enddoc)
CODE_HEADER({@},{FETCH})
        POP     BX
        MOV     AX,[BX]
        _PUSH
;
worddocsafe( {MEMORY},{C@},{c_fetch},{addr --- b},{ISO},
{Leave the 8 bit contents of memory address.
In ciforth , running on the Intel architectures
there are no restrictions regarding byte
addressing.
},{{C!},{@},{2@}},
{ {-23 PAD C! PAD C@ .},{DD} },
enddoc)
CODE_HEADER({C@},{CFET})
        POP     BX
        XOR     AX,AX
        MOV     AL,[BX]
        _PUSH
;
worddocsafe( {MEMORY},{2@},{two_fetch},{addr--- x1 x2},{ISO},
{Leave a pair of _BITS_ bits values forthsamp({x1}) forthsamp({x2}) from
consequitive cells at forthvar({addr}) . forthsamp({x2}) is fetched from
the lowest address. },{{2!},{@},{C@}},
{ {-23. PAD 2! PAD 2@ D.},{-23} },
enddoc)
CODE_HEADER({2@},{TFET})
        POP     BX      ;{ADDR}
        MOV     AX,[BX] ;{MSW}
        MOV     DX,[BX+_CELLS(1)]        ;{LSW}
        _2PUSH
;
worddoc( {MEMORY},{!},{store},{n addr ---},{ISO,FIG,L0},
{Store all _BITS_ bits of n at address.},{{@},{C!},{2!},{L!},{P!},{PC!}},
{{." Via @"},{Via @}},
enddoc)
CODE_HEADER({!},{STORE})
        POP     BX      ;{ADDR}
        POP     AX      ;{DATA}
        MOV     [BX],AX
        _NEXT
;
worddoc( {MEMORY},{C!},{c_store},{b addr ---},{ISO},
{Store 8 bits of forthsamp({b}) at forthvar({addr}) .
In ciforth , running on the Intel architectures
there are no restrictions regarding byte
addressing.
},{{C@},{!}},
{{." Via C@"},{Via C@}},
enddoc)
CODE_HEADER({C!},{CSTOR})
        POP     BX      ;{ADDR}
        POP     AX      ;{DATA}
        MOV     [BX],AL
        _NEXT
;
worddoc( {MEMORY},{2!},{two_store},{addr--- x1 x2},{ISO},
{Store a pair of _BITS_ bits values forthsamp({x1})
forthsamp({x2}) to consecutive cells at forthvar({addr}) .
forthsamp({x2}) is stored at the lowest address.
},{{2@},{!},{C!}},
{{." Via 2@"},{Via 2@}},
enddoc)
CODE_HEADER({2!},{TSTOR})
        POP     BX      ;{ADDR}
        POP     AX      ;{MSW}
        MOV     [BX],AX
        POP     AX      ;{LSW}
        MOV     [BX+_CELLS(1)],AX
        _NEXT
;
worddoc( {MEMORY},{WITHIN},{within},{n1 n2 n3 --- f},{ISO},
{Return a flag indicating that forthvar({n1}) is in
the range forthvar({n2}) (inclusive)
to forthsamp({n3}) (non-inclusive).
This works for signed as well as unsigned numbers.
Shorthand for: forthsamp({OVER - >R - R U<}) },
{{<},{U<}},
{{ 1 1 3 WITHIN .},{_T_},
{ 2 1 3 WITHIN .},{_T_},
{ 3 1 3 WITHIN .},{0},
{ 4 1 3 WITHIN .},{0}}, enddoc)
HEADER({WITHIN},{WITHIN}, {DOCOL})
        DC      OVER, LSUB, TOR
        DC      LSUB, FROMR
        DC      ULESS
        DC      SEMIS
;
_LOAD_({
worddocsafe( {MEMORY},{L@},{long_fetch},{u addr --- n},{},
{Leave the _BITS_ bit contents of forthsamp({u:addr}),
_BITS16_({ the real mode segment plus offset
forthsamp({addr}).}) _BITS32_({ the offset forthsamp({addr}) at
selector forthsamp({u}) .}) },
{{L!},{@},{C@},{2@}},
{{." No test"},{No test} },
enddoc)
CODE_HEADER({L@},{LFET})
        POP     BX      ;MEM LOC
        POP     CX      ;SEG REG VAL
_BITS16_({_SWITCH_({ JMPHERE_FROM_PROT},{dnl})},{dnl})
        MOV     DX,DS   ;{ Leave this for real mode code.}
        MOV     DS,CX
        MOV     BX,[BX]
        MOV     DS,DX
_BITS16_({_SWITCH_({ JMPHERE_FROM_REAL},{dnl})},{dnl})
        PUSH    BX
        _NEXT
;
worddoc( {MEMORY},{L!},{long_store},{n u addr --- },{},
{Store _BITS_ bits of forthvar({n}) at address
forthsamp({u:addr}),
_BITS16_({ the real mode segment plus offset
forthsamp({addr}).}) _BITS32_({ the offset forthsamp({addr}) at
selector forthsamp({u}) .}) },
{{L@},{!},{C!},{2!}},
{{." No test"},{No test} },
enddoc)
CODE_HEADER({L!},{LSTORE})
        POP     BX
        POP     CX
        POP     DX
_BITS16_({_SWITCH_({ JMPHERE_FROM_PROT},{dnl})},{dnl})
        MOV     AX,DS
        MOV     DS,CX
        MOV     [BX],DX
        MOV     DS,AX
_BITS16_({_SWITCH_({ JMPHERE_FROM_REAL},{dnl})},{dnl})
        _NEXT
;
});_END_({_LOAD_})
worddoc( {DEFINING},{:},{colon},{},{ISO,FIG,E,L0},
{Used in the form called a colon-definition:
forthexample({: cccc     ...     ;})
Creates a dictionary entry defining forthsamp({cccc}) as equivalent to the
following sequence of Forth word definitions '...' until the next
forthcode({';'}) or forthcode({';CODE'}). The word is added as the latest
into the forthcode({CURRENT}) word list.
The compiling process is done by the text interpreter as long as
forthcode({STATE}) is non-zero.
Words with the immediate bit
set (I) are executed rather than being compiled.},{},
{{: GS1 1 2 3 ; GS1 . . .},{3 2 1} },
enddoc)
HEADER({:},{COLON},{DOCOL})
        _SECURITY_({DC      SCSP})
        DC      LPWORD
        DC      PCREAT
        DC      LATEST, HIDDEN
        DC      RBRAC
        DC      PSCOD
DOCOL:  LEA     RPO,[RPO - _CELLS(1)]
        MOV     [RPO],HIP ;{R1 <- (IP)}
         MOV     HIP,[WOR+_CELLS(D_HOFFSET - C_HOFFSET)]  ;{(IP) <- (PFA)}
;        CALL    DISPLAYSI
_SWITCH_({
        _SWITCH_({JMPHERE_FROM_FORTH})
        ;{ Allow interrupts to happen.}
        _SWITCH_({JMPHERE_FROM_OS})
});_END_({ _SWITCH_})
        _NEXT
;
worddoc( {DEFINING},{;},{semicolon},{},{ISO,FIG,I,C,L0},
{Terminate a colon-definition and stop further compilation. Compiles
the run-time forthcode({EXIT}) .},{{:}},
{{." Via :"},{Via :}},
enddoc)
HEADER({;},{SEMI},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCSP})
        DC      LIT, SEMIS, COMMA
        DC      LATEST, HIDDEN
        DC      LBRAC
        DC      SEMIS
;
worddoc( {DEFINING},{CONSTANT},{constant},{n ---},{ISO,FIG,L0},
{A defining word used in the form:
    forthvar({n}) forthcode({CONSTANT}) forthsamp({cccc})
to create word forthsamp({cccc}) , with its data field containing
forthsamp({n}) . When forthsamp({cccc}) is later executed, it
will push the value of forthsamp({n}) to the stack.},
{{VARIABLE}},
{{12A CONSTANT FRED FRED .},{12A} },
enddoc)
HEADER({CONSTANT},{LCONST},{DOCOL})
        DC      LPWORD
        DC      PCREAT
        DC      LATEST, TDFA, STORE
        DC      PSCOD
DOCON:  MOV     AX,[WOR+_CELLS((D_HOFFSET-C_HOFFSET))] ;{GET DATA FROM PFA}
        _PUSH
;
worddoc( {DEFINING},{VARIABLE},{variable},{},{ISO,E,LU},
{A defining word used in the form:
                 forthsamp({VARIABLE cccc})
When forthcode({VARIABLE}) is executed, it creates the definition forthsamp({cccc}) with its
data field pointing to a data location.
When forthsamp({cccc}) is later executed, the
content of its data field (containing forthvar({n}) ) is left on the stack,
so that a fetch or store may access this location.},{{USER},{CONSTANT}},
{{ VARIABLE APE 1A34 APE ! APE @ .},{1A34} },
enddoc)
HEADER({VARIABLE},{VAR},{DOCOL})
        DC      LPWORD
        DC      PCREAT
        DC      ZERO, COMMA
        DC      PSCOD
DOVAR:  MOV     AX,[WOR+_CELLS((D_HOFFSET-C_HOFFSET))] ;{(AX) <- PFA}
        _PUSH
;
worddoc( {DEFINING},{USER},{user},{n ---},{ISO,L0},
{A defining word used in the form:
               forthsamp({n USER cccc})
which creates a user variable forthsamp({cccc}) . The data
field of forthsamp({cccc}) contains forthvar({n}) as a fixed
offset relative to the user pointer register forthsamp({UP})
for this user variable. When forthsamp({cccc}) is later
executed, it places the sum of its offset and the user area
base address on the stack as the storage address of that
particular variable. In ciforth the forthsamp({UP}) is fixed.
},
{{VARIABLE},{+ORIGIN}},
{{ 0 USER APE 1A34 APE ! APE @ .},{1A34} },
enddoc)
HEADER({USER},{USER},{DOCOL})
        DC      LCONST
        DC      PSCOD
DOUSE:  MOV     BX,[WOR+_CELLS((D_HOFFSET-C_HOFFSET))] ;{PFA  }
        MOV     DI,_CELL_PTR[USINI]
        LEA     AX,[BX+DI]      ;{ADDR OF VARIABLE}
        _PUSH
;
worddoc( {SUPERFLUOUS},{0},{zero},{--- 0},{},
{Leave the number 0. },{{CONSTANT}},
{{0 .},{0}},
enddoc)
CODE_HEADER({0},{ZERO})
        XOR     AX,AX
        _PUSH
;
worddoc( {SUPERFLUOUS},{1},{one},{--- 1},{},
{Leave the number 1. },{{CONSTANT}},
{{1 .},{1}},
enddoc)
CODE_HEADER({1},{ONE})
        MOV     AX,1
        _PUSH
;
worddoc( {SUPERFLUOUS},{2},{two},{--- 2},{},
{Leave the number 2. },{{CONSTANT}},
{{2 .},{2}},
enddoc)
CODE_HEADER({2},{TWO})
        MOV     AX,2
        _PUSH
;
worddoc( {STRING},{BL},{BL},{--- c},{ISO.FIG},
{ A constant that leaves the
   ascii value for "blank".},{},
{{BL .},{20}},
enddoc)
HEADER({BL},{LBL},{DOCON}, ABL)
;
worddocsafe( {STRING},{$@},{string_fetch},{addr --- sc},{},
{ From address forthvar({addr}) fetch a string constant forthvar({sc}) .},
{{$@},{$!},{$+!},{$C+}},
{{ HEX 4 , 41 C, 39 C, 45 C, 30 C, HERE 4 CELL+ - $@ TYPE},{A9E0}}, enddoc)
HEADER({$@},{SFET},{DOCOL})
        DC LDUP, CELLP, SWAP, FETCH
        DC SEMIS
;
worddoc( {STRING},{$!},{string_store},{sc addr --- },{},
{Store a string constant forthvar({sc})
in the string variable at address forthvar({addr}).},
{{$@},{$+!},{$C+}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - $@ PAD $! PAD $@ TYPE},{A9}}, enddoc)
HEADER({$!},{SSTOR},{DOCOL})
        DC TDUP, STORE, CELLP, SWAP, LCMOVE
        DC SEMIS
;
worddoc( {STRING},{$!-BD},{string_store_brain_damaged},{sc addr --- },{},
{Store a string constant forthvar({sc}) in the
forthdefi({old fashioned}) string variable at address
forthvar({addr}), i.e. it can be fetched with
forthcode({COUNT}). _VERBOSE_({{ (Where would that BD come
from?)}})},
{{COUNT},{$!}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - $@ PAD $!-BD PAD COUNT TYPE},{A9}}, enddoc)
HEADER({$!-BD},{SSTORBD},{DOCOL})
        DC TDUP, CSTOR, ONEP, SWAP, LCMOVE
        DC SEMIS
;
worddoc( {STRING},{$+!},{string_append},{sc addr --- },{},
{Append a string constant forthvar({sc})
to the string variable at address forthvar({addr}).},
{{$@},{$!},{$C+}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - dnl
$@ 2DUP PAD $! PAD $+! PAD $@ TYPE},{A9A9}}, enddoc)
HEADER({$+!},{SPTOR},{DOCOL})
        DC   LDUP, FETCH, TOR ;{ Remember old count.}
        DC   TDUP, PSTORE
        DC   CELLP, FROMR, PLUS, SWAP, LCMOVE
        DC SEMIS
;
worddoc( {STRING},{$C+},{char_append},{ch addr --- },{},
{Append a char forthsamp({ch})
to the string variable at address forthvar({addr}).},
{{$@},{$!},{$+!}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ -  dnl
$@ PAD $! HERE 1 - C@ PAD $C+ PAD $@ TYPE},{A99}}, enddoc)
HEADER({$C+},{CHAPP},{DOCOL})
        DC   LDUP, TOR
        DC   LDUP, FETCH, PLUS, CELLP, CSTOR
        DC   ONE, FROMR, PSTORE
        DC SEMIS
;
worddocsafe( {STRING},{$,},{string_comma},{sc --- addr},{},
{Allocate and store a string constant forthvar({sc})
in the dictionary and leave its address forthvar({addr}).},
{{$@},{$!},{}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - $@ $, $@ TYPE},{A9}}, enddoc)
HEADER({$,},{SCOMMA},{DOCOL})
        DC HERE, TOR
        DC LDUP, CELLP, ALLOT
        DC RR, SSTOR, FROMR
_ALIGNED_({ DC LALIGN}, {dnl})
        DC SEMIS
;
worddoc( {SCREEN},{C/L},{char_per_line},{--- c},{},
{A constant that leaves the number of characters on a line of a
standard screen: 64. The last character of each line is a forthkey({LF}). },
{{LIST},{LINE}},
{{C/L .},{40}},
enddoc)
HEADER({C/L},{CSLL},{DOCON}, 64)
;
_HIGH_BUF_({
worddoc( {STORAGE~},{FIRST},{first},{--- n},{},
{A constant that leaves the address of the first (lowest) block
buffer.},
{{BLOCK},{LIMIT}},
{{LIMIT FIRST - B/BUF 2 CELLS + /MOD #BUFF = .},{_T_}},
enddoc)
HEADER({FIRST},{FIRST},{DOCON}, BUF1)
});_END_({ _HIGH_BUF_})
;
_LOW_BUF_({
        _ALIGN  2       ; Otherwise INT 13 hangs when filling
        ; in into the lba block as a buffer address.
        DB      0       ;{Padding the odd # of bytes in the name FIRST.}
worddoc( {STORAGE~},{FIRST},{first},{--- n},{},
{A constant that leaves the address of the first (lowest) block
buffer.
This is allocated in the lowest 1 Megabyte of memory,
to allow the BIOS to access it.
},{{BLOCK},{LIMIT}},
{{LIMIT FIRST - B/BUF 2 CELLS + /MOD DROP #BUFF = .},{_T_}},
enddoc)
HEADER({FIRST},{FIRST},{DOVAR}, BUF1)
BUF1:   _RESB( (KBBUF+2*CW)*NBUF )
});_END_({ _LOW_BUF_})
;
worddoc( {STORAGE~},{LIMIT},{limit},{---- n},{},
{A constant leaving the address just above the highest memory
available for a disc buffer.
_HIGH_BUF_({Actually this is the highest system memory.})
},{{BLOCK},{FIRST}},
{{." See FIRST"},{See FIRST}},
enddoc)
HEADER({LIMIT},{LIMIT},{DOCON}, BUF1+(KBBUF+2*CW)*NBUF)
;{ THE END  OF THE MEMORY }
worddoc( {MEMORY},{EM},{end_memory},{---- addr},{},
{A constant leaving the address just above the highest memory
in use by Forth.
},{{DP},{BM}},
{{." See FIRST"},{See FIRST}},
enddoc)
HEADER({EM},{LEM},{DOCON}, ACTUAL_EM)
;
worddoc( {MEMORY},{BM},{begin_memory},{---- addr},{},
{A constant leaving the address of the lowest memory
in use by Forth.
},{{DP},{EM}},
{{." No test"},{No test} },
enddoc)
HEADER({BM},{LBM},{DOCON}, ORG0)
;
worddoc( {STORAGE},{B/BUF},{bytes_per_buf},{--- n},{},
{This constant leaves the number of bytes per disc buffer, the byte
count read from disc by forthcode({BLOCK}) .
The ISO standard fixes this to 1024.},{{(BUFFER)}},
{{B/BUF .},{400}},
enddoc)
HEADER({B/BUF},{BBUF},{DOCON}, KBBUF)
;
;{ All user variables are initialised }
;{ with the values from USINI.}
;{ The implementation relies on the initialisation of }
;{ those with numbers (1..11), so change in concord with USINI.}
worddoc( {MISC},{U0},{u_zero},{--- addr},{},
{A user variable, leaving the start address of the user area. This is
for reference only. What is taken into account by user variables is
the initialisation variable at forthsamp({0 +ORIGIN}) .
This is dependant on which task is running.},
{{USER},{+ORIGIN}},
{{U0 @ 0 +ORIGIN @ = .},{_T_}},
enddoc)
HEADER({U0},{UZERO},{DOUSE}, _CELLS(1))
;
worddoc( {STACKS},{S0},{s_zero},{--- addr},{U},
{A user variable that contains the initial value for the data stack
pointer.},{{DSP!}},
{{." See DSP@"},{See DSP@}},
enddoc)
HEADER({S0},{SZERO},{DOUSE}, _CELLS(2))
;
worddoc( {STACKS},{R0},{r_zero},{--- addr},{U},
{A user variable containing the initial location of the return stack. },
{{RSP!}},
{{." See RSP@"},{See RSP@}},
enddoc)
HEADER({R0},{RZERO},{DOUSE}, _CELLS(3))
;
worddoc( {INPUT},{TIB},{t_i_b},{--- addr},{ISO,FIG,U},
{A user variable containing the address of the terminal input buffer.},
{{QUIT}},
{{." See SRC"},{See SRC}},
enddoc)
HEADER({TIB},{TIB},{DOUSE}, _CELLS(4))
;
worddoc( {INPUT},{RUBOUT},{rub_out},{--- c},{},
{A user variable, leaving the key code that must delete the
last character from the input buffer.
_HOSTED_({In this ciforth it is not used, as the terminal input
editing is left to the host operating system.})
},{{USER}},
{{." interactive"},{interactive}},
enddoc)
HEADER({RUBOUT},{RUBOUT},{DOUSE}, _CELLS(5))
;
worddoc( {ERRORS},{WARNING},{warning},{--- addr},{FIG,U},
{A user variable containing a value controlling messages. If it
is 1, a screen system is present, and forthcode({ERRSCR}) contains
the base
location for messages. If it is 0, no such screen system is
present and messages will be presented by number.
If forthcode({WARNING}) is set to 0 and there are disk
problems: nothing will be printed in case of disk errors, not
even that there is a disk error ( because forthcode({ERROR})
uses forthcode({MESSAGE}) ).
},
{{MESSAGE},{ERROR}},
{{." See MESSAGE"},{See MESSAGE}},
enddoc)
HEADER({WARNING},{LWARN},{DOUSE}, _CELLS(7))
;
worddoc( {DICTIONARY~},{FENCE},{fence},{---  addr},{FIG,U},
{A user variable containing an address below which forthcode({FORGET}) ting is
trapped. To forget below this point the user must alter the contents
of forthcode({FENCE}) .},{},
{{." interactive"},{interactive}},
enddoc)
HEADER({FENCE},{FENCE},{DOUSE}, _CELLS(8))
;
worddoc( {DICTIONARY},{DP},{d_P},{---- addr},{FIG,U,L},
{A user variable, the dictionary pointer, which contains the address
of the next free memory above the dictionary. The value may be read
by forthcode({HERE}) and altered by forthcode({ALLOT}) .},{},
{{HERE DP @ = .},{_T_}},
enddoc)
HEADER({DP},{LDP},{DOUSE}, _CELLS(9))
;
worddoc( {WORDLISTS~},{VOC-LINK},{voc_link},{--- addr},{U},
{A user variable containing the forthdefi({dictionary entry
address}) of the word most recently created by
forthcode({VOCABULARY}) . _VERBOSE_({All vocabulary names are
linked by these fields to allow forthcode({FORGET}) to find all
vocabularies.})},
{{VOCABULARY}},
{{VOC-LINK @ ' ENVIRONMENT = .},{_T_}},
enddoc)
HEADER({VOC-LINK},{VOCL},{DOUSE}, _CELLS(10))
;
worddoc( {STORAGE~},{OFFSET},{offset},{--- addr},{U},
{A user variable which contains a block offset to disc drives;
in this way a part of it is available for boot-code.
_HOSTED_MSDOS_({As blocks are allocated in a file on the host operating system it is 0.})
_HOSTED_LINUX_({As blocks are allocated in a file on the host operating system it is 0.})
The
contents of forthcode({OFFSET}) is added to the stack number by forthcode({BLOCK}) before calling
forthsamp({R/W}). },
{{BLOCK},{MESSAGE} },
{{OFFSET @ 1000 U< .},{_T_}},
enddoc)
HEADER({OFFSET},{LOFFSET},{DOUSE}, _CELLS(11))
;
;{ End of user variables with fixed place.}
;
;
worddoc( {ERRORS},{WHERE},{where},{--- addr},{U},
{A user variable pair which contains the start of the source and the
character position of the last error that was thrown by
forthcode({?ERROR}) _VERBOSE_({,so not of exceptions thrown}).
The contents of forthcode({WHERE}) is interpreted by
forthcode({ERROR}) if the corresponding exception was never
caught. },
{{THROW},{CATCH} },
{{"1 12 ?ERROR" 2DUP 'EVALUATE CATCH DROP 2DROP + WHERE 2@ DROP = .},{_T_}},
enddoc)
HEADER({WHERE},{LWHERE},{DOUSE}, _CELLS(12))    ; { Occupies two CELLS! }
;
worddoc( {SCREEN},{SCR},{s_c_r},{--- addr},{U},
{A user variable containing the screen number most recently reference
by forthcode({LIST}) .},{{BLOCK}},
{{." interactive"},{interactive}},
enddoc)
HEADER({SCR},{SCR},{DOUSE}, _CELLS(33))
;
worddoc( {PARSING},{STATE},{state},{--- addr},{ISO,L0,U},
{A user variable containing the compilation state. A non-zero value
indicates compilation.},{},
{{STATE @ .},{0},
{ : GT8 STATE @ 0= . ; IMMEDIATE : GT7 GT8 ; GT7},{0}},
enddoc)
HEADER({STATE},{STATE},{DOUSE}, _CELLS(18))
;
worddoc( {FORMATTING},{BASE},{base},{--- addr},{ISO,FIG,U,L0},
{A user variable containing the current number base used for input
and output conversion.},
{{DECIMAL},{HEX},{<#}},
{{DECIMAL BASE @ 16 BASE ! .},{A}},
enddoc)
HEADER({BASE},{BASE},{DOUSE}, _CELLS(19))
;
worddoc( {FORMATTING~},{DPL},{d_p_l},{---- addr},{FIG,U,L0},
{A user variable containing the address of the decimal point on
double integer input, or a nil pointer. It may also be used to
hold output column location of a decimal point, in user
generated formating. },
{{<#},{FLD},{HLD}},
{{1234.56 DPL @ 0= .},{0}},
enddoc)
HEADER({DPL},{DPL},{DOUSE}, _CELLS(20))
;
worddoc( {FORMATTING~},{FLD},{f_l_d},{--- addr},{FIG,U},
{A user variable for control of number output field width.
Unused in the kernel of ciforth.},
{},
{{." No test"},{No test} },
enddoc)
HEADER({FLD},{LFLD},{DOUSE}, _CELLS(21))
;
_SECURITY_({
worddoc( {SECURITY},{CSP},{c_s_p},{---- addr},{U},
{A user variable temporarily storing the stack pointer position, for
compilation error checking.},{},
{{1256 CSP ! CSP @ .},{1256}},
enddoc)
HEADER({CSP},{LCSP},{DOUSE}, _CELLS(22))
;
});_END_({_SECURITY_})
worddoc( {SCREEN},{R#},{r_hash},{--- addr},{U},
{A user variable which may contain the location of an editing cursor,
or other file related function.
Unused in the kernel of ciforth.},
{},
{{." No test"},{No test} },
enddoc)
HEADER({R#},{RNUM},{DOUSE}, _CELLS(23))
;
worddoc( {FORMATTING~},{HLD},{hld},{--- addr},{FIG,L0},
{A user variable that holds the address of the latest character of
text during numeric output conversion.},
{{<#},{DPL},{FLD}},
{{." No test"},{No test} },
enddoc)
HEADER({HLD},{HLD},{DOUSE}, _CELLS(24))
;
worddoc( {OUTPUT},{OUT},{OUT},{--- addr},{U},
{A user variable that reflects the position at the current line
of the output device where the next character transmitted will
appear. The first position is zero. Only an explicit
forthcode({CR}) will reset forthcode({OUT}) , not an
forthkey(LF) embedded in a string that is forthcode({TYPE})d.},
{{EMIT},{TYPE},{CR}},
{{41 EMIT 42 EMIT OUT @ .},{AB2}},
enddoc)
HEADER({OUT},{LOUT},{DOUSE}, _CELLS(25))
;
worddocsafe( {STORAGE~},{(BLK)},{paren_blk},{--- addr},{U},
{When the standard word forthcode({BLK}) is used, this user variable
reflects the state of the forthsamp({current input source}).
It indicates the block number being interpreted, or
zero, if input is being taken from the terminal input buffer.
Changing forthcode({BLK}) has no effect, and its content must be fetched before
the forthdefi({current input source}) has changed.},
{{BLOCK},{TIB}},
{{BLK (BLK) @ .},{0}},
enddoc)
HEADER({(BLK)},{PBLK},{DOUSE}, _CELLS(26))
;
worddoc( {INPUT},{IN},{in},{--- addr},{},
{A user variable containing a pointer within the current input
text buffer (terminal or disc) from which the next text will be
accepted. All parsing words use and move the value of forthcode({IN}) .},
{{>IN},{WORD},{(WORD)},{NUMBER},{(PARSE)},{IN[]}},
{{: GS1 IN @ IN[] 2DROP IN @ - ; GS1 Q .},{-1}},
enddoc)
HEADER({IN},{LIN},{DOUSE}, _CELLS(29))
;
_LOAD_({
worddocsafe( {INPUT~},{(>IN)},{paren_iso_in},{--- addr},{},
{If the standard word forthcode({>IN}) is used, this variable
contains the offset from the start
within the current input
text buffer (terminal or disc) from which the next text will be
accepted. All parsing words use and move the value of forthcode({IN}) .},
{{>IN},{IN}},
{{." See >IN"},{See >IN}},
enddoc)
HEADER({(>IN)},{PIIN},{DOUSE}, _CELLS(30))
;
});_END_({_LOAD_})
worddoc( {OPERATINGSYSTEM},{ARGS},{arguments},{--- addr},{},
{ Return the addr of forthcode({ARGS}) a user variable that
contains a system dependant pointer to any arguments that are
passed from the operating system to ciforth during startup.}
_LINUX_N_({{
In this ciforth it points to an area with the argument count,
followed by a a null ended array of arguments strings,
then by a null ended array of environment strings.
}});_END_({_LINUX_N_})
,
{{SYSTEM}},
{{." Interactive"},{Interactive}},
enddoc)
HEADER({ARGS},{ARGS},{DOUSE}, _CELLS(31))
;
worddoc( {ERRORS~},{HANDLER},{handler},{--- addr},{},
{A user variable address containing a pointer to the
last exception intercepting frame activated by forthcode({CATCH}) .
It points into the return stack.
If there is a forthcode({THROW}), the return stack
is restored from forthcode({HANDLER}) effecting a multiple level return.
It is called a frame because more things are restored, such as the
position of the data stack top, and the previous value of forthsamp({HANDLER})},
{{CATCH},{THROW}},
{{." See CATCH"},{See CATCH}},
enddoc)
HEADER({HANDLER},{HANDLER},{DOUSE}, _CELLS(32))
;
worddoc( {WORDLISTS},{CURRENT},{current},{--- addr},{FIG,U,L0},
{A user variable containing the WID of a vocabulary to which
new words will be added. The WID has the structure of a
dictionary entry. This allows to link in a new word between the
link field of the WID and the next definition. _VERBOSE_({It is
the forthdefi({compilation word list}) in the sens of the ISO
standard.})
},
{{VOCABULARY},{SEARCH-ORDER}},
{{CURRENT @ ' FORTH >WID = .},{_T_}},
enddoc)
HEADER({CURRENT},{CURR},{DOUSE}, _CELLS(34))
;
worddoc( {INPUT~},{REMAINDER},{remainder},{--- addr},{},
{A pointer to a constant string that contains the balance of
characters fetched into the input buffer, but not yet consumed.
Used as in forthsamp({REMAINDER 2@}) .
},
{{REFILL-TIB}},
{{REMAINDER 2@ ( TYPE)},{}},
enddoc)
HEADER({REMAINDER},{REMAIND},{DOUSE}, _CELLS(14))
;      IMPORTANT
; REQUIRES ONE MORE CELL!
;
worddoc( {WORDLISTS},{SEARCH-ORDER},{search_order},{--- addr},{FIG,U,L0},
{ The current search order is a zero ended row of WID 's found
at an area in the user space forthvar({addr}) . The
corresponding wordlists are searched for definitions during
interpretation. At most M4_MAXWORDLIST WID 's are present in
this ciforth, while the ISO Search-Order wordset requires at
least 8. },
{{FOUND},{VOCABULARY},{CURRENT}},
{{SEARCH-ORDER @ ' FORTH >WID = .},{_T_}},
enddoc)
HEADER({SEARCH-ORDER},{SEARCH},{DOUSE}, _CELLS(37)) ;{ Up to } 37+M4_MAXWORDLIST
;      IMPORTANT
;     M4_MAXWORDLIST USER SPACE CELLS MUST BE KEPT FREE
;     IN ADDITION TO THE ONE FOR SEARCH
;
;{========== END USER VARIABLES =============;}
;
worddoc( {SUPERFLUOUS},{1+},{one_plus},{n1 --- n2},{L1},
{Shorthand for ``forthsamp({1}) forthcode({+})''.},
{{CELL+},{1-}},
{{5 1+ .},{6}},
enddoc)
CODE_HEADER({1+},{ONEP})
        POP     AX
        INC     AX
        _PUSH
;
worddoc( {MEMORY},{CELL+},{cell_plus},{n1 --- n2},{ISO},
{Advance the memory pointer forthvar({n1}) by one (in this case  _BITS_ bits) cell to
forthvar({n2}). _VERBOSE_({{This is invaluable for writing portable
code. Many of the screens of ciforth run on both 16 and 32 bits
systems, thanks to this.}})
},{},
_BITS32_({{{0 CELL+ .},{4}},})dnl expanded before worddoc is!
_BITS16_({{{0 CELL+ .},{2}},})dnl
enddoc)
CODE_HEADER({CELL+},{CELLP})
        POP     AX
        ADD     AX,CW
        _PUSH
;
worddoc( {MEMORY},{CELLS},{cells},{n1 --- n2},{ISO},
{Return the equivalent of forthvar({n1}) cells in bytes:
forthvar({n2}). _VERBOSE_({{This is invaluable for writing portable
code. Many of the screens of ciforth run on both 16 and 32 bits
systems, thanks to this.}})
},{{CELL+}},
_BITS32_({{{2 CELLS .},{8}},})dnl expanded before worddoc is!
_BITS16_({{{2 CELLS .},{4}},})dnl expanded before worddoc is!
enddoc)
;
CODE_HEADER({CELLS},{LCELLS})
        POP     AX
        SHL     AX,1
        _BITS32_({SHL     AX,1})
        _PUSH
;
worddoc( {MEMORY},{CHAR+},{char_plus},{n1 --- n2},{ISO},
{Advance the memory pointer forthvar({n1}) by one character to
forthvar({n2}). In ciforth this means one byte. Bytes are the
address units ISO is talking about. _VERBOSE_({Unfortunately
the ISO standard confounds characters and bytes.})
},{{CELL+}},
{{123 CHAR+ .},{124}},
enddoc)
HEADER({CHAR+}, {CHARP}, {_VAR_FIELD(ONEP)})
;
worddoc( {MEMORY},{CHARS},{chars},{n1 --- n2},{ISO},
{Return the equivalent of forthvar({n1}) chars in bytes:
forthvar({n2}). In ciforth this is a noop.
_VERBOSE_({Unfortunately
the ISO standard confounds characters and bytes.})
},{{CELLS}},
{{123 CHARS .},{123}},
enddoc)
HEADER({CHARS}, {CHARS}, {DOCOL}, , {B_IMMED})
        DC      SEMIS
;
worddoc( {MEMORY},{ALIGN},{align},{ --- },{ISO},
{Make sure that forthcode({HERE}) is forthdefi({aligned}) by advancing
it if necessary. This means that data of any size can be fetched
from that address.
In this ciforth this is a noop.
},{{ALIGNED}},
_ALIGNED_({
{{ 1 ALLOT ALIGN HERE 0 CELL+ MOD . },{0}}
}),
enddoc)
HEADER({ALIGN}, {LALIGN}, {DOCOL}, , {B_IMMED})
_ALIGNED_({
        DC      LDP, FETCH
        DC      ALIGNED
        DC      LDP, STORE
},{dnl});_END_({_ALIGNED_})
        DC      SEMIS
;
worddoc( {MEMORY},{ALIGNED},{aligned},{ad1 --- ad2},{ISO},
{Make sure that forthsamp({ad1}) is forthdefi({aligned}) by advancing
it if necessary to forthsamp({ad2}).
In this ciforth this is a noop.
},{{ALIGN}},
_ALIGNED_({
{{ 4 ALIGNED .},{4},
{5 ALIGNED . },{8}}
}),
enddoc)
CODE_HEADER({ALIGNED}, {ALIGNED}, {DOCOL})
_ALIGNED_({
        POP     AX
        DEC     AX
        OR      AL,3
        INC     AX
        PUSH    AX
},{dnl});_END_({_ALIGNED_})
        _NEXT
;
worddoc( {DICTIONARY},{HERE},{here},{--- addr},{ISO,FIG,L0},
{Leave the address forthvar({addr}) of the next available
dictionary location.},
{{DP}},
{{HERE 896 ALLOT HERE SWAP - .},{896}},
enddoc)
HEADER({HERE},{HERE},{DOCOL})
        DC      LDP
        DC      FETCH
        DC      SEMIS
;
worddoc( {DICTIONARY},{ALLOT},{allot},{n ---},{ISO,FIG,L0},
{Add the signed number to the dictionary pointer forthcode({DP}) . May be used to
reserve dictionary space or re-origin memory. As the Pentium is a byte-addressable
machine forthvar({n}) counts bytes. },{{CELL+}},
{{." Via HERE"},{Via HERE}},
enddoc)
HEADER({ALLOT},{ALLOT},{DOCOL})
        DC      LDP
        DC      PSTORE
        DC      SEMIS
;
worddocsafe( {DICTIONARY},{,},{comma},{n ---},{ISO,FIG,L0},
{Store forthvar({n}) into the next available dictionary memory cell, advancing
the dictionary pointer.},{{DP},{C,}},
{{HERE 625 , DUP @ . CELL+ HERE = .},{625 _T_}},
enddoc)
HEADER({,},{COMMA},{DOCOL})
        DC      HERE
        DC      STORE
        DC      LCELL
        DC      ALLOT
        DC      SEMIS
;
worddocsafe( {DICTIONARY},{C,},{c_comma},{b ---},{ISO,FIG},
{Store 8 bits of forthcode({b}) into the next available dictionary byte, advancing
the dictionary pointer. },{{DP},{,}},
{{HERE 62 C, DUP C@ . 1+ HERE = .},{62 _T_}},
enddoc)
HEADER({C,},{CCOMM},{DOCOL})
        DC      HERE
        DC      CSTOR
        DC      ONE
        DC      ALLOT
        DC      SEMIS
;
worddoc( {OPERATOR},{-},{minus_sign},{n1 n2 --- diff},{ISO,FIG,L0},
{Leave the difference of forthvar({n1}) and forthvar({n2}) .},
{{NEGATE},{+},{*},{/},{MOD}},
{ { 0A BASE !  240 204 - .},{36} },
{}, enddoc)
CODE_HEADER({-},{LSUB})
        POP     DX      ;{S1}
        POP     AX
        SUB     AX,DX
        _PUSH   ;{S1 = S2 - S1}
;
worddoc( {LOGIC},{=},{equals},{n1 n2 --- f},{ISO,FIG,L0},
{Leave a true flag if forthsamp({n1=n2}) ; otherwise leave a false flag.},
{{<},{>},{0=},{-}},
{ { 0A BASE !  240 204 = .},{0},
  { 240 240 = .},{_T_} },
enddoc)
HEADER({=},{EQUAL},{DOCOL})
        DC      LSUB
        DC      ZEQU
        DC      SEMIS
;
worddoc( {LOGIC},{<},{less_than},{n1 n2 --- f},{L0,ISO},
{Leave a true flag if forthvar({n1}) is less than forthvar({n2}) ;otherwise leave a false
flag.},{{=},{>},{0<}},
{{1 2 < .},{_T_},
 {-1 -2 < .},{0},
 {0 -1 < .},{0},
 {1 1 < .},{0} },
enddoc)
CODE_HEADER({<},{LESS})
        POP     DX      ;{S1}
        POP     BX      ;{S2}
        XOR     AX,AX   ;{0 dEFAULT RESULT}
        CMP     BX,DX
        JNL     LES1
        DEC     AX
LES1:   _PUSH
;
worddoc( {LOGIC},{U<},{u_less_than},{u1 u2 --- f},{ISO,L0},
{Leave a true flag if forthvar({u1}) is less than forthvar({u2}) ; otherwise leave a false
flag.(Interpreted as unsigned numbers).},{{<}},
{{1 2 U< .},{_T_},
 {-1 -2 U< .},{0},
 {0 -1 U< .},{_T_},
 {1 1 U< .},{0} },
enddoc)
CODE_HEADER({U<},{ULESS})
        POP     AX
        POP     DX
        SUB     DX,AX
        SBB     AX,AX
        _PUSH
;
worddoc( {LOGIC},{>},{greater_than},{n1 n2 --- f},{ISO,L0},
{Leave a true flag if forthvar({n1}) is greater than
forthvar({n2}) ; otherwise a false flag.},
{{<},{=},{0<}},
{{1 2 > .},{0},
 {-1 -2 > .},{_T_},
 {0 -1 > .},{_T_},
 {1 1 > .},{0} },
enddoc)
HEADER({>},{GREAT},{DOCOL})
        DC      SWAP
        DC      LESS
        DC      SEMIS
;
worddoc( {LOGIC},{<>},{unequal},{n1 n2 --- f},{ISO,L0},
{Leave a true flag if forthvar({n1}) is not equal than
forthvar({n2}) ; otherwise a false flag.},
{{>},{=},{0<}},
{{1 2 <> .},{_T_},
 {-1 -2 <> .},{_T_},
 {0 -1 <> .},{_T_},
 {1 1 <> .},{0} },
enddoc)
HEADER({<>},{UNEQ},{DOCOL})
        DC      LSUB
        DC      ZEQU
        DC      ZEQU
        DC      SEMIS
;
worddoc( {JUGGLING},{ROT},{rot},{nl n2 n3 --- n2 n3 nl},{ISO,FIG,L0},
{Rotate the top three values on the stack, bringing the third to the
top.},{{SWAP}},
{{S0 @ DSP! 1 2 3 4 ROT .S},{
S[  1 3 4 2 ]} },
enddoc)
CODE_HEADER({ROT},{ROT})
        POP     DX      ;{S1}
        POP     BX      ;{S2}
        POP     AX      ;{S3}
        PUSH    BX
        _2PUSH
;
worddoc( {OUTPUT},{SPACE},{space},{},{ISO,FIG,L0},
{Transmit an ascii blank to the output device.},{{EMIT},{OUT}},
{{41 EMIT SPACE 41 EMIT},{A A}},
enddoc)
HEADER({SPACE},{SPACE},{DOCOL})
        DC      LBL
        DC      EMIT
        DC      SEMIS
;
worddoc( {JUGGLING},{?DUP},{question_dupe},
{n1 --- n1 (if zero) / n1 --- n1 n1 (non-zero)},{ISO,FIG,L0},
{Reproduce forthvar({n1}) only if it is non-zero. This is
usually used to copy a value just before forthcode({IF}) , to
eliminate the need for an forthcode({ELSE}) part to drop
it.},{{DUP}},
{{S0 @ DSP!  1 2 3 4 ?DUP .S},{
S[  1 2 3 4 4 ]},
{S0 @ DSP! 1 2 3 0 ?DUP .S},{
S[  1 2 3 0 ]} },
enddoc)
HEADER({?DUP},{QDUP},{DOCOL})
        DC      LDUP
        _0BRANCH(QDUP1) ;{ IF}
        DC      LDUP    ;{THEN}
QDUP1:  DC      SEMIS
;
worddoc( {WORDLISTS},{LATEST},{latest},{--- addr},{FIG},
{Leave the dictionary entry address forthvar({addr}) of the
topmost word in the forthcode({CURRENT}) word list.},
{{VOCABULARY}},
{{: APE ;  LATEST ID.},{APE}},
enddoc)
HEADER({LATEST},{LATEST},{DOCOL})
        DC      CURR
        DC      FETCH
        DC      TLFA
        DC      FETCH
        DC      SEMIS
;
worddoc( {DICTIONARY~},{>CFA},{to_code_field_address},{dea --- cfa},{},
{Given a dictionary entry addres forthvar({dea}) return its
forthdefi({code field address}) forthvar({cfa}) : the address
that is compiled within high level definitions. It serves as an
execution token as well. In ciforth this is actually the same
as the forthdefi({DEA}) .},
{{'},{CFA>},{>DFA},{>FFA},{>LFA},{>NFA},{>SFA},{>PHA}},
{{' WORD  DUP >CFA = .},{_T_}},
enddoc)
HEADER({>CFA},{TCFA},{DOCOL})
        DC      LIT, _CELLS(C_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc( {DICTIONARY~},{>DFA},{to_data_field_address},{dea --- dfa},{},
{Given a dictionary entry addres return its forthdefi({data
field address}) forthvar({dfa}) . This points to the code for a
code word, to the high level code for a colon-definition, and
to the forthcode({DOES>}) pointer for a word build using
forthcode({CREATE}) . Normally this is the area behind the
header, found via forthcode({>PHA}) . },
{{'},{>CFA},{>FFA},{>LFA},{>NFA},{>SFA},{>PHA}},
{{ "APE" (CREATE) HERE ' APE >DFA @ = .},{_T_}},
enddoc)
HEADER({>DFA},{TDFA},{DOCOL})
        DC      LIT, _CELLS(D_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc( {DICTIONARY~},{>FFA},{to_flag_field_address},{dea --- ffa},{},
{Given a dictionary entry addres return its
forthdefi({flag field address}) forthvar({ffa}) .},
{{'},{>CFA},{>DFA},{>LFA},{>NFA},,{>SFA},{>PHA}},
{{"FRED" (CREATE) ' FRED >FFA DUP @ . IMMEDIATE @ .},{0 4}},
enddoc)
HEADER({>FFA},{TFFA},{DOCOL})
        DC      LIT, _CELLS(F_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc( {DICTIONARY~},{>LFA},{to_link_field_address},{dea --- lfa},{},
{Given a dictionary entry addres return its
forthdefi({link field address}) forthvar({lfa}). It contains
the DEA of the previous word. },
{{'},{>CFA},{>DFA},{>FFA},{>NFA},{>PHA},{>SFA}},
{{: FRED ; : WILMA ; ' WILMA >LFA @ ID.},{FRED}},
enddoc)
HEADER({>LFA},{TLFA},{DOCOL})
        DC      LIT, _CELLS(L_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc( {DICTIONARY~},{>NFA},{to_name_field_address},{dea --- nfa},{},
{Given a dictionary entry addres return the
 forthdefi({name field address}).},
{{'},{>CFA},{>DFA},{>FFA},{>LFA},{>SFA}},
{{ ' WORDS >NFA @ $@ TYPE},{WORDS}},
enddoc)
HEADER({>NFA},{TNFA},{DOCOL})
        DC      LIT,_CELLS(N_HOFFSET)
        DC      PLUS
        DC      SEMIS
;
_SOURCEFIELD_({
worddoc( {DICTIONARY~},{>SFA},{to_source_field_address},{dea --- sfa},{},
{Given a dictionary entry addres return the
 forthdefi({source field address}).},
{{'},{>CFA},{>DFA},{>FFA},{>LFA},{>NFA}},
{{ ' WORDS >SFA @ .},{0}},
enddoc)
;
HEADER({>SFA},{TSFA},{DOCOL})
        DC      LIT,_CELLS(S_HOFFSET)
        DC      PLUS
        DC      SEMIS
},{dnl});_END_({_SOURCEFIELD_})
;
worddoc( {DICTIONARY~},{>PHA},{past_header_address},{dea --- addr},{},
{Given a dictionary entry addres return the
forthdefi({past header address}). Here starts the area that no
longer belongs to the header of a dictionary entry, but most
often it is owned by it. },
{{'},{>CFA},{>BODY}},
{{ "Q" (CREATE) ' Q >PHA HERE = .},{_T_} },
enddoc)
HEADER({>PHA},{TPHA},{DOCOL})
        DC      LIT,_CELLS(PH_OFFSET)
        DC      PLUS
        DC      SEMIS
;
worddoc( {DICTIONARY},{>BODY},{to_body},{dea --- addr},{ISO},
{Given the dictionary entry addres forthvar({dea}) of a
definition created with a forthcode({CREATE}) /
forthcode({DOES>}) construct, return its data field
forthvar({addr}).},
{{'},{>CFA},{>DFA},{>PHA},{BODY>}},
{{ CREATE Q  ' Q >BODY HERE = .},{_T_} },
enddoc)
HEADER({>BODY},{TOBODY},{DOCOL})
        DC      CTOD
        DC      TDFA, FETCH
        DC      CELLP           ;{ Skip DOES> pointer.}
        DC      SEMIS
;
worddoc( {DICTIONARY},{BODY>},{body_from},{addr --- dea},{},
{Convert the data field forthvar({addr}) of a definition
created with a forthcode({CREATE}) / forthcode({DOES>})
construct to its forthvar({dea}). Where forthcode({>BODY})
keeps working after revectoring, forthcode({BODY>}) does not.
_VERBOSE_({{ There is some logic to this, because the DEA to
which the body belongs is no longer unique.}})
},
{{'},{>BODY}},
{{ CREATE QAQ HERE BODY> ID.},{QAQ}},
enddoc)
HEADER({BODY>},{BODYF},{DOCOL})
        DC      LIT,_CELLS(BD_OFFSET)
        DC      LSUB
        DC      SEMIS
;
worddoc( {DICTIONARY~},{CFA>},{code_field_address_from},{cfa --- dea},{},
{Convert the code field address of a definition to its
forthdefi({dictionary entry address}) forthvar({dea}).},{{'},{>CFA}},
{{ : GS1 LIT WORDS ; GS1 CFA> ID.},{WORDS}},
enddoc)
HEADER({CFA>},{CTOD},{DOCOL})
        DC      LIT,_CELLS(C_HOFFSET)
        DC      LSUB
        DC      SEMIS
;
worddoc( {DICTIONARY~},{>WID},{to_w_i_d},{dea1 --- dea2},{},
{Given the dictionary entry addres forthvar({dea1}) of a
vocabulary return the address forthvar({dea2}) of its
forthdefi({WID}), a dummy DEA that serves as the start of a
dictionary search. },
{{VOCABULARY},{>CFA}},
{{: APE ; ' FORTH >WID >LFA @ ID.},{APE}},
enddoc)
HEADER({>WID},{TWID},{DOCOL})
        DC      TOBODY
        DC      CELLP ; {Skip vfa link.}
        DC      SEMIS
;
worddoc( {DICTIONARY~},{>VFA},{to_vocabulary_field_address},{dea --- cfa},{},
{Given the dictionary entry addres of a vocabulary
return the address of the link to the next vocabulary.
},{{VOCABULARY},{>CFA},{>WID}},
{{VOCABULARY APE VOCABULARY MONKEY dnl
'MONKEY >VFA @  ' APE = .},{_T_}},
enddoc)
HEADER({>VFA},{TVFA},{DOCOL})
        DC      TOBODY
        DC      SEMIS
;
_SECURITY_({
worddoc( {SECURITY},{!CSP},{store_c_s_p},{},{},
{Save the stack position in forthcode({CSP}). Used as part of the compiler
security.},{},
{{." Via ?CSP"},{Via ?CSP}},
enddoc)
HEADER({!CSP},{SCSP},{DOCOL})
        DC      SPFET
        DC      LCSP
        DC      STORE
        DC      SEMIS
;
});_END_({_SECURITY_})
worddoc( {ERRORS},{?ERROR},{question_error},{f n --},{},
{  Throw exception with number forthsamp({n}) , if the boolean flag is true.
All kernel error handling goes through this words, allowing to
catch e.g. disk errors.
},
{ERROR},
{{0 12 ?ERROR},{},
 {0 WARNING !   1 12 ?ERROR},{ING !   1 12 ?ERROR ? MSG # 18 },
 {CR},{} },
enddoc)
HEADER({?ERROR},{QERR},{DOCOL})
        DC      SWAP
        _0BRANCH(QERR1) ;{IF}
        DC      LIN, FETCH
        DC      SRC, FETCH
        DC      LWHERE, TSTOR
        DC      THROW
        _BRANCH(QERR2)  ;{ELSE}
QERR1:  DC      DROP    ;{THEN}
QERR2:  DC      SEMIS
;
;
_SECURITY_({
worddoc( {SECURITY},{?DELIM},{question_delimiter},{},{},
{Parse a character and issue error message if it is not a
delimiter.},{},
{
{DECIMAL 0 WARNING !   ?DELIM   },{},
{0 WARNING !   ?DELIM 1}, {WARNING !   ?DELIM 1? MSG # 10 },
 {CR},{} },
enddoc)
HEADER({?DELIM},{QDELIM},{DOCOL})
        DC      INBRS
        DC      QBL
        DC      ZEQU
        DC      LIT, 10, QERR
        DC      DROP
        DC      SEMIS
;
worddoc( {SECURITY},{?CSP},{question_c_s_p},{},{},
{Issue error message if stack position differs from value saved in
forthsamp({CSP}) .},{},
{{!CSP ?CSP},{},
{0 WARNING !   !CSP 1 ?CSP},{ING !   !CSP 1 ?CSP ? MSG # 20 },
 {CR},{} },
enddoc)
HEADER({?CSP},{QCSP},{DOCOL})
        DC      SPFET
        DC      LCSP
        DC      FETCH
        DC      LSUB
        DC      LIT, 20, QERR
        DC      SEMIS
;
worddoc( {SECURITY},{?COMP},{question_compile},{},{},
{Issue error message if not compiling.},{{?ERROR}},
{{0 WARNING !   ?COMP},{0 WARNING !   ?COMP ? MSG # 17 },
 {CR},{} },
enddoc)
HEADER({?COMP},{QCOMP},{DOCOL})
        DC      STATE
        DC      FETCH
        DC      ZEQU
        DC      LIT, 17, QERR
        DC      SEMIS
;
worddoc( {SECURITY},{?EXEC},{question_exec},{},{},
{Issue an error message if not executing.},{{?ERROR}},
{{!CSP ?CSP},{},
{0 WARNING ! ?EXEC},{} },
enddoc)
HEADER({?EXEC},{QEXEC},{DOCOL})
        DC      STATE
        DC      FETCH
        DC      LIT, 18, QERR
        DC      SEMIS
;
worddoc( {SECURITY},{?PAIRS},{question_pairs},{n1 n2 --},{},
{Issue an error message if forthvar({n1}) does not equal forthvar({n2}) . The message
indicates that compiled conditionals do not match.},{{?ERROR}},
{{ 1 1 ?PAIRS},{},
{0 WARNING !  1 2 ?PAIRS},{RNING !  1 2 ?PAIRS ? MSG # 19 },
 {CR},{} },
{},
enddoc)
HEADER({?PAIRS},{QPAIR},{DOCOL})
        DC      LSUB
        DC      LIT, 19, QERR
        DC      SEMIS
;
_LOAD_({
worddoc( {SECURITY},{?LOADING},{question_loading},{},{},
{Issue an error message if not loading},{{?ERROR}},
{{0 WARNING ! ?LOADING },{ WARNING ! ?LOADING ? MSG # 22 },
 {CR},{} },
enddoc)
HEADER({?LOADING},{QLOAD},{DOCOL})
        DC      BLK
        DC      FETCH
        DC      ZEQU
        DC      LIT, 22, QERR
        DC      SEMIS
;
});_END_({_LOAD_})
});_END_({_SECURITY_})
;
worddoc( {PARSING},{[},{left_bracket},{},{ISO,FIG,I,L1},
{Used in a colon-definition in form:
forthexample({:  xxx    [  words   ]    more   ;})
Suspend compilation. The words after forthcode({[}) are executed, not compiled.
This allows calculation or compilation exceptions before resuming
compilation with forthcode({]})},{{LITERAL} ,{]}},
{{!CSP : GS1 LIT [ 2398 , ] ; ?CSP GS1 .},{2398}},
enddoc)
HEADER({[},{LBRAC},{DOCOL}, , B_IMMED)
        DC      ZERO
        DC      STATE
        DC      STORE
        DC      SEMIS
;
worddoc( {PARSING},{]},{righ_bracket},{},{ISO,FIG,L1},
{Resume compilation, to the completion of a colon-definition.},
{{[}},
{{." Via ["},{Via [}},
enddoc)
HEADER({]},{RBRAC},{DOCOL})
        DC      ONE
        DC      STATE
        DC      STORE
        DC      SEMIS
;
worddoc( {DICTIONARY~},{HIDDEN},{hidden},{dea -- },{},
{Make the word with dictionary entry address forthvar({dea})
unfindable, by toggling the "smudge bit" in a definitions' flag
field. If however it was the forthvar({dea}) of an unfindable
word, it is made findable again.
_SECURITY_({{Used
during the definition of a colon word to prevents an
uncompleted definition from being found during dictionary
searches, until compiling is completed without error. It also
prevents that a word can be used recursively.}})
},
{{IMMEDIATE},{RECURSE}},
dnl NOTE: a word starting with e.g. C would be a denotation.
{{"ZXJEP" 2DUP (CREATE) 2DUP FOUND 0= .},{0},
{LATEST HIDDEN FOUND .},{0} },
enddoc)
HEADER({HIDDEN},{HIDDEN},{DOCOL})
        DC      TFFA
        DC      LIT,B_INVIS
        DC      TOGGL
        DC      SEMIS
;
worddoc( {FORMATTING},{HEX},{hex},{},{ISO,FIG,L0},
{Set the numeric conversion forthcode({BASE}) for hexadecimal (base 16) input-output.},
{{DECIMAL}},
{{HEX BASE @ DECIMAL .},{16}},
enddoc)
HEADER({HEX},{HEX},{DOCOL})
        DC      LIT,16
        DC      BASE
        DC      STORE
        DC      SEMIS
;
worddoc( {FORMATTING},{DECIMAL},{decimal},{},{ISO,FIG,L0},
{Set the numeric conversion forthcode({BASE}) for decimal input-output.},
{{HEX}},
{{." Via BASE"},{Via BASE}},
enddoc)
HEADER({DECIMAL},{DECA},{DOCOL})
        DC      LIT,10
        DC      BASE
        DC      STORE
        DC      SEMIS
;
worddocsafe( {DEFINING~},{(;CODE)},{paren_semicolon_code},{},{C},
{The run-time proceedure, compiled by forthcode({;CODE}), that rewrites the code
field of the most recently defined word to point to the following
machine code sequence. _VERBOSE_({{This is not needed for words made by
forthcode({(CREATE)}) as it defaults to creating assembler words.}})
},
{{ (CREATE)}, {;CODE}},
{{." No test"},{No test} },
enddoc)
HEADER({(;CODE)},{PSCOD},{DOCOL})
        DC      FROMR
        DC      LATEST
        DC      TCFA
        DC      STORE
        DC      SEMIS
;
worddoc( {DEFINING~},{;CODE},{semicolon_code},{},{ISO,FIG,I,C,L0},
{Used in the form:
  forthsamp({: cccc CREATE .... ;CODE assembly mnemonics })
Stop compilation and terminate a new defining word
forthsamp({cccc}) by compiling forthcode({(;CODE)}). Set
forthcode({ASSEMBLER}) to the top of the forthcode({SEARCH-ORDER})
order. Start assembling to machine code the following
mnemonics.

When forthsamp({cccc}) later executes in the form:
                     forthsamp({cccc nnnn})
the word forthsamp({nnnn}) will be created with its execution proceedure given by
the machine code following forthsamp({cccc}) .
That is, when forthsamp({nnnn}) is executed, it does so by
jumping to the code after forthsamp({nnnn}) .
Because of intimate relation to the
assembler, it is present in loadable form in the screens file
forthfile({forth.lab}) .},
{{(;CODE)},{LOAD},{:}},
{{." Not present"},{Not present} },
enddoc)
;
worddoc( {DEFINING},{CREATE},{create},{},{},
{A defining word used in the form:
     forthsamp({CREATE cccc})
Later execution of forthsamp({cccc}) returns its data field, i.e.
the value of forthcode({HERE}) immediately
after executing forthcode({CREATE}) .


It can be the base of a new defining word if used in the form:
     forthexample({: CREATOR CREATE aaaa DOES> bbbb ;
CREATOR cccc
})
The second line has the effect of creating a word forthsamp({cccc}) .
Its datastrcuture is build
by the code forthsamp({aaaa}) and when executing forthsamp({cccc}) , its data field is pushed
on the stack, then the code forthsamp({bbbb}) is executed.

_VERBOSE_({Space in this data field has yet to
be allocated and the execution action can be changed.})
ciforth is byte aligned, so no extra measures are needed.},
{{DOES>},{;CODE},{ALLOT},{,},{C,}},
{{ CREATE ZWY LATEST ID.},{ZWY},
{HERE ZWY = .},{_T_}},
enddoc)
HEADER({CREATE},{CREATE},{DOCOL})
        DC      LPWORD
        DC      PCREAT
        DC      LIT, HLNOOP, COMMA
        DC      PSCOD
DODOE:  LEA     RPO,[RPO - _CELLS(1)] ;{Pop HIP.}
        MOV     [RPO],HIP
        MOV     HIP,[WOR+_CELLS((D_HOFFSET-C_HOFFSET))] ;{NEW IP }
        LEA     AX,[HIP+_CELLS(1)]
        MOV     HIP,[HIP]
        _PUSH
HLNOOP: DC      SEMIS
;
worddoc( {DEFINING},{DOES>},{does},{},{ISO,FIG,L0},
{A word which is normally use to specify the run-time action
within a high-level defining word. forthcode({DOES>}) modifies
the behaviour of the latest word as to execute the sequence of
compiled word addresses following forthcode({DOES>}) . Used in
combination with forthcode({CREATE}) . When the
forthcode({DOES>}) part executes it begins with the address of
the data field of the word on the stack. This allows
interpretation using this area or its contents. _VERBOSE_({
Typical uses include the Forth assembler, multidimensional
arrays, and compiler generation.})
},
{},
{{ !CSP : GS1 DOES> @ 1 + ;  : GS2 DOES> @ 2 + ; dnl
  CREATE MARY 0 , GS1 MARY . GS2 MARY . ?CSP},{1 2} },
enddoc)
HEADER({DOES>},{DOES},{DOCOL})
        DC      FROMR
        DC      LATEST
        DC      TDFA
        DC      FETCH
        DC      STORE
        DC      SEMIS
;
worddoc( {STRING},{COUNT},{count},{addr1 --- addr2 n},{ISO,FIG,L0},
{Leave the byte address forthvar({addr2}) and byte count forthvar({n}) of a message text
beginning at address forthvar({addr1}) . It is presumed that the first byte at
forthvar({addr1}) contains the text byte count and the actual text starts with
the second byte. Alternatively stated, fetch a string constant forthsamp({addr n})
from the brain damaged string variable at forthvar({addr1}) .
},{{TYPE}},
{{HERE 3 C, 45 C, 45 C, 45 C, COUNT . HERE - .},{3 -3}},
enddoc)
HEADER({COUNT},{COUNT},{DOCOL})
        DC      LDUP
        DC      ONEP
        DC      SWAP
        DC      CFET
        DC      SEMIS
;
worddoc( {STRING},{-TRAILING},{dash_trailing},{sc1 --- sc2},{ISO},
{Trim the string constant forthvar({sc1}) so as not to contain
trailing blanks and leave it as forthvar({sc2}) . },
{},
{{ "    NUKES   " -TRAILING 41 EMIT TYPE 41 EMIT},{A   NUKESA}},
enddoc)
HEADER({-TRAILING},{DTRAI},{DOCOL})
        DC      LDUP
        DC      ZERO
        _DO(DTRA4)
DTRA1:  DC      OVER
        DC      OVER
        DC      PLUS
        DC      ONE
        DC      LSUB
        DC      CFET
        DC      LBL
        DC      LSUB
        _0BRANCH(DTRA2) ;{IF}
        DC      LLEAV
DTRA2:  DC      ONE
        DC      LSUB    ;{ THEN}
        _LOOP(DTRA1)    ;{ LOOP}
DTRA4:
        DC      SEMIS
;
_LOAD_({
worddocsafe( {STRING},{S"},{s_quote},{ --- addr1 n},{ISO,L0},
{ Used in the form:
  forthsamp({S" cccc"})
Leaves an in-line string forthsamp({cccc}) (delimited by the
trailing forthkey({"})) as a constant string forthsamp({addr1
n}) . In ciforth the number of characters has no limit and
using forthsamp({S"}) has always an effect on
forthcode({HERE}), even during interpretation.
},{{DEN"}},
{{S" NUKES  " 41 EMIT TYPE 41 EMIT},{ANUKES  A},
{: GS1 S" NUKES  " 41 EMIT TYPE 41 EMIT ; GS1},{ANUKES  A},
{S" ""BD  " 41 EMIT TYPE 41 EMIT},{A"BD  A}},
enddoc)
HEADER({S"},{SQUOT},{DOCOL}, , B_IMMED)
        DC      DENQ
        DC      SEMIS
;
});_END_({_LOAD_})
worddocsafe( {OUTPUT},{."},{dot_quote},{},{ISO,FIG,I,L0},
{Used in the form:
  forthsamp({." cccc"})
In a definition it compiles an in-line string forthsamp({cccc}) (as if the denotation forthcode({"cccc"}) was used)
followed by forthcode({TYPE}) .
In ciforth forthcode({."}) will behave the same in interpret mode.
In ciforth the number of characters has no limit and has always an effect
on forthcode({HERE}) during interpretation.
In ISO programs you may only use this word during compilation.
_VERBOSE_({We want forthsamp({." cccc"}) replaced by forthsamp({"cccc" TYPE}).})},
{{OUT}},
{{." the end" },{the end},
{: GS1 ." ""the end"" he said" ; GS1 },{"the end" he said}},
{: GS1 ." the end" ; GS1 },{the end}},
enddoc)
HEADER({."},{DOTQ},{DOCOL}, , B_IMMED)
        DC      DENQ
        DC      STATE
        DC      FETCH
        _0BRANCH(DOTQ1) ;{ IF}
        DC      LIT, LTYPE, COMMA
        _BRANCH(DOTQ2)
DOTQ1:
        DC      LTYPE
DOTQ2:
        DC      SEMIS   ;{ THEN}
;
worddocsafe( {OUTPUT},{.(},{dot_paren},{},{I,L0},
{ In ciforth this is an alias for ." , except that the string is closed with forthkey({{)}}).
In ISO programs you may only use this word while interpreting.
_VERBOSE_({We want forthsamp({.( cccc)}) replaced by the equivalent forthsamp({"cccc" TYPE}).})},
{{OUT},{."}},
{{.( the end)},{the end}},
enddoc)
HEADER({.(},{DOTP},{DOCOL}, , B_IMMED)
        DC      LIT, ')'
        DC      PPARS
        DC      LTYPE
        DC      SEMIS
;
worddocsafe( {PARSING},{SET-SRC},{set_source},{sc -- },{},
{Make the string constant forthvar({sc}) the
forthdefi({current input source}). This input is chained, i.e.
exhausting it has the same effect as exhausting the input that
called forthcode({SET-SRC}). _VERBOSE_({ In practice this word
is almost always followed by a call to
forthcode({INTERPRET}).})},
{{EVALUATE},{INTERPRET}},
{{ "1 2 3 . CR" SET-SRC . . .},{3}},
enddoc)
HEADER({SET-SRC},{SETSRC},{DOCOL})
        DC      OVER, PLUS
        DC      SWAP, SRC, TSTOR
        DC      SRC, FETCH
        DC      LIN, STORE ; { IN}
_ISO_IN_({       DC     SRC, FETCH, NEGATE, LDUP
        DC     SRC, CELLP, PSTORE
        DC     LIN, PSTORE
})
;       DC      DOTS
        DC      SEMIS
;
worddoc( {PARSING}, {EVALUATE}, , {sc --- ??}, {ISO},
{Interpret the content of forthvar({sc}). Afterwards return to
the forthdefi({current input source}) .},
{{LOAD},{INCLUDE},{SET-SRC}},
{
{"865" EVALUATE .},{865},
{"8655 1+" EVALUATE U.},{8656},
{": GS1 856 ;" EVALUATE GS1 .},{856}
},
enddoc)
HEADER({EVALUATE}, {EVALUATE},{DOCOL})
        DC      SAVE
        DC      SETSRC
        DC      LIT, INTER, CATCH
        DC      RESTO
        DC      THROW
        DC      SEMIS
;
worddoc( {MEMORY},{FILL},{fill},{addr u b --},{ISO,FIG,L0},
{ If forthvar({u}) is not zero, store forthvar({b})
in each of forthvar({u}) consecutive bytes of memory beginning at
forthvar({addr}) . },
{{BLANK},{ERASE}},
{{ !CSP HERE 41 C, 41 C, 41 C, 41 C, DUP 3 23 FILL dnl
    COUNT . COUNT . COUNT . COUNT .},{23 23 23 41} },
enddoc)
CODE_HEADER({FILL},{FILL})
        POP     AX      ;{ FILL CHAR}
        POP     CX      ;{ FILL COUNT}
        POP     DI      ;{ BEGIN ADDR}
;{       MOV    BX,DS}
;{       MOV    ES,BX   ; ES <- DS}
        CLD             ;{ INC DIRECTION}
        REP     STOSB   ;{STORE BYTE}
        _NEXT
;
worddoc( {MEMORY},{CORA},{CORA},{addr1 addr2 len  -- n},{CIF},
{Compare the memory areas at forthvar({addr1}) and forthvar({addr2})
over a length forthsamp({len}) .
For the first bytes that differ, return -1 if the byte
from forthvar({addr1}) is less (unsigned) than the one from forthvar({addr2}),
and 1 if it is greater.
If all forthsamp({len}) bytes are equal, return
zero.
_VERBOSE_({{This is an abbreviation of forthcode({COMPARE-AREA}).
It should have been named forthsamp({COMPARE}) ,
but that is taken by ISO.}})
},
{},
{{ HEX 41 C, 42 C, 43 C, HERE 3 - DUP 3 CORA .},{0 },
{HERE 2 - HERE 3 - 2 CORA . },{1 },
{HERE 3 - HERE 2 - 2 CORA .},{-1 }},
enddoc)
CODE_HEADER({CORA},{CORA})
;{       MOV    ES,BX   ; ES <- DS}
;{       MOV    BX,DS}
        MOV     DX,HIP   ;{SAVE}
        XOR     AX,AX   ;{ Result}
        POP     CX      ;{ count}
        POP     DI      ;{ addr2}
        POP     SI      ;{ addr1}
        CLD             ;{ INC DIRECTION}
        REP     CMPSB   ;{ Compare BYTE}
        JZ      CORA3
        MOV     AL,1    ;{Remainder is already 0}
        JNC     CORA3
        NEG     AX
CORA3:
        MOV     HIP,DX  ;{Restore}
        _PUSH
;
worddoc( {STRING},{$I},{string_index},{sc ch -- addr},{},
{Find the first forthvar({ch}) in the string constant forthvar({sc}) and
return its forthvar({addr1}) if present.
Otherwise return a nil pointer (0). },
{{$S},{CORA}},
{{ 132 "ORANG" OVER >R &N $I R> - . .},{3 132},
{ 132 "ORANG" &Z $I 0= . .},{_T_ 132}},
enddoc)
CODE_HEADER({$I},{SINDEX})
;{       MOV    ES,BX   ; ES <- DS}
;{       MOV    BX,DS}
        POP     AX      ;{ char}
        POP     CX      ;{ count}
        POP     DI      ;{ addr}
        OR      DI,DI   ;{Clear zero flag.}
        CLD             ;{ INC DIRECTION}
        REPNZ     SCASB   ;{ Compare BYTE}
        JZ      SINDEX1
        XOR     DI,DI    ;{Not found: 0}
        INC     DI
SINDEX1:
        DEC     DI
        PUSH    DI
        _NEXT
;
worddoc( {STRING},{$S},{string_split},{sc ch -- sc1 sc2},{},
{Find the first forthvar({ch}) in the string constant
forthvar({sc}) and split it at that address. Return the strings
after and before forthvar({ch}) into forthvar({sc1}) and
forthvar({sc2}) respectively. If the character is not present
forthvar({sc1}) is a null string _VERBOSE_({{(its address is
zero)}}) and forthvar({sc2}) is the original string.
_VERBOSE_({{Both forthvar({sc1}) and forthvar({sc2}) may be
empty strings (i.e. their count is zero), if forthvar({ch}) is
the last or first character in forthvar({sc}) .}}) },
{{$I},{CORA}},
{{ 132 "ORANG" &O $S . DROP TYPE . },{0 RANG132},
{ "ORANG OETAN" BL $S TYPE TYPE },{ORANGOETAN},
{ "ORANG" &G $S TYPE 0 . TYPE },{ORAN0 },
{ 132 "ORANG" &Z $S TYPE . . .},{ORANG0 0 132 }},
enddoc)
CODE_HEADER({$S},{SSPLIT})
;{       MOV    ES,BX   ; ES <- DS}
;{       MOV    BX,DS}
        POP     AX      ;{ char}
        POP     CX      ;{ count}
        MOV     BX,CX
        POP     DI      ;{ addr}
        OR      DI,DI   ;{Clear zero flag.}
        MOV     DX,DI   ;{ Copy}
        CLD             ;{ INC DIRECTION}
        REPNZ     SCASB   ;{ Compare BYTE}
        JZ      SSPLIT1
; {Not present.}
        PUSH    CX   ;{ Nill pointer.}
        JMP SSPLIT2
SSPLIT1:
        PUSH    DI
        SUB     BX,CX
        DEC     BX      ;{Delimiter is not part of first string.}
SSPLIT2:
        PUSH    CX   ;{Remaining length}
        PUSH    DX   ;{Start of first string.}
        PUSH    BX   ;{Skipped length.}
        _NEXT
;
worddoc( {MEMORY},{ERASE},{erase},{addr n --},{ISO},
{Shorthand for forthsamp({0 FILL}).},
{{BLANK},{FILL}},
{{ !CSP HERE 41 C, 41 C, 41 C, 41 C, DUP 3 ERASE dnl
    COUNT . COUNT . COUNT . COUNT .},{0 0 0 41} },
enddoc)
HEADER({ERASE},{LERASE},{DOCOL})
        DC      ZERO
        DC      FILL
        DC      SEMIS
;
_LOAD_({
worddoc( {MEMORY},{BLANK},,{addr count --},{ISO},
{Shorthand for ``forthcode({BL}) forthcode({FILL})''.},{},
{{ !CSP HERE 41 C, 41 C, 41 C, 41 C, DUP 3 BLANK dnl
    COUNT . COUNT . COUNT . COUNT .},{20 20 20 41} },
enddoc)
HEADER({BLANK},{BLANK},{DOCOL})
        DC      LBL
        DC      FILL
        DC      SEMIS
});_END_({_LOAD_})
;
worddoc( {FORMATTING},{HOLD},{hold},{c ---},{ISO,FIG},
{Add the character forthvar({c}) to the beginning of the output
string. It must be executed for numeric formatting inside a
forthcode({<#}) and forthcode({#>}) construct . },
{{#},{DIGIT}},
{ { <# 1 0 # 41 HOLD # #> TYPE },{0A1} },
enddoc)
HEADER({HOLD},{HOLD},{DOCOL})
        DC      LIT,-1
        DC      HLD
        DC      PSTORE
        DC      HLD
        DC      FETCH
        DC      CSTOR
        DC      SEMIS
;
worddoc( {DICTIONARY},{PAD},{pad},{--- addr},{ISO,FIG,L0},
{Leave the address of the text output buffer, which is a fixed offset
above forthcode({HERE}). The area growing downword from forthcode({PAD}) is used
for numeric conversion.
},{},
{{4321 PAD ! PAD @ .},{4321 } },
enddoc)
HEADER({PAD},{PAD},{DOCOL})
        DC      HERE
;{ Allow for a one line name, a double binary number and some hold char's}
        DC      LIT,84+128+64
        DC      PLUS
        DC      SEMIS
;
_LOAD_({
worddoc( {PARSING},{WORD},{newword},{c ---addr},{ISO,FIG,L0},
{Parse the forthsamp({current input source}) using forthvar({c}) for a delimiter.
Skip leading delimiters then advance the input pointer to past
the next delimiter or past the end of the input source.
Leave at forthvar({addr}) a copy of the string,
that was surrounded by forthvar({c}) in the input source.
This is an oldfashioned string to be fetched by forthcode({COUNT}) , not forthcode({$@}) .
In ciforth the character string is positioned
at the dictionary buffer forthcode({HERE}) .
forthcode({WORD}) leaves the character count in the first byte, the characters, and
ends with two or more blanks.
If forthcode({BLK}) is zero text is taken from the terminal input buffer,
otherwise from the disc block stored in forthcode({BLK}) .},
{{BLK} ,{IN}},
{{: GS1 BL WORD COUNT . C@ EMIT ; GS1 CELLO},{5 C},
{ : GS2 5A WORD COUNT DUP . TYPE ; GS2 QQZ},{2 QQ},
{ : GS3 5A WORD COUNT DUP . TYPE ; GS3 ZZZQQZ},{2 QQ}
},
enddoc)
HEADER({WORD},{IWORD},{DOCOL})
        DC      LDUP, LBL, EQUAL
        _0BRANCH(IWORD1)
         DC      DROP
         DC      LPWORD
        _BRANCH(IWORD2)
IWORD1: DC      TOR
IWORD3:  DC      INBRS, RR, EQUAL
        _0BRANCH(IWORD4)
        DC      DROP
        _BRANCH(IWORD3)
IWORD4:
        DC      DROP
        DC      LIT, -1, LIN, PSTORE ;{ Backtrace to first non-delimiter.}
        DC      FROMR, PPARS
;        DC      DOTS
IWORD2:
        DC      HERE
        DC      LIT,22H
        DC      BLANK
        DC      HERE
        DC      SSTORBD     ; {FIXME}
        DC      HERE
;        DC      DOTS
        DC      SEMIS
;
});_END_({_LOAD_})
worddoc( {PARSING},{CHAR},{char}, {--- c},{ISO,I},
{Parse a word and
leave forthvar({c}) the first non blank char of that word in the
input source. In ciforth this word works also in compiled mode.},
{{DEN&},{CHAR}},
{{CHAR HELL .},{48 },
{CHAR X  .},{58 },
{: GS1 CHAR HELLO ; GS1 . },{48 },
{: GS2 CHAR X ; GS2 .},{58 }},
enddoc)
HEADER({CHAR},{LCHAR},{DOCOL}, , B_IMMED)
        DC      LPWORD, DROP, CFET, LITER
        DC      SEMIS
;
worddocsafe( {PARSING},{[CHAR]},{bracket_char_bracket}, {--- c},{ISO I},
{A compiling word. Parse a word.  Add the run time behaviour:
leave forthvar({c}), the first non blank char of that word in the
input source. In ciforth this word works also in interpret mode.},
{{DEN&},{CHAR}},
{},
{{: GS1 [CHAR] HELLO ; GS1 HEX . },{48 },
{: GS2 [CHAR] X ; GS2 HEX .},{58 }}, enddoc)
HEADER({[CHAR]},{BCHAR},{DOCOL}, _VAR_FIELD({LCHAR}), B_IMMED)
;
worddocsafe( {FORMATTING~},{(NUMBER)},{paren_number},{ --- d1},{},
{Convert the ascii text at the forthdefi({current input
source}) with regard to forthcode({BASE}) . The new value is
accumulated into double number forthvar({d1}) , being left. A
decimal point, anywhere, signifies that the input is to be
considered as a double. ISO requires it to be at the end of the
number. ciforth allows any number of decimal points with the
same meaning. ciforth also allows any number of comma's that
are just ignored, to improve readibility. If the first
unconvertable digit is not a blank, this is an error. },
{{NUMBER},{?BLANK}},
{{ (NUMBER) 1324 D.},{1324} },
}, enddoc)
HEADER({(NUMBER)},{PNUMB},{DOCOL})
        DC      ZERO, ZERO
        DC      ZERO, DPL, STORE
NPNUM1:  DC      INBRS   ;{ BEGIN}
        DC      LDUP, LIT, ADOT, EQUAL
        _0BRANCH(NPNUM2A) ;{ IF}
        DC      DROP, DPL, STORE, ZERO
        _BRANCH(NPNUM3) ;{ ELSE}
NPNUM2A:
        DC      LDUP, LIT, ',', EQUAL
        _0BRANCH(NPNUM2) ;{ IF}
        DC      TDROP, ZERO
        _BRANCH(NPNUM3) ;{ ELSE}
NPNUM2:
        DC      LDUP, QBL
        _0BRANCH(NPNUM4) ;{ IF}
        DC      DROP, DROP, ONE
        _BRANCH(NPNUM3) ;{ ELSE}
NPNUM4:
        DC      SWAP, DROP
        DC      BASE, FETCH, DIGIT
        DC      ZEQU
        DC      LIT, 10, QERR

        DC      SWAP
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DROP
        DC      ROT
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DPLUS
        DC      ZERO
NPNUM3:                 ; {THEN THEN}
        _0BRANCH(NPNUM1)
        DC      SEMIS
;
worddoc( {FORMATTING~},{NUMBER},{number},{ ---  s/d},{},
{Convert characters from the forthdefi({current input source}) into a number,
and compile or execute this number. If the string contains a
decimal point it is a double else a single integer number. If
numeric conversion is not possible, an error message will be
given. It is intended to be called from single character denotation
words, hence the parse pointer is decremented, to include this first
character.},
{{BASE},{(NUMBER)}},
{{ (NUMBER) 1324 D.},{1324} },
enddoc)
HEADER({NUMBER},{NUMB},{DOCOL})
LNUMB:
        DC      LIT, -1, LIN, PSTORE
        DC      PNUMB, SDLITE
        DC      SEMIS
;
_LOAD_({
worddoc( {FORMATTING},{>NUMBER},{to_number},
{ud1 addr1 u1 --- ud2 addr2 u2},
{ISO},
{
forthvar({ud2}) is the result of converting the characters
within the character string specified by forthsamp({addr1 u1})
into digits, using the number in forthcode({BASE}) , and adding
each into ud1 after multiplying forthvar({ud1}) by the number
in forthcode({BASE}) . Conversion continues until a character
that is not convertible is encountered or the string is
entirely converted. forthvar({addr2}) is the location of the
first unconverted character or the first character past the end
of the string if the string was entirely converted.
forthvar({u2}) is the number of unconverted characters in the
string. If forthvar({ud2}) overflows, in ciforth
forthvar({ud2}) will be incorrect, but no crash will result.
_VERBOSE_({Both
forthkey({-}) and forthkey({+}) are considered unconvertible
character's by forthsamp({>NUMBER}) .})
},
{{NUMBER},{DIGIT}},
{
{ 0. "1324" >NUMBER . 4 - 4 TYPE D.},{0 13241324},
{ 0. "1324.KL" >NUMBER DUP . TYPE D.},{3 .KL1324},
}, enddoc)
HEADER({>NUMBER},{TONUMB},{DOCOL})
        DC      TDUP, PLUS, TOR     ;{ End available on return stack.}
        DC      ZERO
        _QDO(TONUM9)
TONUM1:
        DC      LDUP, CFET, BASE, FETCH, DIGIT
        DC      ZEQU
        _0BRANCH(TONUM4) ;{ IF}
        DC      LLEAV
TONUM4:
        DC      SWAP, TOR ; {Address out of the way.}
        DC      SWAP
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DROP
        DC      ROT
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DPLUS
        DC      FROMR, ONEP     ; {Address back.}
        _LOOP(TONUM1)
TONUM9:
        DC      FROMR
        DC      OVER, LSUB
        DC      SEMIS
;
});_END_({_LOAD_})
worddoc( {DICTIONARY},{FOUND},{found},{sc --- dea},{},
{ Look the string up forthvar({sc}) in the dictionary observing
the the current search order. If found, leave the dictionary
entry address forthvar({dea}) of the first entry found, else
leave a nil pointer.},
{{SEARCH-ORDER}, {FIND}, {(FIND)},{VOCABULARY}},
{ { 123 : BONOBO ; "BONOBO" FOUND ' BONOBO = . .},{_T_ 123},
dnl 1ONNOBO is found as a misspelled number!
{ 243 "1ONNOBO" FOUND 0= . .},{0 243},
{ 541 "MYBONOBO" FOUND . .},{0 541}
},
enddoc)
HEADER({FOUND},{FOUND},{DOCOL})
        DC      SEARCH, TOR
FOUND1: DC      RR, FETCH
;        DC      DOTS
        DC      PFIND, LDUP, ZEQU
        _0BRANCH(FOUND3)
        DC      DROP
        DC      RR, FETCH, LIT, FORTH, LSUB ;{Was this ONLY?}
        _0BRANCH(FOUND2)
        DC      FROMR, CELLP, TOR
        _BRANCH(FOUND1)
FOUND2: DC      ZERO
FOUND3: DC      RDROP
        DC      SWAP,DROP,SWAP,DROP
        DC      SEMIS
;
worddoc( {DICTIONARY},{FIND},{find},{addr ---xt 1/xt -1/addr 0},{ISO},
{For the (old fashioned) string _VERBOSE_({(stored with a
preceeding character count)}) at forthvar({addr}) find a Forth
word in the current search order.
Return its
execution token forthsamp({xt}). If the word is immediate, also
return 1, otherwise also return -1. If it is not found, leave
the original forthvar({addr}) and a zero. },
{{SEARCH-ORDER},{FOUND},{(FIND)}},
{
{ : FIND: BL WORD FIND ; dnl
123 : BONOBO ; FIND: BONOBO . ' BONOBO = . .},{-1 _T_ 123},
{ IMMEDIATE 142 FIND: BONOBO . ' BONOBO = . .},{1 _T_ 142},
{ 153 FIND: GONNOBO . HERE - ABS 30 U< . .},{0 _T_ 153},
},
enddoc)
HEADER({FIND},{FIND},{DOCOL})
        DC      LDUP, COUNT, FOUND
        DC      LDUP
        _0BRANCH(FIND1) ;{IF}
        DC      SWAP, DROP ; {The address.}
        ; {Fine point, get xt by TCFA. Even if a nop.}
        DC      LDUP, TCFA, SWAP
        DC      TFFA, FETCH
        DC      LIT, B_IMMED, LAND
        DC      LIT, -1, SWAP
        _0BRANCH(FIND1) ;{IF}
        DC      NEGATE
FIND1:               ;{THEN THEN}
        DC      SEMIS
;
worddocsafe( {DICTIONARY~},{(FIND)},{paren_find},
{sc dea1 --- sc dea2},{},
{Search down from the forthdefi({DEA}) forthvar({dea}) for a
word with name forthvar({sc}).
This DEA can be a forthdefi({WID}). _VERBOSE_({A forthdefi({WID}) is
mostly a dummy forthdefi({DEA}) found in the
data field of a
vocabulary, or the content of forthcode({DENOTATION}) or
forthcode({SEARCH-ORDER}) }). Leave the dictionary entry address
forthvar({dea2}) of the first entry found, else leave a nil
pointer. Do not consume the string forthvar({sc})_VERBOSE_({{,
as this is a repetitive action}}). },
{{FIND},{FOUND},{>WID}},
{ { : BONOBO ; "BONOBO" CURRENT @ (FIND) ' BONOBO = .},{_T_},
 {TYPE},{BONOBO} },
enddoc)
HEADER({(FIND)},{PFIND},{DOCOL})
        DC      ZERO, RESULT, STORE
        DC      LIT, MATCHING, SWAP, FORW
        DC      RESULT,FETCH
        DC      SEMIS
;
worddoc( {ERRORS},{ERROR},{error},{n --- },{},
{Notify the user that an uncaught exception or
error with number forthvar({n}) has occurred.
The word that caused it is found using forthcode({WHERE}) and displayed .
Also forthvar({n}) is passed to forthcode({MESSAGE}) in order to give a description
 of the error.
This word is executed by forthcode({CATCH}) before restarting the interpreter
and can be revectored to give more elaborate diagnostics. },
{{?ERROR},{WARNING}},
{ {SCR @ DUP WHERE 2! 12 ERROR},{? MSG # 18},
 {CR},{} },
enddoc)
HEADER({ERROR},{ERROR},{DOCOL})
        DC      LWHERE, TFET
        DC      OVER, LIT, 20, LSUB
        DC      MAX
        DC      SWAP,OVER, LSUB
        DC      LTYPE
        DC      LIT, '?', EMIT
        DC      SPACE
        DC      MESS
        DC      SEMIS
;
worddoc( {ERRORS},{CATCH},{catch},{... xt --- ... tc },{ISO},
{Execute forthsamp({xt}). If it executes successfully, i.e. no
forthcode({THROW}) is executed by forthvar({xt}), leave a zero
into forthsamp({tc}) in addition to any stack effect
forthcode({xt}) itself might have. Otherwise in forthsamp({tc})
the non-zero throw code is left, and the stack depth is
restored. The values of the parameters for
forthcode({xt}) could have been modified. _VERBOSE_({{In
general, there is nothing useful that can be done with those
stack items.}}) Since the stack depth is known, the application
may forthcode({DROP}) those items.},
{{THROW},{QUIT},{HANDLER}},
{{' NOOP CATCH .},{0},
{: GS1 1 2 3 12 THROW ; 33 ' GS1 CATCH 44 . . .},{44 12 33}
},
enddoc)
HEADER({CATCH},{CATCH},{DOCOL})
        DC      SPFET, CELLP, TOR
        DC      HANDLER, FETCH, TOR
        DC      RPFET, HANDLER, STORE
        DC      EXEC
        DC      FROMR, HANDLER, STORE
        DC      RDROP, ZERO
        DC      SEMIS
;
worddoc( {ERRORS},{THROW},{throw},{... tc --- ... / ... tc},{ISO},
{If forthsamp({tc}) is zero, it is merely discarded. If we are
executing under control of a forthcode({CATCH}) , see
forthcode({CATCH}) for the effect of a non-zero
forthsamp({tc}). If we are executing not under control of a
forthcode({CATCH}), a non-zero forthsamp({tc}) aborts.
},
{{CATCH},{QUIT},{HANDLER},{?ERROR}},
{{: GS1 IN @ SRC @ WHERE 2! 1 2 3 12 THROW ; GS1 },
{ 2 3 12 THROW ; GS1 ? MSG # 18},
 {CR},{} },
enddoc)
HEADER({THROW},{THROW},{DOCOL})
        DC      QDUP
        _0BRANCH(THROW1)
        DC      HANDLER, FETCH, ZEQU
        _0BRANCH(THROW2)
        DC      ERROR
        DC      MTBUF  ;{ A (too) crude way to remove locks}
        DC      SZERO, FETCH, SPSTO
        DC      QUIT
THROW2:
        DC      HANDLER, FETCH, RPSTO
        DC      FROMR, HANDLER, STORE
        DC      FROMR, SWAP, TOR
        DC      SPSTO
        DC      FROMR
THROW1:
        DC      SEMIS
;
_LOAD_({
worddocsafe( {ERRORS~},{(ABORT")},{paren_abort_quote},{f --- },{},
{The run time action of forthcode({ABORT"}) .},
{},
{{( See abort_quote)},{}},
enddoc)
HEADER({(ABORT")},{PABORTQ},{DOCOL})
        DC      ROT
        _0BRANCH(PABQ1) ;{IF}
        DC      LTYPE, SIGNON, ABORT
        _BRANCH(PABQ2) ;{ELSE}
PABQ1:  DC       TDROP
PABQ2:   DC      SEMIS
;
worddocsafe( {ERRORS},{ABORT"},{abort_quote},{f --- },{ISO,I},
{Usage is forthsamp({: <SOME> ... ABORT" <message>" ... ;}). If
ABORT" finds a non-zero forthvar({f}) on the stack, the
forthsamp({<message>}) is displayed and an
forthcode({ABORT}) is executed. Otherwise proceed with the
words after forthsamp({<message>}). In ciforth it is also
allowed to use forthcode({ABORT"}) in interpret mode.
},
{{?ERROR}},
{{ 0  ABORT" APE" 123 .},{123},
{: GS1 0 ABORT" APE" 123 ; GS1 .},{123},
dnl The warm start message is filtered away!
{ 1  ABORT" APE" },{APE},
{: GS2 1 ABORT" APE" 123 ; GS2 .},{APE}
},
enddoc)
HEADER({ABORT"},{ABORTQ},{DOCOL},,B_IMMED)
        DC      DENQ
        DC      STATE
        DC      FETCH
        _0BRANCH(ABQ3) ;{ IF}
        DC      LIT, PABORTQ, COMMA
        _BRANCH(ABQ4)
ABQ3:
        DC      PABORTQ
ABQ4:
        DC      SEMIS
;
});_END_({_LOAD_})
worddoc( {DICTIONARY},{ID.},{i_d_dot},{dea ---},{},
{Print a definition's name from its dictionary entry address.
Dummy entries are ignored. },
{{'},{>DFA},{>NFA}},
{ { : GORILLA ; ' GORILLA ID.},{GORILLA} },
enddoc)
HEADER({ID.},{IDDOT},{DOCOL})
        DC      LDUP, TFFA
        DC      FETCH, LIT, B_DUMMY, LXOR
        _0BRANCH(IDDOT1)
        DC      TNFA
        DC      FETCH
        DC      SFET
        DC      LTYPE
        DC      SPACE
        DC      SPACE
        DC      SPACE
        _BRANCH(IDDOT2)
IDDOT1:
        DC      DROP
IDDOT2:
        DC      SEMIS
;
worddocsafe( {DEFINING~},{(CREATE)},{paren_create},{sc --},{},
{This is the basis for all defining words. It lays down the
string forthvar({sc}) in the dictionary, then creates a
dictionary entries with that string as the namefield. It is
linked into the forthcode({CURRENT}) word list. The code field
and data field both point to the area owned by this header,
i.e. immediately following the completed header _VERBOSE_({{as
appriopriate for a low level (assembler) definition}}). The
flag field is empty _VERBOSE_({{, so not forthcode({SMUDGE}) d}}). },
{{CREATE}},
{{"FRED" (CREATE) ' FRED LATEST = .},{_T_}},
enddoc)
HEADER({(CREATE)},{PCREAT},{DOCOL})
        DC      LDUP
        DC      ZEQU
        DC      LIT, 5, QERR
        DC      TDUP
        DC      FOUND
        DC      LDUP
        _0BRANCH(CREA1) ;{IF}
        DC      LDUP, TFFA, FETCH
        DC      LIT, B_DENOT, LAND, ZEQU
        _0BRANCH(CREA1) ;{IF}
        DC      IDDOT
        DC      LIT,4
        DC      MESS
        DC      SPACE   ;{THEN}
        DC      ZERO
CREA1:  DC      DROP
_ALIGNED_({ DC      LALIGN},{dnl})
        DC      SCOMMA
_ALIGNED_({ DC      LALIGN},{dnl})
        DC      HERE,TOR

        DC      RR, TPHA, COMMA         ; {Code field.}

        DC      RR, TPHA, COMMA         ; {Data field.}

        DC      ZERO, COMMA ; {Flag field.}

        DC      CURR, FETCH, TLFA
        DC      LDUP, FETCH, COMMA   ; {Link field.}
        DC      RR, SWAP, STORE

        DC      COMMA   ; {Name field.}

_SOURCEFIELD_({
        DC      BLK, FETCH, LDUP, ZEQU
        _0BRANCH(CREA2)
        DC      DROP, LIN, FETCH
CREA2:  DC      COMMA  ; {Source field.}
},{dnl})
        DC      RDROP
        DC      SEMIS
;
worddoc( {COMPILING},{[COMPILE]},{bracket_compile},{},{I,C},
{Used in a colon-definition in form:
forthexample({:  xxx    [COMPILE]   FORTH   ;})
forthcode({[COMPILE]}) will force the compilation of an immediate definitions,
that would otherwise execute during compilation. The above example
will select the forthcode({FORTH}) vocabulary when forthsamp({xxx}) executes, rather than at
compile time.},{{POSTPONE}},
{ {: MY-IF [COMPILE] IF ; IMMEDIATE dnl
 : JAN MY-IF 1 ELSE 2 THEN . ; ?CSP 0 JAN 1 JAN},{2 1} },
enddoc)
HEADER({[COMPILE]},{BCOMP},{DOCOL}, , B_IMMED)
        DC      LPWORD
        DC      FOUND
        DC      LDUP
        DC      ZEQU
        DC      ZERO, QERR
        DC      TCFA
        DC      COMMA
        DC      SEMIS
;
worddoc( {COMPILING},{POSTPONE},{postpone},{},{I,C},
{Used in a colon-definition in the form:
    forthexample({: xxx POSTPONE SOME-WORD })
forthcode({POSTPONE}) will postpone the
compilation behaviour of forthsamp({SOME-WORD}) to the
definition being compiled. If forthsamp({SOME-WORD}) is an immediate word
this is similar to forthsamp({[COMPILE] SOME-WORD}). },
{{[COMPILE]}},
{
{!CSP : GS1 POSTPONE BL ; : GS2 [ GS1 ] ; GS2 .},{20},
{: MY-IF POSTPONE IF ; IMMEDIATE dnl
: IAN MY-IF 1 ELSE 2 THEN . ; ?CSP 0 IAN 1 IAN},{2 1}
},
enddoc)
HEADER({POSTPONE},{POSTP},{DOCOL}, , B_IMMED)
        DC      LPWORD
        DC      FOUND
        DC      LDUP
        DC      ZEQU
        DC      ZERO, QERR
        DC      LDUP, TFFA, FETCH
        DC      LIT, B_IMMED, LAND, ZEQU
        _0BRANCH(POSTP1)
         DC      LIT, LIT, COMMA
         DC      COMMA
         DC      LIT, COMMA, COMMA
        _BRANCH(POSTP2)
POSTP1:
         DC      COMMA
POSTP2:
        DC      SEMIS
;
worddoc( {COMPILING},{LITERAL},{literal},{d --- d (executing) n --- (compiling)},{ISO,I,C2,L0},
{If compiling, then compile the stack value forthvar({n}) as a
_BITS_ bit literal.
_VERBOSE_({The intended use is:
     forthsamp({: xxx    [ calculate ]  LITERAL  ;})
Compilation is suspended for the compile time calculation of a
value. Compilation is resumed and forthcode({LITERAL}) compiles
this value.}) Later execution of the definition containing the literal will
push it to the stack. If executing in ciforth, the number will just remain on
the stack.},
{{LIT},{LITERAL}},
{ {: GS3 [ 45 ] LITERAL EMIT ; GS3},{E} },
enddoc)
HEADER({LITERAL},{LITER},{DOCOL}, , B_IMMED)
        DC      STATE
        DC      FETCH
        _0BRANCH(LITE1) ;{IF}
        DC      LIT, LIT, COMMA
        DC      COMMA   ;{THEN}
LITE1:  DC      SEMIS
;
worddoc( {COMPILING},{DLITERAL},{dliteral},{d --- d (executing) d --- (compiling)},{I},
{If compiling, compile a stack double number into a literal.
Later execution of the definition containing the literal will
push it to the stack. If executing in ciforth, the number will just remain on
the stack.},{{LITERAL},{LIT}},
{ {: GS3 [ 0.46 ] DLITERAL DROP EMIT ; GS3},{F} },
enddoc)
HEADER({DLITERAL},{DLITE},{DOCOL}, , B_IMMED)
        DC      STATE
        DC      FETCH
        _0BRANCH(DLIT1) ;{ IF}
        DC      SWAP
        DC      LITER
        DC      LITER   ;{ THEN}
DLIT1:  DC      SEMIS
;
;
worddoc( {COMPILING~},{SDLITERAL},{sdliteral},
{d --- s/d (executing) d --- (compiling)},{I},
{If compiling, compile a stack double number into a literal or
double literal, depending on whether forthcode({DPL}) contains a
nil pointer or points into the input. Later execution of the
definition containing the literal will push it to the stack. If
executing, the number will remain on the stack.},
{{SLITERAL},{DLITERAL}},
{
{: GS1 [ 0.46 ] SDLITERAL DROP EMIT ; GS1},{F} },
{: GS3 [ 45 ] SDLITERAL EMIT ; GS3},{E} },
},
enddoc)
HEADER({SDLITERAL},{SDLITE},{DOCOL}, , B_IMMED)
        DC      DPL
        DC      FETCH
        _0BRANCH(SDLIT1) ;{ IF}
        DC      DLITE
        _BRANCH(SDLIT2) ;{ IF}
SDLIT1:
        DC      DROP, LITER
SDLIT2:
        DC      SEMIS
;
_SECURITY_({
worddoc( {SECURITY},{?STACK},{question_stack},{},{},
{Issue an error message if the stack is out of bounds.},
{{?ERROR}},
{{ S0 @ DSP! ?STACK},{},
{0 WARNING ! : GS1 DROP ?STACK ;},{},
dnl Do not use the part of TIB that is corrupted!
 {                               GS1},{      GS1 ? MSG # 1 },
 {CR},{} },
enddoc)
HEADER({?STACK},{QSTAC},{DOCOL})
        DC      SPFET
        DC      SZERO
        DC      FETCH
        DC      SWAP
        DC      ULESS
        DC      ONE, QERR
        DC      SPFET
        DC      HERE
        DC      LIT,80H
        DC      PLUS
        DC      ULESS
        DC      LIT, 7, QERR
        DC      SEMIS
        PAGE
});_END_({_SECURITY_})
;
worddoc( {PARSING},{INTERPRET},{interpret},{},{},
{Repeatedly fetch the next text word in the input source and
execute it (forthcode({STATE}) is not 1) or compile it
(forthcode({STATE}) is 1). A word is blank-delimited and looked
up in the vocabularies of forthcode({SEARCH-ORDER}) . Failing that a
string consisting of the first character is looked up in the
forthcode({DENOTATION}) wordlist. If it is not found at all, it
is an forthcode({ERROR}).
_VERBOSE_({ If the word name cannot be found after a search of
forthcode({SEARCH-ORDER}), it is considered as a
forthdefi({denotation}) of a number, a double number, a
character or a string or whatever. Denotations are handled
respectively by the words forthcode({0}) ... forthcode({F})
forthcode({&}) forthcode({"}) and any other word of the
forthcode({DENOTATION}) wordlist, depending on the first
character. A number is converted according to the current base.
If a decimal point is found as part of a number, the number
value that is left is a double number, otherwise it is a single
number.})
},
{{WORD},{NUMBER},{BLK},{DPL}},
{{( No test)},{}},
enddoc)
HEADER({INTERPRET},{INTER},{DOCOL})
INTE1:
        DC      LPWORD
        DC      LDUP      ;{ Zero length.}
        _0BRANCH(INTE8) ;{WHILE}
;       DC      DOTS
;       DC      TDUP, LTYPE
        DC      OVER, TOR       ; {Save old parse pointer.}
        DC      FOUND
        DC      LDUP, ZEQU
        DC      LIT, 12, QERR
        DC      LDUP, TFFA, FETCH
        DC      LDUP, LIT, B_DENOT, LAND ;{Retain copy of flags.}
        _0BRANCH(INTE3B) ;{IF}
        DC      OVER, TNFA, FETCH, FETCH
        DC      RR, PLUS, LIN, STORE  ;{Skip over prefix.}
INTE3B:                  ;{THEN }
        DC      RDROP           ; {Drop old parse pointer.}
        DC      LIT, B_IMMED, LAND
        DC      STATE, FETCH, ZEQU, LOR
        _0BRANCH(INTE3) ;{IF}
        DC      EXEC
        _BRANCH(INTE4) ;{IF}
INTE3:
        DC      COMMA
                        ;{THEN}
INTE4:
        _SECURITY_({DC      QSTAC})
        _BRANCH(INTE1)  ;{AGAIN}
INTE8:  DC      DROP, DROP
        DC      SEMIS
;
worddoc( {DICTIONARY},{IMMEDIATE},{immediate},{},{},
{Mark the most recently made definition so that when encountered at
compile time, it will be executed rather than being compiled, i.e.
the immediate bit in its header is set.
This method allows definitions to handle unusual compiling
situations, rather than build them into the fundamental compiler.
The user may force compilation of an immediate definition by
preceeding it with forthcode({[COMPILE]}) .},{},
{ { : GS1 &Z EMIT ; IMMEDIATE : GS2 GS1 ;},{Z}},
enddoc)
HEADER({IMMEDIATE},{IMMED},{DOCOL})
        DC      LATEST
        DC      TFFA
        DC      LIT, B_IMMED
        DC      TOGGL
        DC      SEMIS
;
worddoc( {DEFINING},{VOCABULARY},{vocabulary},{},{FIG,E,L},
{A defining word used in the form: forthcode({VOCABULARY})
forthsamp({cccc}) to create a vocabulary definition
forthsamp({cccc}) . It will create a forthdefi({word list})in
the ISO sense. Subsequent use of forthsamp({cccc}) will push
this word list (the word list forthdefi({associated with})
forthsamp({cccc}))
to the top of the search order in forthcode({SEARCH-ORDER}). So
vocabulary which is searched first by forthcode({INTERPRET}) .

A vocabulary 's data content field contains at first the dovoc
pointer (like for any forthcode({DOES>}) word) , then follows
its forthdefi({body}) . The body contains the vocabulary link
field address ( forthdefi({VLFA}) ) The VLFA points to the VLFA
of the next vocabulary or 0 for the end.

Then follows a dummy dea that serves as forthdefi({word list
identifier}) or WID in the sense of the ISO standard. with
empty fields, except for the link field (forthdefi({DLFA}))
that points to the dea of the first word of the vocabulary
or a zero pointer if empty.
Executing the vocabulary means pushing its WID on top of the
forthcode({SEARCH-ORDER}) order. In ciforth when there can be at most
M4_MAXWORDLIST word list 's in the search order, the oldest one
gets lost.
By convention, vocabulary names are to be declared
forthcode({IMMEDIATE}) .},
{{VOC-LINK},{DEFINITIONS}},
{{123 VOCABULARY JOHN .},{123},
{123 JOHN . ONLY FORTH},{123}},
enddoc)
HEADER({VOCABULARY},{VOCAB},{DOCOL})
        DC      CREATE
        DC      LATEST   ;{ Link this DEA into VOC-LINK chain.}
        DC      VOCL
        DC      FETCH
        DC      COMMA
        DC      VOCL
        DC      STORE
        DC      ZERO, COMMA   ;{ Dummy code field}
        DC      ZERO, COMMA   ;{ Dummy data field}
        DC      LIT, B_DUMMY, COMMA ;{ Dummy flag field}
        DC      ZERO, COMMA ;{Links to the word FORTH}

        DC      DOES
DOVOC:
        DC      ALSO
        DC      CELLP   ;{ Make it a WID. }
        DC      SEARCH
        DC      STORE
        DC      SEMIS
        PAGE
;
;{   The link to task is a cold start value only.}
;{   It is updated each time a definition is}
;{   appended to the 'FORTH' vocabulary.}
;
worddoc( {WORDLISTS},{ASSEMBLER},{assembler},{},{NISO,FIG,I,L1},
{The name of the vocabulary to make machine code definitions.
In ciforth execution it pushes the associated word list to the
top of the forthcode({SEARCH-ORDER}) stack. (For ISO-compliance it
would replace the top of the stack.) forthcode({ASSEMBLER}) is
immediate, so it will execute during the creation of a
colon-definition, to select this vocabulary at compile time.
This word makes only sense in combination with the words that
belong to it. So it is present in loadable form in the screens
file forthfile({forth.lab}) .},
{{VOCABULARY},{LOAD}},
{{( No test) },{}},
enddoc)
;
worddoc( {WORDLISTS},{DEFINITIONS},{definitions},{},{ISO},
{Used in the form:
           forthsamp({cccc DEFINITIONS})
Make
the top most
forthcode({SEARCH-ORDER}) word list, the compilation, i.e.
forthcode({CURRENT}) word list.
In the example, executing
vocabulary name forthsamp({cccc}) add it to the top of the
forthcode({SEARCH-ORDER}) order and executing
forthcode({DEFINITIONS}) will result in new definitions added to
forthsamp({cccc}) .},
{{VOCABULARY}},
{
  { VOCABULARY JOHN JOHN DEFINITIONS : ORAN ; dnl
  ' FORTH >WID >LFA @ ' ORAN = .},{0},
  {' JOHN >WID >LFA @ ' ORAN = .},{_T_},
  {FORTH DEFINITIONS},{}
},
enddoc)
HEADER({DEFINITIONS},{DEFIN},{DOCOL})
        DC      SEARCH
        DC      FETCH
        DC      CURR
        DC      STORE
        DC      SEMIS
;
worddoc( {WORDLISTS},{ALSO},{also},{},{ISO},
{Duplicate the topmost forthdefi({wid}) in the SEARCH-ORDER order stack.
If there were already M4_MAXWORDLIST wid 's,
ciforth looses the last one,
This is not counting
the forthcode({ONLY}) search order.},
{{VOCABULARY}},
{
  { VOCABULARY JOHN ALSO ' JOHN >WID SEARCH-ORDER ! DEFINITIONS dnl
  : ORAN ; ' FORTH >WID >LFA @ ' ORAN = .},{0},
  {' JOHN >WID >LFA @ ' ORAN = .},{_T_},
  {FORTH DEFINITIONS},{}
},
enddoc)
HEADER({ALSO},{ALSO},{DOCOL})
        DC      SEARCH, LDUP, CELLP
        DC      LIT, _CELLS(M4_MAXWORDLIST-1)
        DC      LMOVE
        DC      LIT, FORTH  ;{End sentinel for array of word list's.}
        DC      SEARCH, LIT, _CELLS(M4_MAXWORDLIST), PLUS
        DC      STORE ;{Trim sets of wordset.}
        DC      SEMIS
;
worddoc( {WORDLISTS},{PREVIOUS},{PREVIOUS},{},{ISO},
{Pop the topmost forthdefi({wid}) from the forthcode({SEARCH-ORDER}) order stack.
If empty stil the forthcode({ONLY}) search order is left.},
{{VOCABULARY}},
{
  { SEARCH-ORDER @ VOCABULARY JOHN JOHN DUP SEARCH-ORDER @ = .},{0},
  { PREVIOUS SEARCH-ORDER @ = .},{_T_}
},
enddoc)
HEADER({PREVIOUS},{PREVI},{DOCOL})
        DC      SEARCH, LDUP, CELLP, SWAP
        DC      LIT, _CELLS(M4_MAXWORDLIST)
        DC      LMOVE
        DC      SEMIS
;
worddoc( {WORDLISTS},{ONLY},{ONLY},{},{NISO},
{Make the forthcode({SEARCH-ORDER}) order stack empty.
The word forthcode({FORTH}) can still be found,
such that one can regain control.
},
{{VOCABULARY}},
{
  {: test ONLY WORDS POSTPONE FORTH ; test},
{FORTH "   +   -   F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0   ^   &   '}
},
enddoc)
HEADER({ONLY},{ONLY},{DOCOL})
        DC      LIT, FORTH, SEARCH, STORE
        DC      SEARCH, LDUP, CELLP
        DC      LIT, _CELLS(M4_MAXWORDLIST-1)
        DC      LCMOVE
        DC      SEMIS
;
worddocsafe( {PARSING},{(},{paren},{},{ISO,FIG,I,L0},
{{{{Used in the form: forthsamp({( cccc)}). Ignore a comment that
will be delimited by a right parenthesis that must be in the
same input source, i.e. on the same line for terminal input, or
in the same string, block or file, when that is the input. It
is an immediate word{{}}_VERBOSE_({{, so colon definitions can
be commented too}}).
A blank after the word forthcode({{(}}) is required.}}}},
{{\}},
{{( Nothing to be seen) 8374 U.},{8374} },
enddoc)
HEADER({(},{PAREN},{DOCOL}, , B_IMMED)
        DC      LIT,')'
        DC      PPARS
        DC      TDROP
        DC      SEMIS
;
;
worddocsafe( {PARSING},{\},{backslash},{},{ISO,I,L0},
{Used in the form:
forthsamp({\ cccc})
Ignore a comment that will be delimited by the end of the current line.
May occur during execution or in a
colon-definition.
A blank after the word forthcode({\}) is required.},
{{(}},
{{\ Nothing to be seen 8374 .
},{} },
enddoc)
HEADER({\},{BACKS},{DOCOL}, , B_IMMED)
        DC      LIT,ALF
        DC      PPARS
        DC      TDROP
        DC      SEMIS
;
worddoc( {INIT},{QUIT},{quit},{},{ISO,FIG},
{Restart the interpreter. Clear the return stack, stop
compilation, and return control to the operators terminal,
or to the redirected input stream.
This means forthcode({ACCEPT}) user input to forthcode({TIB}) , and
then forthcode({INTERPRET}) with forthcode({TIB}) as a
forthcode({SOURCE}) .
No
message is given.},
{{ABORT}},
{{1243 QUIT
  . },{1243} },
enddoc)
HEADER({QUIT},{QUIT},{DOCOL})
        DC      LBRAC
QUIT1:                  ;{BEGIN}
        DC      RZERO
        DC      FETCH
        DC      RPSTO
        _LINUX_N_({DC      LIT})
        DC      PACCEP
_LINUX_N_({
        DC      CATCH
        _0BRANCH(OKAY)
        DC      BYE     ; {Nothing else can be done!}
OKAY:
});_END_({_LINUX_N_})
        DC       SETSRC
        DC      INTER
        DC      OK
        _BRANCH(QUIT1)  ;{AGAIN}
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
;
worddoc( {INIT},{OK},{ok},{},{ISO,FIG},
{Takes care of printing the "okay" message, after interpreting
a line. Default it prints okay only for an interactive session
in interpret forthcode({STATE}). },
{{QUIT},{COLD}},
{{OK ( Gives OK unless interpreted from stream)},{},
{: GS1 STATE @ 1 STATE ! OK STATE ! ; GS1},{}},
enddoc)
HEADER({OK},{OK},{DOCOL})
        DC      STATE
        DC      FETCH
        DC      ZEQU
        _0BRANCH(OK2) ;{IF}
        _STRINGINLINE({ OK})   ;{THEN}
        DC      LTYPE
        DC      CR
OK2:
        DC      SEMIS
;
worddoc( {INIT},{ABORT},{abort},{},{ISO,FIG,L0},
{Restart the system. In addition and before the actions of
forthcode({QUIT}), clear also the data stack and reset the
search order and numeric base to default.
_VERBOSE_({{As required by ISO it is silent. This may be confusing
at times, because you can't tell the difference between a word
that is still busy or that has aborted.}})
},{{WARM}},
{{( No test)},{}},
enddoc)
HEADER({ABORT},{ABORT},{DOCOL})
        DC      SZERO, FETCH, SPSTO
        DC      DECA
        _SECURITY_({DC      QSTAC})
        DC      ONLY
        DC      FORTH
        DC      DEFIN
        DC      QUIT
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
;
;{      WARM START VECTOR COMES HERE}
;{      For booting code we enter here, real mode and using the switchsegment.}
;{      BY control BREAK.}
WRM:
_BOOTED_({
SET_16_BIT_MODE         ;{Pops back at next _SWITCH_}
;{Without this clearing of the disk status, the system hangs too.}
        XOR     {AX},{AX}
        MOV     DL, DRIVE
        INT     13H     ;{Reset floppy disk system.}
        XOR     {AX},{AX}
        MOV     DL, 80H
        INT     13H     ;{Reset hard disk system.}
;{Without this clearing of the keyboard status, the system hangs at}
;{the next call of KEY (INT 10H function 0EH)}
        XOR     {AX},{AX}
        MOV     DS,{AX}
        MOV     [417H],{AX}
;        MOV     [496H],{AX} ;{This should improve things, but doesn't.}
});_END_({ _BOOTED_})
        _SWITCH_({JMPHERE_FROM_OS})
        MOV     HIP,_OFFSET WRM1
        _NEXT                   ;{Hope stacks are still okay.}
;
WRM1:   DC      WARM
;
worddoc( {INIT},{WARM},{warm},{},{FIG L0},
{Perform a so called "warm" start. In addition and before the
actions of forthcode({ABORT}), discard blocks; they may not be
written back to mass storage. Display the sign on message.
},{{ABORT}},
{{( No test)},{}},
enddoc)
HEADER({WARM},{WARM},{DOCOL})
        DC      MTBUF
        DC      SIGNON
        DC      ABORT
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
;
_LINUX_N_({
worddoc( {INIT},{OPTIONS},{options},{f1 -- f2},{FIG L0},
{Handle command line options. This is primarily a vector point
to suppress the handling of options during cold boot, in behalf of
turnkey applications. Accept and return an flag forthvar({f}) whether the signon
message must be displayed.
},{{COLD}},
{{( No test)},{}},
enddoc)
HEADER({OPTIONS},{OPTIONS},{DOCOL})
;       Execute option.
        DC      ARGS, FETCH, CELLP, CELLP, FETCH
        DC      LDUP
        _0BRANCH(COLD4) ; {No options}
        DC      FETCH
        DC      LDUP, LIT, 0FFH, LAND
        DC      LIT, '-', UNEQ
        _0BRANCH(COLD3)
        DC      LIT, 3, LDUP, MESS, CR ; {Fatal, but can't use ERROR.}
; { I can't help it. May god have mercy with me. }
; { I use 'ONE' instead of 'LIT, exit,' to save one cell.}
        DC      ZERO, ZERO, ONE, LINOS ; {Exit with error 3.}
COLD3:
        DC      LIT, 8, RSHIFT
        DC      LIT, 1FH, LAND
        DC      LOAD
        DC      ZERO, SWAP ;{ Sign on suppressed.}
COLD4:
        DC      DROP
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
});_END_({_LINUX_N_})

worddoc( {INIT},{COLD},{cold},{},{FIG},
{Reinitialise the system. Clear all block buffers.
Reinitialise all user variables to their boot up values
values, i.a. the stacks and the dictionary pointers. Restart via
forthcode({ABORT}) . May be called from the terminal to remove
application programs and restart, as long as there are no
new vocabularies with definitions.
_HOSTED_({But it is better to say forthcode({BYE}) to Forth and start again.})
_BOOTED_({But it is better to reboot.})
_BLOCKSINFILE_({Opens the file that contains the blocks.})
},{{WARM},{BLOCK},{LIST}},
{{( No test)},{}},
enddoc)
HEADER({COLD},{COLD},{DOCOL})
        DC      ZERO, HANDLER, STORE
        DC      MTBUF
        DC      FIRST
        DC      STALEST,STORE
        DC      FIRST
        DC      PREV,STORE
;{ Fill user area for single task.}
        DC      LIT, USINI
        DC      LIT, USINI+_CELLS(1), FETCH
        DC      LIT, US
        DC      LCMOVE
_BLOCKSINFILE_({
        DC      BLINI
});_END_({_BLOCKSINFILE_})
        DC      DECA
        DC      ONLY
        DC      FORTH
        DC      DEFIN
_LINUX_N_({
        DC      ONE            ; {Sign on wanted.}
        DC      ZERO, LIT, TCGETS, TERMIO
        DC      LIT, ioctl, LINOS, ZLESS
        _0BRANCH(COLD1)
        ;{ Not a terminal. Cannot set the terminal, get rid of "OK".}
        DC      DROP, ZERO      ;{ Sign on suppressed.}
        DC      LIT,NOOP  ; {Suppress OK for pipes.}
        DC      LIT,OK
        DC      LIT, _CELLS(3), LCMOVE
COLD1:  DC      OPTIONS
        _0BRANCH(COLD5)
});_END_({_LINUX_N_})
        DC      SIGNON    ; {Suppressed for scripting! Or any options.}
COLD5:
        DC      ABORT
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
;
worddoc( {DOUBLE},{S>D},{s_to_d},{n --- d},{ISO},
{Sign extend a single number to form a double number.},{},
{{ 0 S>D D.},{0},
 { 1 S>D D.},{1},
 { -1 S>D D.},{-1} },
enddoc)
CODE_HEADER({S>D},{STOD})
        POP     DX      ;{S1}
        SUB     AX,AX
        OR      DX,DX
        JNS     STOD1   ;{POS}
        DEC     AX      ;{NEG}
STOD1:  _2PUSH
;
worddoc( {OPERATOR},{ABS},{abs},{n --- u},{ISO,FIG,L0},
{Leave the absolute value of forthvar({n}) as forthvar({u}) .},
{{DABS}},
{
{ 0  ABS .},{0 },
{ 1  ABS .},{1 },
{ -1 ABS .},{1}
},
enddoc)
HEADER({ABS},{LABS},{DOCOL})
        DC      LDUP
        DC      ZLESS
        _0BRANCH(PM1)   ;{IF}
        DC      NEGATE   ;{THEN}
PM1:
        DC      SEMIS
;
worddoc( {DOUBLE},{DABS},{d_abs},{d --- ud},{ISO,FIG},
{Leave the absolute value forthvar({ud}) of a double number forthvar({d}) .},
{{DNEGATE},{ABS}},
{
{ 0.  DABS D.},{0},
{ 1.  DABS D.},{1},
{ -1. DABS D.},{1}
},
enddoc)
HEADER({DABS},{DABS},{DOCOL})
        DC      LDUP
        DC      ZLESS
        _0BRANCH(DPM1)  ;{IF}
        DC      DNEGA   ;{THEN}
DPM1:
        DC      SEMIS
;
worddoc( {OPERATOR},{MIN},{min},{n1 n2 --- min},{ISO,FIG,L0},
{Leave the smaller of two numbers.},{{MAX}},
{{ 204 240 MIN .},{204},
 { -204 -240 MIN .},{-240} },
enddoc)
HEADER({MIN},{MIN},{DOCOL})
        DC      TDUP
        DC      GREAT
        _0BRANCH(MIN1)  ;{IF}
        DC      SWAP    ;{THEN}
MIN1:   DC      DROP
        DC      SEMIS
;
worddoc( {OPERATOR},{MAX},{max},{n1 n2 --- max},{ISO,FIG,L0},
{Leave the greater of two numbers.},{{MIN}},
{{ 204 240 MAX .},{240},
 { -204 -240 MAX .},{-204} },
enddoc)
HEADER({MAX},{MAX},{DOCOL})
        DC      TDUP
        DC      LESS
        _0BRANCH(MAX1)  ;{IF}
        DC      SWAP    ;{THEN}
MAX1:   DC      DROP
        DC      SEMIS
;
worddoc( {OPERATOR},{LSHIFT},,{u1 n --- u2},{ISO},
{Perform a forthsamp({{logical {{shift}} }}) of the bits of
forthvar({u1}) to the left by forthvar({n}) places.
_VERBOSE_({{Put zero into the places uncovered by the {{shift}}.}}) },
{{RSHIFT},{2*}},
{{1 2 LSHIFT .},{4}},
enddoc)
CODE_HEADER({LSHIFT},{LSHIFT},{DOCOL})
        POP     CX
        POP     AX
        SHL     AX,CL
        _PUSH
;
worddoc( {OPERATOR},{RSHIFT},,{u1 n --- u2},{ISO},
{Perform a forthsamp({{logical {{shift}}}}) of the bits of
forthvar({u1}) to the right by forthvar({n}) places.
_VERBOSE_({{Put zero into the places uncovered by the {{shift}}.}}) },
{{LSHIFT},{2/}},
{{4 2 RSHIFT .},{1}},
enddoc)
CODE_HEADER({RSHIFT},{RSHIFT},{DOCOL})
        POP     CX
        POP     AX
        SHR     AX,CL
        _PUSH
;
worddoc( {MULTIPLYING},{M*},{m_star},{n1 n2 --- d},{ISO,FIG,L0},
{A mixed magnitude math operation which leaves the double
number forthvar({d}) : the signed product of two signed number
forthvar({n1}) and forthvar({n2}) .},
{{M/MOD},{SM/REM},{*}},
{ { -1 -1 M* D. },{1},
  {DECIMAL 240 204 M* D.},{48960} },
enddoc)
HEADER({M*},{MSTAR},{DOCOL})
        DC      TDUP
        DC      LXOR
        DC      TOR
        DC      LABS
        DC      SWAP
        DC      LABS
        DC      USTAR
        DC      FROMR
        DC      ZLESS
        _0BRANCH(DPM2)  ;{IF}
        DC      DNEGA   ;{THEN}
DPM2:
        DC      SEMIS
;
worddoc( {MULTIPLYING},{SM/REM},{m_slash},{d n1 --- n2 n3},{ISO},
{A mixed magnitude math operator which leaves the signed
remainder forthvar({n2}) and signed quotient forthsamp({n3})
from a double number dividend forthvar({d}) and divisor
forthvar({n1}). This is a symmetic division{{}}_VERBOSE_({{, i.e.
the remainder takes its sign from the
dividend.}})},
{{M/MOD},{/},{M*}},
{
{  7 S>D  3 SM/REM . . },{2   1},
{  7 S>D -3 SM/REM . . },{-2   1},
{ -7 S>D  3 SM/REM . . },{-2  -1},
{ -7 S>D -3 SM/REM . . },{2  -1}
},
enddoc)
CODE_HEADER({SM/REM},{MSLAS})
        POP     BX      ;{DIVISOR}
        POP     DX      ;{MSW OF DIVIDEND}
        POP     AX      ;{LSW OF DIVIDEND}
        IDIV     BX      ;{16 BIT DIVIDE}
        _2PUSH          ;{STORE QUOT/REM}
;
_LOAD_({
worddoc( {SUPERFLUOUS},{2/},{two_slash},{n1 --- n2},{ISO},
{Perform an arithmetical {{shift}} right.
The bit pattern of forthvar({n1}) is shifted to the right, except that
the left most bit (``sign bit'') remains the same.
_VERBOSE_({{ This is the same as forthsamp({S>D 2 FM/MOD SWAP
DROP}). It is not the same as forthsamp({2 /}), nor is it the
same as forthsamp({1 RSHIFT}). This confusing word should never
be used.}})},
{{2*} },
{
{2 2/ . },{1},
{-2 2/ . },{-1},
{-1 2/ . },{-1},
},
enddoc)
HEADER({2/},{TWOSL},{DOCOL})
        DC      STOD, TWO, FMSLAS
        DC      SWAP, DROP
        DC      SEMIS
;
worddoc( {SUPERFLUOUS},{2*},{two_star},{n1 --- n2},{ISO},
{Perform an arithmetical {{shift}} left.
The bit pattern of forthvar({n1}) is shifted to the left,
with a result indentical to forthsamp({1 LSHIFT}).
_VERBOSE_({This word should not be used.})},
{{2/} },
{
{  2 2* . },{4},
{  -2 2* . },{-4},
},
enddoc)
HEADER({2*},{TWOST},{DOCOL})
        DC      TWO, STAR
        DC      SEMIS
;
worddoc( {SUPERFLUOUS},{1-},{one_minus},{n1 --- n2},{ISO},
{ This is the shorthand for forthsamp({1 -}). },
{{1+} },
{
{  2 1- . },{1},
{  -2 1- . },{-3},
},
enddoc)
HEADER({1-},{ONEM},{DOCOL})
        DC      ONE, LSUB
        DC      SEMIS
;
});_END_({_LOAD_})
worddoc( {MULTIPLYING},{FM/MOD},{floored_slash},{d n1 --- n2 n3},{ISO},
{A mixed magnitude math operator which leaves the signed
remainder forthvar({n2}) and signed quotient forthsamp({n3})
from a double number dividend forthvar({d}) and divisor
forthvar({n1}). This is floored division{{}}_VERBOSE_({{, i.e.
the remainder takes its sign from the divisor.}})},
{{SM/REM}, {M/MOD},{/},{M*}},
{
{  7 S>D  3 FM/MOD . . },{2   1},
{  7 S>D -3 FM/MOD . . },{-3   -2},
{ -7 S>D  3 FM/MOD . . },{-3  2},
{ -7 S>D -3 FM/MOD . .     6 S>D -3 FM/MOD . .},
{2  -1 -2   0}
},
enddoc)
HEADER({FM/MOD},{FMSLAS},{DOCOL})
        DC      LDUP, TOR
        DC      TDUP, LXOR, TOR
        DC      MSLAS
        DC      FROMR, ZLESS
        _0BRANCH(FMMOD1)
        DC      OVER
        _0BRANCH(FMMOD1)
        DC      ONE, LSUB
        DC      SWAP, FROMR, PLUS, SWAP
        _BRANCH(FMMOD2)
FMMOD1:
        DC      RDROP
FMMOD2:
        DC      SEMIS
;
worddocsafe( {OPERATOR},{*},{star},{n1 n2 --- n3},{ISO,FIG,L0},
{Leave the signed product forthvar({n3}) of two signed numbers
forthvar({n1}) and forthvar({n2}) .},
{{+},{-},{/},{MOD}},
{
  {DECIMAL 24 204 * .},{4896} },
  {DECIMAL -24 204 * .},{-4896} }
},
enddoc)
HEADER({*},{STAR},{DOCOL})
        DC      MSTAR
        DC      DROP
        DC      SEMIS
;
worddoc( {OPERATOR},{/MOD},{slash_mod},{n1 n2 --- rem quot},{ISO,FIG,L0},
{Leave the remainder and signed quotient of forthvar({n1}) and forthvar({n2}) .
The remainder has the sign of the dividend
(forthdefi({symmetric division})). },
{{*/MOD},{*/},{SM/REM}},
{
{  7  3 /MOD . . },{2   1},
{  7 -3 /MOD . . },{-2   1},
{ -7  3 /MOD . . },{-2  -1},
{ -7 -3 /MOD . . },{2  -1}
},
enddoc)
HEADER({/MOD},{SLMOD},{DOCOL})
        DC      TOR
        DC      STOD
        DC      FROMR
        DC      MSLAS
        DC      SEMIS
;
worddoc( {OPERATOR},{/},{slash},{n1 n2 --- quot},{ISO,FIG,L0},
{Leave the signed quotient of forthvar({n1}) and forthvar({n2}) .
(forthdefi({symmetric division})). },
{{+},{-},{*},{MOD},{*/MOD}},
{
{  7  3 / . },{2  },
{  7 -3 / . },{-2 },
{ -7  3 / . },{-2 },
{ -7 -3 / . },{2  }
},
enddoc)
HEADER({/},{SLASH},{DOCOL})
        DC      SLMOD
        DC      SWAP
        DC      DROP
        DC      SEMIS
;
worddoc( {OPERATOR},{MOD},{mod},{n1 n2 --- mod},{ISO,FIG,L0},
{Leave the remainder of forthsamp({n1}) divided by forthvar({n2}) , with the same sign
as forthvar({n1}) (forthdefi({symmetric division})).},
{{+},{-},{*},{/},MOD,{*/MOD}},
{
{  7  3 MOD . },{1},
{  7 -3 MOD . },{1},
{ -7  3 MOD . },{-1},
{ -7 -3 MOD . },{-1}
},
enddoc)
HEADER({MOD},{LMOD},{DOCOL})
        DC      SLMOD
        DC      DROP
        DC      SEMIS
;
worddoc( {MULTIPLYING},{*/MOD},{start_slash_mod},{n1 n2 n3 --- n4 n5},{ISO,FIG,L0},
{Leave the quotient forthsamp({n5}) and remainder forthsamp({n4})
of the operation forthsamp({n1*n2/n3}) A double precision
intermediate product is used as for forthcode({*/})
(forthdefi({symmetric division})).}, {{*/},{/MOD}},
{
{ 7 2 3   */MOD . . },{4  2 },
{ 7 2 -3  */MOD . . },{-4 2 },
{ -7 2 3  */MOD . . },{-4 -2 },
{ -7 2 -3 */MOD . . },{4 -2 }
},
enddoc)
HEADER({*/MOD},{SSMOD},{DOCOL})
        DC      TOR
        DC      MSTAR
        DC      FROMR
        DC      MSLAS
        DC      SEMIS
;
worddoc( {MULTIPLYING},{*/},{star_slash},{n1 n2 n3 --- n4},{ISO,FIG,L0},
{Leave the ratio forthsamp({n4 = n1*n2/n3}) where all are signed
numbers(forthdefi({symmetric division})). Retention of a double
precision intermediate product permits greater accuracy than
would be available with the sequence:
      forthsamp({n1 n2 * n3 /})
},
{{*/MOD},{/MOD}},
{
{ 7 2 3   */ . },{4 },
{ 7 2 -3  */ . },{-4 },
{ -7 2 3  */ . },{-4 },
{ -7 2 -3 */ . },{4 },
}, enddoc)
HEADER({*/},{SSLA},{DOCOL})
        DC      SSMOD
        DC      SWAP
        DC      DROP
        DC      SEMIS
;
worddoc( {MULTIPLYING},{M/MOD},{m_slash_mod},{ud1 u2 --- u3 ud4},{CIF,FIG},
{An unsigned mixed magnitude math operation which leaves a
double quotient forthsamp({ud4}) and remainder forthsamp({u3}) ,
from a double dividend forthvar({ud1}) and single divisor
forthvar({u2}) .},
{{UM/MOD},{SM/REM},{M*}},
_BITS16_({
{
{-1. -1 M/MOD D. .},{10001 0},
{ 88812.34 100 M/MOD D. .},{88812 34},
{DECIMAL 12.34 100 M/MOD D. .},{12 34},
} })
_BITS32_({
{
{-1. -1 M/MOD D. .},{100000001 0},
{ 8888812.34 100 M/MOD D. .},{8888812 34},
{DECIMAL 12.34 100 M/MOD D. .},{12 34},
} })
,
enddoc)
HEADER({M/MOD},{MSMOD},{DOCOL})
        DC      TOR
        DC      ZERO
        DC      RR
        DC      USLAS
        DC      FROMR
        DC      SWAP
        DC      TOR
        DC      USLAS
        DC      FROMR
        DC      SEMIS
;
worddocsafe( {SCREEN},{(LINE)},{paren_line},{n1 n2 --- sc },{},
{Convert the line number forthsamp({n1}) and the screen
forthvar({n2}) to a string forthvar({sc}) the content of the
line (without the trailing new line). },
{{LINE}},
{
{1 0 (LINE) TYPE}, { LICENSE }
},
enddoc)
HEADER({(LINE)},{PLINE},{DOCOL})
        DC      TOR
        DC      LIT,64
        DC      MSTAR
        DC      BBUF
        DC      FMSLAS
        DC      FROMR ;{ This blocks, so is screens.}
        DC      PLUS
        DC      BLOCK
        DC      PLUS
        DC      LIT,63  ;{ Leave off the '\n'.}
        DC      SEMIS
;
worddoc( {SCREEN},{.LINE},{dot_line},{line scr --},{},
{Print on the terminal device, a line of text from the disc by its
line and screen number. _VERBOSE_(
{{Trailing blanks are suppressed,
which leads to a tremendous speed advantage on modern glass tty's.}})},
{{C/L}},
{
{1 0 .LINE}, { LICENSE }
},
enddoc)
HEADER({.LINE},{DLINE},{DOCOL})
        DC      PLINE
        DC      DTRAI
        DC      LTYPE
        DC      SEMIS
;
;
worddoc( {ERRORS},{ERRSCR},{error_screen},{--- addr},{},
{A variable containing the address of the number of the screen
from which messages are offset. Messages
correspond with lines and the offset
may be positive or negative.
forthsamp({0 MESSAGE}) prints the first line of this screen.
_VERBOSE_({Traditionally this was screen 4, but the negative
Unix error numbers makes this unattractive.})
},{{C/L},{MESSAGE}},
{{HEX ERRSCR ?},{20}},
enddoc)
HEADER({ERRSCR},{ERRSCR},{DOVAR}, )
        DC ERRORSCREEN
;
worddoc( {ERRORS},{MESSAGE},{message},{n --},{},
{Print on the selected output device the text of line
forthvar({n}) relative to screen forthcode({ERRSCR}) . forthvar({n}) may be
positive or negative and beyond just screen forthcode({ERRSCR}).
forthcode({MESSAGE}) is generally used to print error and
warning messages.
_PC_({This ciforth contains only messages with positive offset.})
_HOSTED_LINUX_({The messages with only with negative offset contain
the strings belonging to the return values for Linux system calls.})
forthsamp({0 MESSAGE}) will print version information about the library file,
the messages sit in.
If forthcode({WARNING}) is zero, the message will simply be
printed as a number (disc unavailable) in decimal, ignoring the
current forthcode({BASE}).
},
{{ERROR}},
{
{1 WARNING ! -190 MESSAGE}, {( -g This_option_is_available )},
{0 WARNING ! HEX 12 MESSAGE},{MSG # 18 }},
enddoc)
HEADER({MESSAGE},{MESS},{DOCOL})
        DC      LWARN
        DC      FETCH
        _0BRANCH(MESS1) ;{IF}
        DC      ERRSCR, FETCH
        DC      DLINE
        DC      SPACE   ;{THEN}
        _BRANCH(MESS2)  ;{ELSE}
MESS1:  _STRINGINLINE({MSG # })
        DC      LTYPE
        DC      BASE, FETCH
        DC      DECA
        DC      SWAP, DOT
        DC      BASE, STORE
MESS2:                      ;{THEN}
        DC      SEMIS
;
_PC_({
worddocsafe( {MEMORY},{PC@},{port_char_fetch},{port --- b},{},
{Fetch a byte forthvar({b}) from the port address
forthsamp({port}). A port address is always 16 bits .},
{{PC!},{P@},{P!},{@}},
{{( No test)},{}},
enddoc)
CODE_HEADER({PC@},{PCFET})
;{ FETCH CHARACTER (BYTE) FROM PORT}
        POP     DX      ;{ PORT ADDR}
        XOR     AX,AX
        IN      AL,{DX}  ;{ BYTE INPUT}
        _PUSH
;
worddoc( {MEMORY},{PC!},{port_char_store},{b port --- },{},
{Store a byte forthvar({b}) to the port address
forthsamp({port}).
A port address is always 16 bits .},
{{PC@},{P!},{P@},{!}},
{{( No test)},{}},
enddoc)
CODE_HEADER({PC!},{PCSTO})
        POP     DX      ;{PORT ADDR}
        POP     AX      ;{DATA}
        OUT     {DX},AL   ;{ BYTE OUTPUT}
        _NEXT
;
worddocsafe( {MEMORY},{P@},{port_fetch},{port --- n},{},
{Fetch the _BITS_ bit contents forthvar({n}) from the port address
forthsamp({port}). A port address is always 16 bits .},
{{P!},{PC@},{PC!},{@}},
{{( No test)},{}},
enddoc)
CODE_HEADER({P@},{PFET})
        POP     DX      ;{PORT ADDR}
        IN      AX,{DX}  ;{WORD INPUT}
        _PUSH
;
worddoc( {MEMORY},{P!},{port_store},{n port --- },{},
{Store the _BITS_ bit data forthvar({n}) to the port address
forthsamp({port}) .},
{{P@},{PC!},{PC@},{!}},
{{( No test)},{}},
enddoc)
CODE_HEADER({P!},{PSTO})
        POP     DX      ;{PORT ADDR}
        POP     AX      ;{DATA}
        OUT     {DX},AX   ;{WORD OUTPUT}
        _NEXT
;
});_END_({_PC_})
worddoc( {STORAGE~},{STALEST},{stalest},{--- addr},{},
{A variable containing the address of the oldest
block buffer, the first candidate to be claimed if a new
one is needed.},{{BLOCK}},
{ { STALEST @ FIRST LIMIT WITHIN .},{_T_} },
enddoc)
HEADER({STALEST},{STALEST},{DOVAR}, )
        DC BUF1
;
worddoc( {STORAGE~},{PREV},{prev},{---- addr},{},
{A variable containing the address of the disc buffer (not its
content field!) most recently referenced. The
forthcode({UPDATE}) command marks this buffer to be
written to disc.},{{(BUFFER)}},
{ { STALEST @ FIRST LIMIT WITHIN .},{_T_} },
enddoc)
HEADER({PREV},{PREV},{DOVAR}, )
        DC      BUF1
;
worddoc( {STORAGE},{#BUFF},{hash_buf},{--- c},{},
{A constant that leaves the number of block buffers.
Because a buffer that is being interpreted is locked in memory,
this is also a limit to the nesting depth of blocks loading other
blocks. },
{{BLOCK},{THRU},{LOAD},{LOCK}},
{{#BUFF 100 U< .},{_T_} },
enddoc)
HEADER({#BUFF},{NOBUF},{DOCON}, NBUF)
;
worddoc( {STORAGE~},{+BUF},{plus_buf},{add1 --- addr2 f},{FIG},
{Advance the disc buffer address forthvar({addr1}) to the address of
the next buffer forthvar({addr2}) . Boolean forthvar({f}) is false
when forthvar({addr2}) is the buffer presently pointed to by variable
forthcode({PREV}).
},{{BLOCK}},
{
{ PREV @ DUP +BUF DROP DUP PREV ! FIRST LIMIT WITHIN .},{_T_},
{ +BUF . DUP FIRST LIMIT WITHIN .},{0 _T_},
{ +BUF 0= . DUP FIRST LIMIT WITHIN .},{0 _T_},
}, enddoc)
HEADER({+BUF},{PBUF},{DOCOL})
        DC      LIT,(KBBUF+2*CW)
        DC      PLUS,LDUP
        DC      LIMIT,EQUAL
        _0BRANCH(PBUF1)
        DC      DROP,FIRST
PBUF1:  DC      LDUP, PREV, FETCH, LSUB
        DC      SEMIS
;
worddoc( {STORAGE},{UPDATE},{update},{},{ISO,FIG,L0},
{Marks the most recently referenced block (pointed to by
forthcode({PREV}) ) as altered. The block will subsequently be
transferred automatically to disc should its buffer be required for
storage of a different block. In fact the block is transferred
to disk immediately.},{{BLOCK},{SCREEN}},
{{!CSP 1 BLOCK DROP UPDATE ?CSP},{} },
},
enddoc)
HEADER({UPDATE},{UPDAT},{DOCOL})
        DC      PREV, FETCH
        DC      LDUP, CELLP,CELLP
        DC      SWAP, FETCH
        DC      LOFFSET,  FETCH, PLUS
        DC      ZERO
        DC      RSLW
        DC      SEMIS
;
worddoc( {STORAGE},{EMPTY-BUFFERS},{empty_buffers},{},{ISO FIG L0},
{Mark all block-buffers as empty. Updated blocks are not
written to the disc. This is an initialization proceedure
before first use of the disc. _VERBOSE_({The usage as an
``undo'' is unfeasible in ciforth.}) },
{{FLUSH},{BLOCK},{SCREEN},{UPDATE}},
{{!CSP EMPTY-BUFFERS ?CSP},{}},
enddoc)
HEADER({EMPTY-BUFFERS},{MTBUF},{DOCOL})
        DC      FIRST
        DC      LIMIT,OVER
        DC      LSUB,LERASE
        DC      SEMIS
        PAGE
;
worddocsafe({STORAGE~},{(BUFFER)},{paren_buffer},{n --- addr},{},
{Return the addres forthvar({addr}) of a buffer assigned to
block forthvar({n}) .
The buffer layout is as follows: a cell
with the block number, a cell with the status, and the
content. The status is negative for locked, zero for free and
one for present and unlocked.
The block is not read from the disc. The buffer
is either one that was already assigned, or else a free buffer.
If there is none free, the stalest buffer is freed. The
contents of that buffer is written to the disc, if it was
marked as updated. In ciforth this is never needed, because
updated blocks are written immediately. In ciforth blocks can
be locked, and locked buffers are never freed by
forthcode({(BUFFER)}) .
_VERBOSE_({{An update flag would somehow be
multiplexed with the lock count, but it is not needed in
ciforth.}}) If all buffers were locked, forthcode({(BUFFER)})
freezes the system.
},
{{BLOCK},{STALEST},{PREV},{#BUFF},{LOCK},{UNLOCK}},
{{!CSP 1 (BUFFER) FIRST LIMIT WITHIN . ?CSP},{_T_}},
enddoc)
HEADER({(BUFFER)},{BUFFER},{DOCOL})
;{ Find the buffer, if it is already here.}
    DC      PREV, FETCH
BUFFER1:
    DC          TOR, RR, FETCH, OVER, EQUAL
    _0BRANCH(BUFFER3)
    DC        DROP, FROMR, EXIT
BUFFER3:
    DC          FROMR
    DC      PBUF, ZEQU
    _0BRANCH(BUFFER1)
    DC       DROP
;{ Just allocate the stalest buffer.}
    DC       STALEST,   FETCH, TOR
;{ Remember the next stalest buffer. }
    DC       RR
BUFFER2:
    DC       PBUF, OVER, CELLP, FETCH,
    DC       LIT, -1, GREAT, LAND
    _0BRANCH(BUFFER2)
    DC       STALEST, STORE
;{ Fill in the house keeping.}
    DC       RR, STORE
    DC       ZERO, RR, CELLP, STORE
    DC       RR, PREV, STORE
    DC       FROMR
    DC  SEMIS
;

worddoc( {STORAGE},{BLOCK},{block},{n --- addr},{ISO FIG L0},
{Leave forthvar({addr}) the disc buffer containing block
forthvar({n}), which is the physical disk block
forthsamp({OFFSET+n}). The address left is the field within the
buffer to be used for data storage. If the block is not already
in memory, it is transferred from disc to a new buffer allocated
by forthcode({(BUFFER)}) .
_VERBOSE_({Blocks are generally
used to contain source code to be interpreted
by forthcode({LOAD}). They can be equally useful to contain
other data, e.g. for implementing a database. })
_FEWBLOCKS_({In this experimental version forthsamp({PMASK})
restricts the number of blocks to 0FFH.})},
{{(BUFFER)},{R/W},{OFFSET},{UPDATE},{FLUSH},{LOAD}},
{{!CSP 1 BLOCK FIRST LIMIT WITHIN . ?CSP},{_T_} },
enddoc)
HEADER({BLOCK},{BLOCK},{DOCOL})
_FEWBLOCKS_({        DC      LIT, PMASK, LAND})
        DC      BUFFER
        DC      LDUP, CELLP, FETCH, ZEQU
        _0BRANCH(BLOCK1)
        DC      LDUP, CELLP, CELLP
        DC      OVER, FETCH
        DC      LOFFSET,  FETCH, PLUS
        DC      ONE
        DC      RSLW
        DC      ONE, OVER, CELLP, STORE
BLOCK1:
        DC      LDUP, PREV, STORE
        DC      CELLP, CELLP
        DC      SEMIS
;
worddoc( {STORAGE~},{FLUSH},{flush},{},{ISO FIG L0},
{Make sure that the content of all forthcode({UPDATE}) d block buffers
has been transferred to disk.
They are no longer associated with a block and their content is
no longer available.
},{{EMPTY-BUFFERS},{BLOCK},{SCREEN}},
{{1 BLOCK DROP PREV @ @ 0= . FLUSH PREV @ @ 0= .},{0 _T_} },
},
enddoc)
HEADER({FLUSH},{FLUSH}, {DOCOL}, _VAR_FIELD({MTBUF}))

; Unlock all buffers
        DC      LIMIT
        DC      FIRST, CELLP
        _DO(FLUS2)
FLUS1:  DC      ZERO, IDO, STORE
        DC      LIT,(KBBUF+2*CW)
        DC      PLOOP
        DC      (FLUS1-$)
FLUS2:
        DC      SEMIS
;
worddoc( {STORAGE~},{SAVE},{save},{ --- },{},
{Save the content of forthcode({SRC}) on the return stack
prior to changing the forthdefi({current input source}).
This must be balanced by a RESTORE in the same definition.},
{{RESTORE},{SAVE-INPUT}},
{{!CSP : GS1 SAVE 0 IN ! RESTORE ; GS1 34 . ?CSP},{34} },
},
enddoc)
HEADER({SAVE},{SAVE},{DOCOL})
        DC      FROMR
        DC      SRC, TFET
        DC      LIN, FETCH
        DC      TOR, TOR, TOR
        DC      TOR
        DC SEMIS
;
worddoc( {STORAGE~},{RESTORE},{restore},{ --- },{},
{This must follow a forthcode({SAVE}) in the same definition.
Restore the content of forthcode({SRC}) from the return stack
thusly restoring the forthdefi({current input source}) to what
it was when the forthcode({SAVE}) was executed.
},
{{RESTORE-INPUT},{SAVE-INPUT}},
{{( Via SAVE)},{}},
enddoc)
HEADER({RESTORE},{RESTO},{DOCOL})
        DC      FROMR
        DC      FROMR, FROMR, FROMR
        DC      LIN, STORE
        DC      SRC, TSTOR
        DC      TOR
        DC SEMIS
;
_LOAD_({
worddoc( {STORAGE~},{SAVE-INPUT},{save_input},{ --- n1 n2 n3 3},{ISO},
{Get a complete specification of the input source stream. For
ciforth this is the content of forthcode({SRC}). ciforth needs
3 cells, and is always able to forthcode({RESTORE}) an input
saved like this. _VERBOSE_({In practice the use of
forthcode({SAVE-INPUT}) should be restricted to restoring input
of the same stream.
}) },
{{RESTORE},{RESTORE-INPUT}},
{{!CSP : GS1 SAVE-INPUT 0 IN ! RESTORE-INPUT ; dnl
    GS1 34 . ?CSP},{34} },
enddoc)
HEADER({SAVE-INPUT},{SAVEI},{DOCOL})
        DC      SRC, TFET
        DC      LIN, FETCH
        DC      LIT, 3
        DC SEMIS
;
worddoc( {STORAGE~},{RESTORE-INPUT},{restore_input},{ n1 n2 n3 3--- f},{ISO},
{Restore the input source stream from what was saved by
SAVE-INPUT .
ciforth is always able to restore the input across
different input sources, as long as the input to be restored was
not exhausted. This has the effect of chaining, and doesn't
effect the return from nested calls be it interpreting, loading
or evaluating. _VERBOSE_({{The input source abandoned will
never be closed properly, so use should be restricted to the same
input source. }}) },
{{RESTORE},{SAVE-INPUT}},
{{( Via SAVE-INPUT)},{}},
enddoc)
HEADER({RESTORE-INPUT},{RESTOI},{DOCOL})
        DC      DROP
        DC      LIN, STORE
        DC      SRC, TSTOR
        DC SEMIS
;
});_END_({_LOAD_})
worddoc( {STORAGE},{LOCK},{lock},{ n --- },{CI},
{Lock the block forthvar({n}).
Multiple locks are possible, and require multiple unlocks.
_VERBOSE_({{Probably, because it
is to become the forthdefi({current input source}).}})
The result is that its buffer will not be reclaimed
until a forthcode({UNLOCK}) occurs.},
{{BLOCK},{UNLOCK},{#BUFF}},
{ {EMPTY-BUFFERS 1 BLOCK DROP 1 LOCK dnl
    PREV @ CELL+ @ . FLUSH PREV @ CELL+ @ 0= .},{-1 _T_} },
enddoc)
HEADER({LOCK},{LLOCK},{DOCOL})
        DC      BLOCK
        DC      LIT, CW, LSUB
        DC      LIT, -2, SWAP, PSTORE
        DC      SEMIS
;
worddoc( {STORAGE},{UNLOCK},{unlock},{ n --- },{CI},
{Unlock the block forthvar({n})
_VERBOSE_({{Probably, because it
is no longer the forthdefi({current input source.})}})
The result is that its buffer can again be reclaimed.
Unlocking without a previous lock may lead to a crash.
},
{{LOCK},{#BUFF}},
{
{EMPTY-BUFFERS 1 BLOCK DROP 1 LOCK dnl
 PREV @ CELL+ @ . 1 UNLOCK PREV @ CELL+ @ .},{-1 1} },
},
enddoc)
HEADER({UNLOCK},{LUNLOCK},{DOCOL})
        DC      BLOCK
        DC      LIT, CW, LSUB
        DC      TWO, SWAP, PSTORE
        DC      SEMIS
;
worddoc( {SCREEN},{LOAD},,{n --- ??},{ISO,FIG,L0},
{Interrupt the forthdefi({current input source}) in order to
interpret screen forthvar({n}) .
_VERBOSE_({{The stack changes in according with the words executed.}})
At the end of the screen, barring errors or forced changes,
it continues with the interrupted input source.},
{{BLOCK},{#BUFF},{THRU},{QUIT},{EXIT},{-->},{LIST}},
{{." interactive"},{interactive}},
enddoc)
HEADER({LOAD},{LOAD},{DOCOL})
        DC      LDUP, THRU
        DC      SEMIS
;
worddoc( {SCREEN},{THRU},,{n1 n2 --- ??},{ISO,FIG,L0},
{Interrupt the forthdefi({current input source}) in order to
interpret screen forthvar({n1}) through forthvar({n2})
(inclusive).
_VERBOSE_({{The stack changes in according with the words executed.}})
At the end of the screens, barring errors or forced changes,
it continues with the interrupted input source.},
{{#BUFF},{BLOCK},{LOAD},{QUIT},{EXIT},{-->}},
{{." interactive"},{interactive}},
enddoc)
HEADER({THRU},{THRU},{DOCOL})
        DC      SAVE
        DC      ONEP, SWAP
        _DO(THRU2)
THRU1:
        DC      IDO, LLOCK
        DC      IDO, BLOCK
        DC      LIT, KBBUF
        DC      SETSRC
        DC      LIT, INTER, CATCH
        DC      IDO, LUNLOCK
        DC      QDUP
        _0BRANCH(THRU3)
        DC      RDROP, RDROP, RDROP; {UNLOOP}.
        DC      RESTO
        DC      THROW
THRU3:
        _LOOP({THRU1})
THRU2:
        DC      RESTO
        DC      SEMIS
;
_LOAD_({
;
worddoc( {STORAGE~},{BLK},{blk},{--- addr},{ISO},
{When the standard word forthcode({BLK}) is used, the content
of the user variable forthsamp({(BLK)}) is refreshed to reflect
the state of the current input source and its address is returned
in forthvar({addr}) .
It indicates the block
number being interpreted, or zero, if input is being taken from
the terminal input buffer. Changing the content at
forthvar({addr}) has no effect, and its content must be
fetched before the forthdefi({current input source}) has
changed.},
{{BLOCK},{TIB}},
{{BLK @ .},{0}},
enddoc)
HEADER({BLK},{BLK},{DOCOL})
        DC      LIN, FETCH
        DC      FIRST, LIMIT, WITHIN
        DC      SRC, TFET, LSUB
        DC      LIT, 1024, EQUAL, LAND
        _0BRANCH(BLK1)
        DC      SRC, FETCH, TWO, LCELLS, LSUB, FETCH
        _BRANCH(BLK2)
BLK1:
        DC      ZERO
BLK2:
        DC      PBLK, STORE
        DC      PBLK
        DC      SEMIS
;
worddocsafe( {SCREEN},{-->},{next_screen},{},{I,L0},
{Continue interpretation with the next disc screen. If the
current input source is not from a block, a crash will ensue.
If this new screen is left by throw of an exception, the
screen may remain locked until a forthcode({QUIT}), or any
uncaught exception. },
{{LOCK},{CATCH},{LOAD}},
{{." interactive"},{interactive}},
enddoc)
HEADER({-->},{ARROW},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QLOAD})
        DC      BLK, FETCH
        DC      LDUP, LUNLOCK
        DC      ONEP
        DC      LDUP, LLOCK
        DC      LDUP, BLK, STORE
        DC      BLOCK
        DC      LIT, KBBUF
        DC      SETSRC
        DC      SEMIS
        PAGE
;
});_END_({_LOAD_})
_PC_({
;{ Generic call on BIOS. A boon for experimenters.}
worddoc( {OPERATINGSYSTEM},{BIOS},{bios},{a b c d i---ar br cr dr fl}{},
{Do a call of ``BIOS'' interrupt forthsamp({i}) with forthsamp({a b c d})
in registers forthsamp({AX BX CX DX}). Upon return those registers contains
forthsamp({ar br cr dr}) and forthsamp({fl}) is the content of the processors flag
register._DPMI_({This word performs calls only as related to a real mode interface.
Under DPMI we have to do this via a special call to the
unadorned , which is in this case protected mode, interrupt 31H function 0300H.
In behalf of this registers are saved and restored in forthcode({REG-SET}) .
Unadorned calls to interrupt 31H (DPMI) are available as forthcode({BIOSP}) .})
_VERBOSE_({ forthsamp({1 AND}) leaves a zero if the call was successful.})
},{{BDOS}}, {}, enddoc)
_NORMAL_BIOS_({
;{ Because there is no such thing as a variable interrupt:}
;{ THIS IS SELF MODIFYING CODE! NOT REENTRANT! DO NOT PUT IN ROM!}
;{ BEWARE OF THE SOFTWARE POLICE!}
CODE_HEADER({BIOS},{BIOS})
        POP     AX      ;{ Function code}
        ;{ Once we are more acknowledgable, put segment overwrite here.}
        MOV     _BYTE_PTR([RQBIOS+1]),AL ;{ Patch the code.}
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        PUSH     HIP      ;{ Save Forth registers. NEEDED? }
        PUSH     RPO
        XCHG    SI,AX   ;{ Save AX in (already free) SI}
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    {SI},{AX}
RQBIOS:  INT(0)          ;{ Request number to be overwritten.}
        PUSHF      ;{ Save status into DI }
        POP     {DI}
        XCHG    {SI},{AX} ;{ Save AX in (still free) SI     }
        _SWITCH_({JMPHERE_FROM_OS})
        XCHG    SI,AX
        POP     RPO      ;{ Restore Forth registers. NEEDED? }
        POP     HIP
        PUSH     AX
        PUSH     BX
        PUSH     CX
        PUSH     DX
        PUSH     DI     ;{ i.e. flags }
        _NEXT
_SWITCH_({SPSAVE: DC       0H})
;{ SELF MODIFYING CODE ENDS HERE! YOU HAVE BEEN WARNED!}
});_END_({_NORMAL_BIOS_})
_SIMULATE_BIOS_({
CODE_HEADER({BIOS},{BIOS})
; Adapted from Allen Wyatt, Advanced Assembly language, QUE
; from pmtest.asm.

        POP     BX      ; Function code
        POP     AX
        MOV     _CELL_PTR[SaveDX],AX ;{Parameters specified from stack.}
        POP     AX
        MOV     _CELL_PTR[SaveCX],AX
        POP     AX
        MOV     _CELL_PTR[SaveBX],AX
        POP     AX
        MOV     _CELL_PTR[SaveAX],AX
        PUSHF
        POP     AX
        MOV     _CELL_PTR[SaveFlags],AX


       MOV     _CELL_PTR[SaveSI],SI ;{Save some registers.}
       MOV     _CELL_PTR[SaveDI],DI
       MOV     _CELL_PTR[SaveBP],BP
       MOV     _CELL_PTR[SaveSP],SP ;Can't leave it at 0, because
                                    ;SS is not 0, so SS:IP is used.

       MOV     AX,0300h            ;Simulate real-mode interrupt
       ;  Function number was popped into BX register.
       MOV     CX,0                ;Copy nothing from stack
       LEA     DI, [REGSET+(CW*(PH_OFFSET-C_HOFFSET))]
       INT     31h

       MOV     SI,_CELL_PTR[SaveSI] ;{Restore some registers.}
       MOV     DI,_CELL_PTR[SaveDI]
       MOV     BP,_CELL_PTR[SaveBP]
       MOV     SP,_CELL_PTR[SaveSP]

       MOV     AX,_CELL_PTR[SaveAX] ;{Make others available.}
       PUSH     AX
       MOV     AX,_CELL_PTR[SaveBX]
       PUSH     AX
       MOV     AX,_CELL_PTR[SaveCX]
       PUSH     AX
       MOV     AX,_CELL_PTR[SaveDX]
       PUSH     AX
       MOV     AX,_CELL_PTR[SaveFlags]
       PUSH    AX
       JMP     NEXT
;
worddoc( {STORAGE},{REG-SET},{register-set},{--- addr},{},
{Leaves the forthvar({addr})
the register storage areas for cross-mode interrupt handling.
This structure is defined by the DPMI specifications for
use with interrupt 31H function 0300H.
},
{{BIOS}},
dnl Expect a reasonable value for the data segment.
{{123 REG-SET 24 + @ 0FFFF AND 1000 3000 WITHIN .},{_T_} },
enddoc)
HEADER({REG-SET},{REGSET},{DOVAR},)
SaveDI:     DD      00000000
SaveSI:     DD      00000000
SaveBP:     DD      00000000
            DD      00000000            ;Reserved area--set to 0
SaveBX:     DD      00000000
SaveDX:     DD      00000000
SaveCX:     DD      00000000
SaveAX:     DD      00000000
SaveFlags:  DW      0000
SaveES:     DW      0000
SaveDS:     DW      0000
SaveFS:     DW      0000
SaveGS:     DW      0000
SaveIP:     DW      0000
SaveCS:     DW      0000
SaveSP:     DW      0000
SaveSS:     DW      0000
;
worddoc( {OPERATINGSYSTEM},{BIOSP},{biosp},{a b c d di i---ar br cr dr fl},{},
{Do an adorned, protected mode, call of ``BIOS'' interrupt
forthsamp({i}) with forthsamp({a b c d di}) in registers
forthsamp({AX BX CX DX DI}). Upon return those registers
contains forthsamp({ar br cr dr}) and forthsamp({fl}) is the
content of the processors flag register. _VERBOSE_({
forthsamp({1 AND}) leaves a zero if the call was successful.})
},{{BIOS},{BDOS}}, {}, enddoc)
; Wanted here is a generic call on BIOS. A boon for experimenters.
;{ Because there is no such thing as a variable interrupt:}
; I tried to use self modifying code , filling in the interrupt
; number. Like in the BIOS for the real case.
; In protected mode with different selectors for code
; and data this fails. So in fact BIOSP is now DPMI : interrupt 31H.
CODE_HEADER({BIOSP},{BIOSP})
        POP     DI
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        PUSH     HIP      ;{ Save Forth registers. NEEDED? }
        PUSH     RPO
        XCHG    SI,AX   ;{ Save AX in (already free) SI}
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    {SI},{AX}
RQBIOS: INT(31H)          ;{ Request number to be overwritten.}
        PUSHF      ;{ Save status into DI }
        POP     {DI}
        XCHG    {SI},{AX} ;{ Save AX in (still free) SI     }
        _SWITCH_({JMPHERE_FROM_OS})
        XCHG    SI,AX
        POP     RPO      ;{ Restore Forth registers. NEEDED? }
        POP     HIP
        PUSH     AX
        PUSH     BX
        PUSH     CX
        PUSH     DX
        PUSH     DI     ;{ i.e. flags }
        _NEXT
_SWITCH_({SPSAVE: DC       0H})
;{ SELF MODIFYING CODE ENDS HERE! YOU HAVE BEEN WARNED!}
});_END_({_SIMULATE_BIOS_})
worddoc( {OPERATINGSYSTEM},{BDOS},{bdos},{a b c d i---ar br cr dr fl},{},
{Do a call of ``BDOS'' interrupt (21H) with forthsamp({a b c d}) in
registers forthsamp({AX BX CX DX}). Upon return those registers
contains forthsamp({ar br cr dr}) and forthsamp({fl}) is the content
of the processors flag register. This draws upon all facilities made
available by MSDOS. _BOOTSECTRK_({This works in this standalone Forth, but
only if it is started from MSDOS.})
},{{BIOS}}, {}, enddoc)
_NORMAL_BIOS_({
CODE_HEADER({BDOS},{BDOS})
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        PUSH     HIP      ;{ Save Forth registers. NEEDED? }
        PUSH     RPO
        XCHG    SI,AX   ;{ Save AX in (already free) SI}
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    {SI},{AX}
        INT     21H
        PUSHF      ;{ Save status into DI }
        POP     {DI};{ Not EDI! }
        XCHG    {SI},{AX}  ;{ Save AX in (still free) SI     }
        _SWITCH_({JMPHERE_FROM_OS})
;        XCHG    {SI},{AX}   ; This is more correct actually.
        XCHG    SI,AX
        POP     RPO      ;{ Restore Forth registers. NEEDED? }
        POP     HIP
        PUSH     AX
        PUSH     BX
        PUSH     CX
        PUSH     DX
        PUSH     DI     ;{ i.e. flags }
        _NEXT
});_END_({_NORMAL_BIOS_})
_SIMULATE_BIOS_({
HEADER({BDOS},{BDOS},{DOCOL})
        DW      LIT,  21H
        DW      BIOS
        DW      SEMIS
});_END_({_SIMULATE_BIOS_})
});_END_({ _PC_})
_HOSTED_LINUX_({
worddoc( {OPERATINGSYSTEM},{LINOS},{linos},{p1 p2 p3 n---ret},{},
{ Do a Linux
system call (man 2) with parameters forthsamp({p1 p2 p3}).
forthsamp({ret}) is the return value of the call. If it is negative, it
is mostly an error, such as known by forthsamp({errno}) . This makes
available all facilities present in Linux, except those with 4 or 5 parameters
that are handled by forthcode({LINOS5}) .
},{{?LINUX-ERROR}},
{{1 "CHIMP" 4 LINOS .},{CHIMP5}},
enddoc)
CODE_HEADER({LINOS},{LINOS})
        POP     AX        ; Function number
        POP     DX        ; Third parameter, if any
        POP     CX        ; Second parameter, if any
        POP     BX        ; First parameter.
        INT     80H        ;{ Generic call on LINUX }
        _PUSH     ; Positive means okay. Negative means -errno.
;
worddoc( {OPERATINGSYSTEM},{LINOS5},{linos5},{p1 p2 p3 p4 p5 n---ret},{},
{ Do a Linux
system call (man 2) with parameters forthsamp({p1 p2 p3 p4 p5}).
forthsamp({ret}) is the return value of the call. If it is negative, it
is mostly an error, such as known by forthsamp({errno}) . This makes
available forthemph({all}) facilities present in Linux.
},{{?LINUX-ERROR}},
{{1 "CHIMP" 0 0 4 LINOS5 .},{CHIMP5}},
enddoc)
CODE_HEADER({LINOS5},{LINOS5})
        LEA     RPO,[RPO - _CELLS(1)] ;{Save HIP on return stack.}
        MOV     [RPO],HIP
        POP     AX        ; Function number
        POP     DI        ; 5th parameter, if any
        POP     SI        ; 4th parameter, if any
        POP     DX        ; Third parameter, if any
        POP     CX        ; Second parameter, if any
        POP     BX        ; First parameter.
        INT     80H        ;{ Generic call on LINUX }
        MOV     HIP,[RPO]    ;{ Restore}
        LEA     RPO,[RPO+_CELLS(1)]
        _PUSH     ; Positive means okay. Negative means -errno.
;
worddoc( {OPERATINGSYSTEM},{?LINUX-ERROR},{query_linux_error},{errno ---},{},
{Handle the error forthsamp({errno}) by interpreting it as returned from a
Linux system call. If it is negative, error forthvar({errno}) is displayed and the word
is aborted.
},{{?ERROR}},
{
{0 ?LINUX-ERROR 1 ?LINUX-ERROR},{},
{0 WARNING ! -20 ?LINUX-ERROR },
{ ! -20 ?LINUX-ERROR ? MSG # -32},
{CR},{},
},
enddoc)
HEADER({?LINUX-ERROR},{QLERR},{DOCOL})
        DC      ZERO, MIN, LDUP, QERR
        DC      SEMIS
;
worddoc( {OPERATINGSYSTEM},{MS},{millisecond},{n1 ---},{ISO},
{ Wait for forthvar({n1}) miliseconds. },
{{KEY?}},
{{ 123 10 MS . },{123}},
enddoc)
HEADER({MS},{MS},{DOCOL})
        DC      LIT, 1000, LIT, 1000000, SSMOD ;{ (ms -- us s) }
        DC      LIT, TV, TSTOR
        DC      ZERO, ZERO
        DC      ZERO, ZERO
        DC      LIT, TV
        DC      LIT, _newselect, LINOS5
        DC      QLERR
        DC      SEMIS
TV:     _RESB( 8 )
;
});_END_({ _HOSTED_LINUX_})
_PC_({
             ;{ SVGA-modus 43*132 char's}
HEADER({SMALL},{LSMALL},{DOCOL})
        DC      LIT, 4F02H, LIT, 010AH, ZERO, ZERO
        DC      LIT, 0010H, BIOS
        DC      DROP, DROP, DROP, DROP, DROP
        DC      SEMIS
             ;{                          ^ MUST BE 4FH}
});_END_({_PC_})
        PAGE
;{------------------------------------}
;{       SYSTEM DEPENDANT CHAR I/O}
;{------------------------------------}
_MODERN_({
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO FIG L0},
{Transmit ascii character forthvar({c}) to the output device.
forthcode({OUT}) is incremented for each character output
and reset by a LF.
.},{{OUT}}, {}, enddoc)
HEADER({EMIT},{EMIT},{DOCOL})
        DC      LDUP,LIT,ALF,EQUAL
        _0BRANCH(EMIT1)
        DC      LIT,ACR,EMIT
        DC      ZERO,LOUT,STORE
EMIT1:
        DC      SPFET, ONE, LTYPE
        DC      DROP
        DC      SEMIS
;
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG,L0},
{Leave the ascii value of the next terminal key struck.},
{ACCEPT},{KEY?}, {}, enddoc)
HEADER({KEY},{KEY},{DOCOL})
        DC         LIT, 1000H, ZERO, ZERO, ZERO
        DC         LIT, 0016H, BIOS
        DC         DROP,DROP,DROP,DROP
        DC         LIT, 00FFH, LAND, SEMIS
;
worddoc( {INPUT},{KEY?},{key_question},{--- f},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },{{KEY},{ACCEPT}}, {}, enddoc)
HEADER({KEY?},{KEYQ},DOCOL)
        DC      LIT,0B00H
        DC      ZERO,ZERO,ZERO
        DC      BDOS, DROP ;{ ignore error }
        DC      DROP, DROP, DROP
        DC      LIT, 01H, LAND
        DC      SEMIS
;
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit count characters from forthvar({addr}) to the output device.
All terminal I/O goes through this word. It's first word is a forthcode({NOOP}) so terminal
I/O can be redirected, by forthdefi({revectoring}) it.
In this ciforth the string must not contain embedded LF's.
forthcode({OUT}) is incremented for each character output.},
{{EMIT},{OUT}}, {}, enddoc)
HEADER({TYPE},{LTYPE},{DOCOL})
        DC      LDUP, LOUT, PSTORE
        DC      TOR     ; { Count.}
_BITS32_({; MSDOS cannot handle a 32 bits address: copy the buffer.})
_BITS32_({        DC      LIT, TYPEBUF, RR, LCMOVE })
_BITS32_({        DC      LIT, TYPEBUF })
        DC      TOR     ; { Buffer address.}
        DC      LIT,04000H ;{ Write file or device }
        DC      ONE     ;{ Handle}
        DC      FROMR, FROMR, SWAP
         _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS, })
        DC      BDOS, DROP ;{ ignore error }
        DC      DROP, DROP, DROP, DROP
        DC      SEMIS
_BITS32_({TYPEBUF:  _RESB(0400H) })
;
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Accept characters from the terminal, until a forthkey({RET})
is received and return the result as a constant string
forthvar({sc}).
It doesn't contain a trailing forthkey({LF}).
But possibly a trailing forthkey({RET}) (0DH).
The
editing functions are the same as with forthcode({ACCEPT}) .
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than forthcode({ACCEPT}).
Text is probably present in the buffer address contained in
forthcode({TIB @}), but not necessarily at the beginning. }})
},
{{KEY},{KEY?},{ACCEPT}},
{
{(ACCEPT)},{},
 {GIBBON
  DUP . TYPE},{6 GIBBON},
dnl { ." Type an 'A'" (ACCEPT) DUP . TYPE},{1 A)},
dnl {." Type an 'ABCDEF'" DUP . },{6},
},
enddoc)
HEADER({(ACCEPT)},{PACCEP},{DOCOL})
PACCEP2:
;        DC      NOLF
;        DC       LIT, 'a', EMIT
        DC      REMAIND
        DC      TFET
        DC      LIT, ALF, SINDEX
        DC      ZEQU
        _0BRANCH(PACCEP1)
;        DC      RETOBO
        DC      REMAIND, TFET
        DC      TIB, FETCH
        DC      SWAP, LMOVE
        DC      TIB, FETCH
        DC      REMAIND, CELLP, STORE
        DC      REFTIB
        _BRANCH(PACCEP2)
PACCEP1:
;        DC      SPLOFF
;;;;;;;;DC      REMAIND             ; go
;;;;;;;;DC      TFET                     ; go
;;;;;;;;DC      LIT, ALF, SINDEX          ; go
;;;;;;;;DC      ZEQU                     ; go
;;;;;;;;DC      LIT, 13, QERR            ; go
        DC      REMAIND, TFET
        DC      LIT, ALF, SSPLIT
        DC      TSWAP, REMAIND, TSTOR
        _PC_({DC ONEM}, {dnl})
        DC      SEMIS

worddoc( {INPUT~},{REFILL-TIB},{refill_tib},{ --- } ,{},
{Accept characters from the terminal input stream such as to
fill up forthcode({TIB}) . Normally this means until a
forthkey({RET}). If the input is redirected (such that reading
after forthkey({RET}) cannot be prevented)
forthsamp({REMAINDER 2@}) contains the first part of
forthcode({TIB}) that has a left over from the previous read.
After forthcode({REFILL-TIB}) forthsamp({REMAINDER 2@}) defines
the characters ready in the input buffer. All characters are
retained including the forthkey({RET}). The editing functions
are the same as with forthcode({ACCEPT}).
},
{{ACCEPT},{(ACCEPT)}},
{
{( "see (ACCEPT)" TYPE)},{}
},
enddoc)
HEADER({REFILL-TIB},{REFTIB},{DOCOL})
        DC      LIT,03F00H ;{ Read file or device }
        DC      ZERO     ;{ Handle}
        DC      REMAIND, FETCH, TOR
_BITS16_(
{        DC      LIT, RTS/2, RR, LSUB
        DC      TIB, FETCH, RR, PLUS},
{dnl})
_BITS32_(
{;{ MSDOS cannot handle a 32 bits address: use the buffer.}
        DC      LIT, 0200H
        DC       LIT, EXPECTBUF },
{dnl})
_SWITCH_({        DC   LIT, M4_SWITCHOFFSET, PLUS, },{dnl})
        DC      BDOS, ONE, LAND
        DC      LIT, 6, QERR
        DC      DROP, DROP, DROP ;{ Leave count}
_BITS32_(
{;{ Copy the buffer.}
        DC      LIT, EXPECTBUF, OVER
        DC      TIB, FETCH, RR, PLUS
        DC      SWAP, LCMOVE},
{dnl})
        DC      LDUP, ZEQU
        _0BRANCH(PACCEP3)
        DC      ZERO, REMAIND, STORE
        DC      LIT, -32, LAND, THROW ; {Presumably end of pipe.}
PACCEP3:
        DC      TIB, FETCH, SWAP, FROMR, PLUS
        DC      REMAIND, TSTOR
        DC      SEMIS
_BITS32_({EXPECTBUF:  _RESB( 0200H ) },{dnl})
;
});_END_({_MODERN_})
_LINUX_C_({
;{ Code fields are filled in during bootup. }
;{ Lower case labels starting with "c_.." are c-supplied facilities.}
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Input a line
until a "return") from the operators terminal, and leave it as
a string constant.
It doesn't contain the forthkey({LF}),
but the buffer still does and after forthcode({1+}) the string
contains forthkey({LF}).
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than forthcode({ACCEPT})
Text is probably present in the buffer address contained in
forthcode({TIB @}), but not necessarily at the beginning. }})
},
{{ACCEPT},{EVALUATE}},
{{." interactive"},{interactive}},
enddoc)
HEADER({(ACCEPT)},{PACCEP},{DOCOL})
        DC      TIB
        DC      FETCH
        DC      LDUP
        DC      LIT,RTS/2
        DC      ACCEP
; Keep the next line in for debugging ACCEPT for MSDOS.
;        DC      LIT, 41H, EMIT, TDUP, LTYPE, LIT, 41H, EMIT
;        DC      DOTS
        DC      SEMIS
;
worddoc( {INPUT},{ACCEPT},{accept},{addr count --- n},{ISO FIG L0},
{Transfer characters from the terminal to address forthvar({addr}) ,
until a "RET" is received.
At most forthsamp({count}) characters will be trasferred to forthvar({addr})
Rely on the operating system for input editing. One or more
nulls are added at the end of the text.
},{{KEY},{KEY?}}, {}, enddoc)
CODE_HEADER({ACCEPT},{ACCEP})
        CALL    c_expec
        LEA     ESP,[ESP+_CELLS(2)]    ; remove input
        PUSH    EAX
        _NEXT
;
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG,L0},
{Leave the ascii value of the next terminal key struck.},{}, {}, enddoc)
CODE_HEADER({KEY},{KEY})
        CALL    c_key
        PUSH    EAX
        _NEXT
;
worddoc( {INPUT},{KEY?},{key_question},{--- f},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },{}, {}, enddoc)
CODE_HEADER({KEY?},{KEYQ})
        CALL    c_qterm
        PUSH    EAX
        _NEXT
;
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit count characters from forthvar({addr}) to the output device.
All terminal I/O goes through this word.
forthcode({OUT}) is not observed.},{{EMIT},{OUT}}, {}, enddoc)
CODE_HEADER({TYPE},{LTYPE},DOCOL)
        CALL    c_type
        LEA     ESP,[ESP+_CELLS(2)]    ; remove input
        _NEXT
;
});_END_({_LINUX_C_})
_LINUX_N_({
;{ All I/O goes through the modern device (unix-standard)}
;{ device I/O. Code fields are filled in during bootup. }
;{ Lower case labels starting with "c_.." are c-supplied facilities.}
worddoc( {INPUT},{ACCEPT},{accept},{addr count --- n},{ISO},
{Transfer at most forthsamp({count}) characters from the
terminal to address, until a forthkey({RET}) is received. The
simple tty editing functions of Linux are observed, i.e. the
``erase'' (delete a character) and ``kill'' (delete a line)
characters. Typically these are the backspace key and ^U. Note
that excess characters after forthsamp({count}) are ignored.
The number of characters not
including the forthkey({RET}) is returned into forthsamp({n}).
},
{{(ACCEPT)},{KEY},{KEY?},{(ACCEPT)}},
{
{PAD 10 ACCEPT},{},
 {GIBBON
  . PAD 5 TYPE},{6 GIBBO},
 {( ." Type an 'A'" PAD 2 ACCEPT . PAD C@ EMIT)( 1 A)},{},
 {( ." Type an 'ABCDEF'" PAD 80 ACCEPT . )( 6)},{},
 {( ." Type an 'ZX'" PAD 1 ACCEPT . PAD C@ EMIT)( 1 Z)},{}
},
enddoc)
HEADER({ACCEPT},{ACCEP},{DOCOL})
        DC      PACCEP
        DC      TSWAP, ROT, MIN
        DC      LDUP, TOR, LMOVE, FROMR
        DC      SEMIS
;
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Accept characters from the terminal, until a forthkey({LF})
is received and return the result as a constant string
forthvar({sc}).
It doesn't contain the forthkey({LF}),
but the buffer still does and after forthcode({1+}) the string
contains forthkey({RET}).
The
editing functions are the same as with forthcode({ACCEPT}) .
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than forthcode({ACCEPT}) }})
},
{{KEY},{KEY?},{ACCEPT}},
{
{(ACCEPT)},{},
 {GIBBON
  DUP . TYPE},{6 GIBBON},
dnl { ." Type an 'A'" (ACCEPT) DUP . TYPE},{1 A)},
dnl {." Type an 'ABCDEF'" DUP . },{6},
},
enddoc)
HEADER({(ACCEPT)},{PACCEP},{DOCOL})
PACCEP2:
;        DC      NOLF
;        DC       LIT, 'a', EMIT
        DC      REMAIND
        DC      TFET
        DC      LIT, ALF, SINDEX
        DC      ZEQU
        _0BRANCH(PACCEP1)
;        DC      RETOBO
        DC      REMAIND, TFET
        DC      TIB, FETCH
        DC      SWAP, LMOVE
        DC      TIB, FETCH
        DC      REMAIND, CELLP, STORE
        DC      REFTIB
        _BRANCH(PACCEP2)
PACCEP1:
;        DC      SPLOFF
        DC      REMAIND, TFET
        DC      LIT, ALF, SSPLIT
        DC      TSWAP, REMAIND, TSTOR
        _PC_({DC ONEM}, {dnl})
        DC      SEMIS

worddoc( {INPUT},{KEY},{key},{--- c},{ISO FIG L0},
{Leave the ascii value of the next terminal key struck.},
{{ACCEPT},{KEY?}},
dnl THE TEST CODE HERE IS PARTLY INPUT FOR KEY
dnl HENCE THE CRITICAL LAYOUT WITH RESPECT TO CR'S
dnl KEY has to be patched with the code `` DSP@ 1 ACCEPT DROP ''
dnl because while redirected the input is buffered in ACCEPT.
dnl {
dnl {CR KEY},{},
dnl  {G
dnl   EMIT CR},{
dnl G},
dnl {CR KEY},{},
dnl  {G EMIT CR},{G}
dnl }
,
enddoc)
HEADER({KEY},{KEY},{DOCOL})
        DC      ONE, LIT, RAWIO, STTERM ; Do not wait for CR
        DC      ZERO, SPFET     ; Expect single key on stack
        DC      ZERO            ; Standard input
        DC      SWAP, ONE       ; Buffer and length
        DC      LIT, read, LINOS
        DC      LDUP, QLERR
        DC      ZEQU, LIT, -EPIPE, LAND, QLERR ; {Presumably end of pipe.}
        DC      ONE, LIT, RAWIO, STTERM       ; Toggle back
        DC      SEMIS
;
worddoc( {INPUT},{KEY?},{key_question},{--- f},{ISO},
{Into forthvar({f}) return whether a character is available.
The next execution of forthcode({KEY}) will return the character immediately.
},
{{KEY},{ACCEPT},{KEY?}},
{{." interactive"},{interactive}},
enddoc)
HEADER({KEY?},{KEYQ},{DOCOL})
        DC      ZERO, LIT, RAWIO, STTERM
        DC      ONE     ;{ # of highest channel to watch.}
        DC      LIT, RFDS   ;{ Waiting for input }
        DC      ONE, OVER, STORE ;{ Waiting for standard in.}
        DC      ZERO, ZERO  ;{ Not output, not events.}
        DC      ZERO, ZERO
        DC      LIT, TV, TSTOR ;{ Time out of zero. See MS.}
        DC      LIT, TV
        DC      LIT, _newselect, LINOS5
        DC      LDUP,  QLERR
        DC      NEGATE        ; {1 -> flag.}
        DC      ZERO, LIT, RAWIO, STTERM
        DC      SEMIS
        _ALIGN  4
RFDS:   _RESB(128)     ;{32 channels maximum.}
;
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit forthvar({count}) characters from forthvar({addr}) to
the output device. All terminal I/O goes through this word. It
is high level so terminal I/O can be redirected, by
forthdefi({revectoring}) it _VERBOSE_({{and the usual
redirection or forthsamp({tee})-ing by Linux}}). In this
ciforth strings may contain embedded forthkey({LF}) 's with the
effect of a new line at that point in the output, however in
that case forthcode({OUT}) is not observed. },
{{EMIT},{OUT}},
{{HERE 41 C, 42 C, 2 TYPE},{AB}},
enddoc)
HEADER({TYPE},{LTYPE},{DOCOL})
        DC      LDUP, LOUT, PSTORE
        DC      ONE, ROT, ROT   ; filedescriptor 1 for standard output.
        DC      LIT, write
        DC      LINOS
        DC      DROP
        DC      SEMIS
;
worddoc( {INPUT~},{TERMIO},{termio},{--- addr},{},
{Leave the address of the terminal description, this has the layout of
a c-structure forthsamp({termio}) .
},{{SET-TERM}},
{{." interactive"},{interactive}},
enddoc)
HEADER({TERMIO},{TERMIO},{DOVAR}, )
        _RESB(SIZE_TERMIO)     ; Filled induring cold boot.
;
worddoc( {INPUT~},{REFILL-TIB},{refill_tib},{ --- } ,{},
{Accept characters from the terminal input stream such as to
fill up forthcode({TIB}) . Normally this means until a
forthkey({RET}). If the input is redirected (such that reading
after forthkey({RET}) cannot be prevented)
forthsamp({REMAINDER 2@}) contains the part of
forthcode({TIB}) that is outside the reach of forthcode({SRC}) ,
is not consumed nor consumable directly by Forth parsing words,
such as forthcode({ACCEPT}) or forthcode({WORD}).
Immediately, after forthcode({REFILL-TIB}) forthsamp({REMAINDER 2@}) defines
the characters ready in the input buffer. All characters are
retained including the forthkey({RET}). The editing functions
are those described by forthcode({ACCEPT}).
},
{{ACCEPT},{(ACCEPT)}},
{
{( "see (ACCEPT)" TYPE)},{}
},
enddoc)
HEADER({REFILL-TIB},{REFTIB},{DOCOL})
        DC      REMAIND, FETCH, TOR
        DC      ZERO
        DC      TIB, FETCH, RR, PLUS
        DC      LIT, RTS/2, RR, LSUB
        DC      LIT, read
        DC      LINOS, LDUP, QLERR
        DC      LDUP, ZEQU, LIT, -EPIPE, LAND, QLERR ; {Presumably end of pipe.}
        DC      TIB, FETCH, SWAP, FROMR, PLUS
        DC      REMAIND, TSTOR
        DC      SEMIS
;
worddoc( {INPUT~},{SET-TERM},{set_term},{len b --- },{},
{Set the terminal length to forthsamp({len}) and toggle the c_lflag field
with forthvar({b}) in the termio structure forthcode({TERMIO}) .
In particular toggling with 0AH makes that
the terminal doesn't wait for a forthkey({RET}).
This word is invalid for pipes, and is replaced by
a forthcode({2DROP}) in that case.
},{{SET-TERM}},
{{." interactive"},{interactive}},
enddoc)
HEADER({SET-TERM},{STTERM},{DOCOL})
        DC      LIT, _VAR_FIELD(TERMIO)+_CELLS(3)
        DC      SWAP, TOGGL
        DC      LIT, _VAR_FIELD(TERMIO)+_CELLS(4)+7
        DC      CSTOR
        DC      ZERO, LIT, TCSETS, TERMIO
        DC      LIT, ioctl, LINOS, QLERR
        DC      SEMIS
;
});_END_({_LINUX_N_})
_HOSTED_LINUX_({
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO FIG L0},
{Transmit ascii character forthvar({c}) to the output device.
For this ciforth all terminal I/O goes through forthcode({TYPE}).
In this ciforth forthcode({EMIT}) maintains forthcode({OUT}).},
{{TYPE},{OUT}},
{ {&z EMIT},{z} },
enddoc)
HEADER({EMIT},{EMIT},{DOCOL})
        DC      SPFET, ONE, LTYPE
        DC      DROP
        DC      SEMIS
;
});_END_({_HOSTED_LINUX_})
;
_PC_({
worddoc( {INPUT},{ACCEPT},{accept},{addr count --- n},{ISO},
{Transfer at most forthsamp({count}) characters from the
terminal to address, until a forthkey({RET}) is received.
_LINUX_({ The simple tty editing functions of Linux are
observed, i.e. the ``erase'' (delete a character) and ``kill''
(delete a line) characters. Typically these are the backspace
key and ^U.}) _PC_({The editing functions such as described by
forthcode({(ACCEPT)}) are observed.}) Note that excess
characters after forthsamp({count}) are ignored. The number of
characters not including the forthkey({RET}) is returned into
forthsamp({n}). },
{{(ACCEPT)},{KEY},{KEY?},{(ACCEPT)}},
{
{PAD 10 ACCEPT},{},
 {GIBBON
  . PAD 5 TYPE},{6 GIBBO},
 {( ." Type an 'A'" PAD 2 ACCEPT . PAD C@ EMIT)( 1 A)},{},
 {( ." Type an 'ABCDEF'" PAD 80 ACCEPT . )( 6)},{},
 {( ." Type an 'ZX'" PAD 1 ACCEPT . PAD C@ EMIT)( 1 Z)},{}
},
enddoc)
HEADER({ACCEPT},{ACCEP},{DOCOL})
        DC      PACCEP
        DC      TSWAP, ROT, MIN
        DC      LDUP, TOR, LMOVE, FROMR
        DC      SEMIS
;
});_END_({_PC_})
_CLASSIC_({
;{ All I/O goes through the 3 assembler functions}
;{ CI CHO CSTAT. They could be collapsed into the }
;{ code definitions, but this way they are available}
;{ to be called from code. And the high level words can be revectored }
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO FIG L0},
{Transmit ascii character forthvar({c}) to the terminal.
All terminal I/O goes through this word. It is high level so terminal
I/O can be redirected, by forthdefi({revectoring}) it.
forthcode({OUT}) is incremented for each character output and reset for
a carriage return.
Note that in this ciforth (``classical FIG'') terminal I/O mainly
uses BDOS, where disk I/O uses the BIOS.
},{{TYPE},{OUT}}, {}, enddoc)
HEADER({EMIT},{EMIT},{DOCOL})
        DC      PEMIT
        DC      ONE,LOUT
        DC      PSTORE,SEMIS
PEMIT   DC      _AP_ +_CELLS(1)
        POP     AX      ;{GET CHAR}
        CMP     AL,ALF   ;{ Precede ^J with ^M}
        JNE     PEMIT1
        MOV     _CELL_PTR[_VAR_FIELD(LOUT)],0H
        MOV     AL,ACR
        CALL    CHO
        MOV     AL,ALF
        ;{ Bizar, without the colon MASM reports error.}
PEMIT1: CALL    CHO    ;{CHAR OUTPUT}
        _NEXT
CHO     PROC    NEAR
        PUSH    DX
        PUSH    AX      ;{SAVE CHAR}
        MOV     DL,AL   ;{CHAR TO WRITE}
        MOV     AH,2    ;{CHAR OUT FUNCTION}
        INT     21H     ;{DOS}
        POP     AX
        POP     DX
        RET
_ENDP CHO     ENDP
;
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG,L0},
{Leave the ascii value of the next terminal key struck.},{}, {}, enddoc)
CODE_HEADER({KEY},{KEY})
        CALL    CI      ;{CONSOLE INPUT}
        MOV     AH,0    ;{MAKE 16 BITS}
        _PUSH   ;{SAVE KEY VALUE}
CI      PROC    NEAR
        MOV     AH,0    ;{ READ CHAR FUNCTION}
        INT     16H
        RET
_ENDP CI      ENDP
;
worddoc( {INPUT},{KEY?},{key_question},{--- f},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },
{{KEY},{ACCEPT}}, {}, enddoc)
CODE_HEADER({KEY?},{KEYQ})
        JMP     PQTER
PQTER:  CALL    CSTAT   ;{TEST FOR KEY}
        OR      AL,AL   ;{ANY KEY?}
        JZ      PQTER1  ;{NO}
        MOV     AL,1    ;{TRUE = CHAR FOUND}
PQTER1: MOV     AH,0    ;{MAKE 16 BITS}
        _PUSH   ;{SAVE STATUS}
;
CSTAT   PROC    NEAR
        PUSH    DX
        MOV     DX,0FFH
        MOV     AX,0600H
        INT     21H
        POP     DX
STATRT: RET
_ENDP CSTAT   ENDP
;
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit forthsamp({count}) characters from forthvar({addr}) to the
terminal.
In this ciforth all terminal I/O goes through forthcode({EMIT}), so
forthcode({OUT}) is observed.},{{EMIT},{OUT}}, {}, enddoc)
HEADER({TYPE},{LTYPE},{DOCOL})
        DC      QDUP
        _0BRANCH(TYPE1) ;{ IF}
        DC      OVER
        DC      PLUS
        DC      SWAP
        _DO(TYPE4)
TYPE2:  DC      IDO
        DC      CFET
        DC      EMIT
        _LOOP(TYPE2)    ;{ LOOP}
TYPE4:
        _BRANCH(TYPE3)  ;{ ELSE}
TYPE1:  DC      DROP    ;{ THEN}
TYPE3:  DC      SEMIS
;
});_END_({_CLASSIC_})
_USEBIOS_({
worddocsafe( {OUTPUT},{(EMIT)},{paren_emit},{c ---},{},
{Just transmit ascii character forthvar({c}) to the terminal
by a BIOS call.
},{{EMIT}}, {}, enddoc)
HEADER({(EMIT)},{PEMIT},{DOCOL})
             DC      LIT, 0E00H, PLUS, ZERO, ZERO, ZERO
             DC      LIT, 0010H, BIOS
             DC      DROP, DROP, DROP, DROP, DROP, SEMIS
;
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO FIG L0},
{Transmit ascii character forthvar({c}) to the terminal.
All terminal I/O goes through this word. It is high level so terminal
I/O can be redirected, by forthdefi({revectoring}) it.
forthcode({OUT}) is incremented for each character output and reset for
a carriage return.
},{{TYPE},{OUT}}, {}, enddoc)
HEADER({EMIT},{EMIT},{DOCOL})
             DC      ONE,LOUT,PSTORE
             DC      LIT, 07FH, LAND
             DC      LDUP,LIT,ALF,EQUAL
             _0BRANCH(EMIT1)
             DC      LIT,ACR,PEMIT
             DC      ZERO,LOUT,STORE
EMIT1:       DC      PEMIT
             DC      SEMIS
;
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG,L0},
{Leave the ascii value of the next terminal key struck.},{}, {}, enddoc)
HEADER({KEY},{KEY},{DOCOL})
             DC         LIT, 1000H, ZERO, ZERO, ZERO
             DC         LIT, 0016H, BIOS
             DC         DROP,DROP,DROP,DROP
             DC         LIT, 00FFH, LAND, SEMIS
;
worddoc( {INPUT},{KEY?},{key_question},{--- f},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },
{{KEY},{ACCEPT}}, {}, enddoc)
HEADER({KEY?},{KEYQ},{DOCOL})
             DC      LIT, 01100H, ZERO, ZERO, ZERO
             DC      LIT, 016H, BIOS
             DC      LIT, 040H, LAND, ZEQU, TOR
             DC      DROP, DROP, DROP, DROP
             DC      FROMR, SEMIS
;
worddoc( {OUTPUT},{POUT)},{p_out},{c ---},{},
{Just transmit ascii character forthvar({c}) to the printer
by a BIOS call. forthcode({OUT}) is not observed.
},{{EMIT}}, {}, enddoc)
HEADER({POUT},{POUT},{DOCOL})
             DC      ZERO, ZERO, ZERO
             DC      LIT, 0017H, BIOS
             DC      DROP, DROP, DROP, DROP, DROP, SEMIS
;
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO FIG L0},
{Transmit count characters from forthvar({addr}) to the output device.
forthcode({OUT}) is incremented for each character output.
In this ciforth all terminal I/O goes through forthcode({EMIT}), so
forthcode({OUT}) is observed.
},{{EMIT},{OUT}}, {}, enddoc)
HEADER({TYPE},{LTYPE},{DOCOL})
             DC      QDUP
             _0BRANCH(TYPE1)
             DC      OVER,   PLUS
             DC      SWAP
             _DO(TYPE4)
TYPE2:       DC      IDO,    CFET,    EMIT
             _LOOP(TYPE2)
             _BRANCH(TYPE3)
TYPE4:
TYPE1:       DC      DROP
TYPE3:       DC      SEMIS
;
});_END_({_USEBIOS_})
_KEY_BY_KEY_({
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Input a line
until a forthkey({RET)}) from the input terminal, and leave it as
a string constant. It doesn't contain a trailing forthkey({LF}).
But possibly a trailing forthkey({RET}) (0DH).
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than forthcode({ACCEPT})
Text is probably present in the buffer address contained in
forthcode({TIB @}), but not necessarily at the beginning. }})
Editing is done locally observing forthcode({RUBOUT}) .
},
{{ACCEPT},{EVALUATE}},
{{." interactive"},{interactive}},
enddoc)
HEADER({(ACCEPT)},{PACCEP},{DOCOL})
        DC      TIB
        DC      FETCH
        DC      LIT,RTS/2
        DC      TDUP
; { Old fig code of EXPECT :}
             DC      OVER
             DC      PLUS
             DC      OVER
             _DO(EXPE8)
EXPE1:       DC      KEY
             DC      LDUP
             DC      RUBOUT
             DC      FETCH
             DC      EQUAL
             _0BRANCH(EXPE2) ;{ IF                    }
             DC      DROP
             DC      LDUP
             DC      IDO
             DC      EQUAL
             DC      LDUP
             DC      FROMR
             DC      TWO     ;{ Remove last 2 chars }
             DC      LSUB
             DC      PLUS
             DC      TOR
             _0BRANCH(EXPE6) ;{ IF                    }
             DC      LIT
             DC      BELL
             _BRANCH(EXPE7)  ;{ ELSE                  }
EXPE6:       DC      LIT
             DC      BSOUT   ;{ THEN                 }
EXPE7:       _BRANCH(EXPE3)  ;{ ELSE                  }
EXPE2:       DC      LDUP
             DC      LIT,0DH
             DC      EQUAL
             _0BRANCH(EXPE4) ;{ IF}
             ; {Emulate old fashioned LEAVE.}
             DC      FROMR, RDROP, LDUP, TOR, TOR
             DC      DROP
             DC      LBL
             DC      ZERO
             _BRANCH(EXPE5)  ;{ ELSE}
EXPE4:       DC      LDUP    ;{ THEN}
EXPE5:       DC      IDO
             DC      CSTOR
             DC      ZERO
             DC      IDO
             DC      ONEP
             DC      STORE   ;{ THEN}
EXPE3:       DC      EMIT
             _LOOP(EXPE1)    ;{ LOOP}
EXPE8:
             DC      DROP
;        END      EXPEC
        DC      ZERO, SINDEX
        DC      TIB, FETCH, SWAP, OVER, LSUB
        DC      SEMIS
;
});_END_({_KEY_BY_KEY_})

        PAGE
;{------------------------------------}
;{       SYSTEM DEPENDANT DISK I/O}
;{------------------------------------}
define({_FILENAMELENGHT_M4_},_BITS16_(30)_BITS32_(254))
worddoc( {STORAGE},{DISK-ERROR},{disk_error},{--- addr},{},
{Leave the address forthvar({addr}) of a variable containing
information about the latest disk error in opening, using or
closing the block file. _HOSTED_LINUX_({ This is just
a flag, indicating there was an error. }). _PC_({ One means an
error and and zero means okay.})
_VERBOSE_({Beware that if error messages are loaded from disk,
this may clear forthcode({DISK-ERROR}) })
},
_HOSTED_LINUX_({ {{BLOCK},{?LINUX-ERROR}}, })
_USEBIOS_({ {{BLOCK},{R/W}}, })
_HOSTED_LINUX_({ {{ CR DISK-ERROR @ 0 < . BLOCK-INIT},{0},}, })
_PC_({ {{ CR DISK-ERROR @ 0=},{0},}, }),
enddoc)
HEADER({DISK-ERROR},{DERR},{DOVAR}, )
        DC      -1
;
_BLOCKSINFILE_({
worddoc( {STORAGE},{BLOCK-FILE},{block_file},{---addr},{},
{Leave the address forthvar({addr}) of a counted string,
the name of a file in which blocks are (to be) allocated.
The name may contain a path and be at most}
_FILENAMELENGHT_M4_ {characters long.
The default name is forthsamp({forth.lab}) .
},{{BLOCK-HANDLE},{BLOCK-INIT},{BLOCK-EXIT}},
{{BLOCK-FILE $@ TYPE},{forth.lab}},
enddoc)
HEADER({BLOCK-FILE},{BLFL},{DOVAR}, )
        _STRING({forth.lab})
        _RESB(_FILENAMELENGHT_M4_-9)               ;{ Allow for some path}
worddoc( {STORAGE},{BLOCK-HANDLE},{block_handle},{---n},{},
{Leave a file handle in forthvar({n}) .
If it is negative there is no block file open,
otherwise the handle is used by the system to access blocks.
_LINUX_C_({In this ciforth forthcode({BLOCK-HANDLE}) is not used.})
},{{BLOCK-FILE},{BLOCK-INIT},{BLOCK-EXIT}},
{{BLOCK-HANDLE @ 10 U< .},{_T_}},
enddoc)
HEADER({BLOCK-HANDLE},{BHAN},{DOVAR}, )
        DC      -1
;
});_END_({_BLOCKSINFILE_})
;
_RWFILE_({
worddoc( {STORAGE},{?DISK-ERROR},{disk_error_},{u---},{},
{Interpret forthvar({u}) as the status of a disk i/o BDOS call.
Report an error if it contains an error condition.
},{{BLOCK-FILE},{BLOCK-HANDLE},{BLOCK-INIT},{BLOCK-EXIT}}, {}, enddoc)
HEADER({?DISK-ERROR},{QDSKER},{DOCOL})
        DC      ONE, LAND
        DC      LIT, 8, QERR
        DC      SEMIS
;
worddoc( {STORAGE},{BLOCK-INIT},{block_init},{---},{},
{Map the blocks on the block file forthcode({BLOCK-FILE}),
i.e. the mass storage words refer
to the blocks in this file, using forthsamp({BLOCK-HANDLE}) to acces it.
},
{{BLOCK},{LIST},{LOAD},{BLOCK-EXIT}},
{{( Via MESSAGE)},{}},
enddoc)
HEADER({BLOCK-INIT},{BLINI},{DOCOL})
        DC      LIT, 03D02H    ;{ Open file for read/write}
        DC      ZERO,ZERO
        DC      BLFL
        DC      SFET, OVER, PLUS
        DC      ZERO, SWAP, CSTOR  ;{ Zero ended as required}
         _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS, })
        DC      BDOS
        DC      ONE, LAND, ONE, LXOR ;{ 0 if disk problems. }
        DC      LWARN, FETCH, MIN ;{ Affect WARNING only if it was 1.}
        DC      LWARN, STORE
        DC      DROP, DROP, DROP
        DC      BHAN, STORE
        DC      SEMIS
;
worddoc( {STORAGE},{BLOCK-EXIT},{block_exit},{---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Close the currently open block file forthcode({BLOCK-HANDLE}),
i.e. the mass storage words no longer work, and will result in
error messages.
},{{BLOCK},{LIST},{LOAD}},
{
{EMPTY-BUFFERS BLOCK-EXIT},{},
{0 WARNING ! -1F MESSAGE}, {MSG # -1F},
{ CR DISK-ERROR @ 0= 0= . BLOCK-INIT},{_T_},
{1 WARNING ! -20 MESSAGE}, {( -b This_option_is_available )},
},
enddoc)
HEADER({BLOCK-EXIT},{BLEXI},{DOCOL})
        DC      FLUSH
        DC      LIT, 03E00H    ;{ Close file }
        DC      ZERO
        DC      LWARN, FETCH, MIN ;{ Affect WARNING only if it was 1.}
        DC      LWARN, STORE
        DC      BHAN, FETCH
        DC      ZERO, ZERO
        DC      BDOS, QDSKER
        DC      DROP, DROP, DROP, DROP
        DC      LIT, -1, BHAN, STORE
        DC      SEMIS
;
worddoc( {STORAGE~},{SEEK},{seek},{n---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Position the file pointer at block forthvar({n})
in behalf of subsequent reads and writes.
},{{BLOCK},{LIST},{LOAD}}, {}, enddoc)
HEADER({SEEK},{SEEK},{DOCOL})
        DC      BHAN, FETCH
        DC      SWAP, TOR, TOR
        DC      LIT, 04200H     ;{ Seek from start}
        DC      FROMR           ;{ Handle}
        DC      FROMR, BBUF
        _BITS16_({DC      USTAR,SWAP})    ;{ L.S. ON TOP}
        _BITS32_({DC      STAR, LIT, 10000H, SLMOD,SWAP})    ;{ L.S. ON TOP}
        DC      BDOS, QDSKER
        DC      DROP, DROP, DROP, DROP
        DC      SEMIS
;
worddoc( {STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The ciforth primitive for read-write of blocks. forthvar({addr})
specifies the source or destination block buffer, forthsamp({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read or write and reports errors.
},
{{BLOCK},{DISK-ERROR}}, {}, enddoc)
HEADER({R/W},{RSLW},{DOCOL})
        _0BRANCH(RSLW1)
        DC      LIT, 03F00H     ;{ Disk read }
        _BRANCH(RSLW2)
RSLW1:  DC      LIT, 04000H     ;{ Disk write}
RSLW2:  DC      TOR
        DC      SEEK ;{ That's done}
        DC      FROMR, SWAP, TOR
        DC      BHAN, FETCH
        DC      BBUF
        DC      FROMR           ;{ ADDR}
        _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS, })
        DC      BDOS, QDSKER
        DC      DROP, DROP, DROP
        DC      BBUF, LSUB, QDSKER
        DC      SEMIS
;
});_END_({_RWFILE_})
_LINUX_N_({
worddoc( {STORAGE},{GET-FILE},{get_file},{sc1 --- sc2},{},
{Get the content of the file with name forthsamp({sc1});
leave it as a string forthsamp({sc2}) .
},
{{BLOCK},{?LINUX-ERROR}},
{{"hello.frt" GET-FILE TYPE },{." Hello world!"}},
enddoc)
HEADER({GET-FILE},{GFILE},DOCOL)
        DC      HERE, TOR, LIT, 10000000, ALLOT
        DC      RR, SSTOR, ZERO, RR, CHAPP ; {Unix requires a c-string.}
        _STRINGINLINE({FiLeBuF})        ; {Magic number.}
        DC      RR, SPTOR
        DC      FROMR, SFET, OVER, PLUS, TOR
        DC      LIT, O_RDONLY, ZERO, LIT, open, LINOS
        DC      LDUP, QLERR
        DC      LDUP, RR, LIT,  9999000
        DC      LIT ,read, LINOS
        DC      LDUP, QLERR, TOR
        DC      ZERO,ZERO, LIT, close, LINOS, QLERR
        DC      FROMR, FROMR, SWAP
        DC      TDUP, PLUS, LDP, STORE
        DC      SEMIS
;
worddoc( {STORAGE},{PUT-FILE},{put_file},{sc1 sc2 --- },{},
{Save the string constant forthsamp({sc2} as a new file with
the name forthsamp({sc1}) ) . },
{{BLOCK},{?LINUX-ERROR}},
{{"CONTENT" "orang" PUT-FILE "orang" GET-FILE TYPE },{CONTENT}},
enddoc)
HEADER({PUT-FILE},{PFILE},DOCOL)
        DC      PAD, SSTOR, ZERO, PAD, CHAPP ; {Unix requires a c-string.}
        DC      TOR, TOR
        DC      PAD, CELLP
        DC      LIT, O_RDWR _OR_ O_CREAT, LIT, 777Q
        DC      LIT, open, LINOS, LDUP, QLERR
        DC      LDUP, FROMR, FROMR
        DC      LIT, write, LINOS, QLERR
        DC      ZERO,ZERO, LIT, close, LINOS, QLERR
        DC      SEMIS
;
worddoc( {STORAGE},{INCLUDED},{INCLUDED},{sc1 --- i*x},{ISO},
{Interpret the content of the file with name forthsamp({sc1})
as if it was typed from the console, leaving result
forthsamp({i*x}). },
{{BLOCK},{?LINUX-ERROR}},
{{"hello.frt" INCLUDED},{Hello world!}},
enddoc)
HEADER({INCLUDED},{INCLUD},DOCOL)
        DC      HERE, TOR
        DC      LIT, GFILE, CATCH
        DC      LDUP
        _0BRANCH(INCLUD1)
        DC      FROMR, LDP, STORE
        DC      THROW
        _BRANCH(INCLUD2)
INCLUD1:
        DC      RDROP, DROP
INCLUD2:
        DC      EVALUATE
        DC      SEMIS
;
worddoc( {OPERATINGSYSTEM},{SYSTEM},{system},{sc1 --- },{ISO},
{Have the operating system execute the command contained
in the string forthsamp({sc1}).
},{{BLOCK},{?LINUX-ERROR}},
{{"cat hello.frt" SYSTEM 2000 MS},{." Hello world!"}},
enddoc)
HEADER({SYSTEM},{SYSTEM},{DOCOL})
        DC      LIT, COMBUF, SSTOR, ZERO, LIT, COMBUF, CHAPP
        DC      ZERO, ZERO, ZERO, LIT, fork, LINOS
        DC      LDUP, QLERR
        DC      LDUP, ZEQU
        _0BRANCH(SYSTEM1)
        DC      LIT, SHELL, LIT, SYSARGS
;  Get environment vector
        DC      ARGS, FETCH, SFET, ONEP, LCELLS, PLUS
        DC      LIT, execve, LINOS
        DC      LIT, -127, QLERR, BYE
SYSTEM1:
        DC      LDUP
        DC      LIT, STATUS, ZERO, LIT, waitpid, LINOS
        DC      LDUP
        DC      LIT, EINTR, EQUAL
        _BRANCH(SYSTEM2)
        DC      DROP
        _0BRANCH(SYSTEM1)
SYSTEM2:
        DC      QLERR
        DC      TDROP
        DC      SEMIS
;
STATUS   DC     0
SYSARG1:
SHELL:   DB      "/bin/sh",0
SYSARG2: DB      "-c", 0
COMBUF:  _RESB(256)
SYSARGS: DC   SYSARG1, SYSARG2, COMBUF + _CELLS(1), 0
;
worddoc( {STORAGE},{BLOCK-INIT},{block_init},{---},{},
{Map the blocks on the block file forthcode({BLOCK-FILE}),
i.e. the mass storage words refer
to the blocks in this file, using forthcode({BLOCK-HANDLE}) to acces it.
If successful, forthcode({WARNING}) is reinitialised to use disk messages.
},{{BLOCK},{LIST},{LOAD},{BLOCK-EXIT},{DISK-ERROR}},
{{( Via MESSAGE)},{}},
enddoc)
HEADER({BLOCK-INIT},{BLINI},DOCOL)
        DC      ZERO, BLFL, SFET, PLUS, STORE ; {Unix requires a c-string.}
        DC      BLFL, SFET, DROP
        DC      LIT, O_RDWR
        DC      ZERO
        DC      LIT, open
        DC      LINOS
        DC      LDUP, BHAN, STORE
        DC      ZERO, MIN      ; 0/-errno
        DC      LDUP, DERR, STORE
        DC      ZEQU, ONE, LAND  ;{ 0 if disk problems. }
        DC      LWARN, FETCH, MIN ;{ Affect WARNING only if it was 1.}
        DC      LWARN, STORE
        DC      SEMIS
;
worddoc( {STORAGE},{BLOCK-EXIT},{block_exit},{---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Close the currently open block file forthcode({BLOCK-HANDLE}),
i.e. the mass storage words no longer work, and will result in
error messages. If error messages were fetched from disk, they
no longer are.},
{{BLOCK},{LIST},{LOAD},{DISK-ERROR},{WARNING}},
{
{EMPTY-BUFFERS BLOCK-EXIT},{},
{0 WARNING ! EMPTY-BUFFERS 1 BLOCK},
 {PTY-BUFFERS 1 BLOCK ? MSG # 8},
{ CR DISK-ERROR @ 0 < . BLOCK-INIT},{_T_},
{1 0 .LINE}, { LICENSE }
},
enddoc)
HEADER({BLOCK-EXIT},{BLEXI},DOCOL)
        DC      FLUSH
        DC      ZERO
        DC      LWARN, FETCH, MIN ;{ Affect WARNING only if it was 1.}
        DC      LWARN, STORE
        DC      BHAN, FETCH
        DC      ZERO,ZERO
        DC      LIT, close
        DC      LINOS
        DC      ZERO, MIN      ; 0/-errno
        DC      DERR, STORE
        DC      SEMIS
;
worddoc( {STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The ciforth primitive for read-write of blocks. forthvar({addr})
specifies the source or destination block buffer, forthsamp({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read or write and records errors, but doesn't abort on them.},
{{BLOCK},{DISK-ERROR}},
dnl we can use block 2 for scratch, -b is not an option in use.
{
{PAD B/BUF 41 FILL PAD 2 0 R/W},{},
{PAD B/BUF 45 FILL PAD 2 1 R/W},{},
{PAD 23 + 5 TYPE},{AAAAA},
},
enddoc)
;{      ( ADDR  BLK#  FLAG (0=W, 1=R) --- )}
HEADER({R/W},{RSLW},{DOCOL})
        DC      TOR
        DC      BBUF, STAR
        DC      BHAN, FETCH, SWAP
        DC      LIT, SEEK_SET
        DC      LIT, lseek
        DC      LINOS
        DC      ZERO, MIN      ; 0/-errno
        DC      LDUP, DERR, STORE
        _0BRANCH( RSLW1 )
        DC      RDROP
        _BRANCH( RSLW2 )
RSLW1:
        DC      BHAN, FETCH, SWAP
        DC      BBUF
        DC      FROMR
        _0BRANCH( RSLW3 )
        DC     LIT, read
        _BRANCH( RSLW4 )
RSLW3:
        DC      LIT, write
RSLW4:  DC      LINOS
        DC      BBUF, UNEQ     ; { Catches errors (negative) too.}
        DC      DERR, STORE
RSLW2:  DC      DERR, FETCH
        DC      LIT, 8, QERR
        DC      SEMIS

});_END_({_LINUX_N_})

_LINUX_C_({
worddoc( {STORAGE},{BLOCK-INIT},{block_init},{---},{},
{Map the blocks on the block file forthcode({BLOCK-FILE}),
i.e. the mass storage words refer
to the blocks in this file. The handle to use it is
hidden in the c-code. forthcode({DISK-ERROR}) reflects whether the mapping was
successful. Reinstall forthcode({WARNING}) as appropriate!
_VERBOSE_({{
This word is executed by c-code outside of Forth.
This handling from c is problematic,
because forthcode({WARNING}) no longer is maintained properly.
We could import it to C , but there is no end to that.}})
},{{BLOCK},{LIST},{LOAD},{BLOCK-EXIT},{DISK-ERROR}}, {}, enddoc)
CODE_HEADER({BLOCK-INIT},{BLINI})
        MOV     AX,[_VAR_FIELD(BLFL)]
        MOV     BX,_VAR_FIELD(BLFL)+CW
        PUSH    BX
        PUSH    AX
        CALL    c_block_init
        MOV     [_VAR_FIELD(DERR)],AX
        LEA     ESP,[ESP+_CELLS(2)]    ; remove input
        _NEXT
;
worddoc( {STORAGE},{BLOCK-EXIT},{block_exit},{---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Close the currently open block file,
i.e. the mass storage words no longer work, and will result in
errors. Reinstall forthcode({WARNING}) as appropriate!
_VERBOSE_({{
This word is executed by c-code outside of Forth.
This handling from c is problematic,
because forthcode({WARNING}) no longer is maintained properly.
We could import it to C , but there is no end to that.}})
},{{BLOCK},{LIST},{LOAD},{DISK-ERROR}}, {}, enddoc)
CODE_HEADER({BLOCK-EXIT},{BLEXI})
        CALL    c_block_exit
        _NEXT
;
worddoc( {STORAGE},{R/W},{read_slash_write},{addr blk f --},{FIG},
{The ciforth primitive for read-write of blocks. forthvar({addr})
specifies the source or destination block buffer, forthsamp({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read or write and shows errors via forthcode({DISK-ERROR}).},
{{BLOCK}}, {}, enddoc)
;{      ( ADDR  BLK#  FLAG (0=W, 1=R)}
CODE_HEADER({R/W},{RSLW})
        CALL c_rslw
        MOV     [_VAR_FIELD(DERR)],AX
        LEA     ESP,[ESP+_CELLS(3)]    ; remove input
        _NEXT


});_END_({_LINUX_C_})
_RWSECTRK_({
worddoc( {STORAGE},{DRIVE},{drive},{--- addr},{},
{Leave the address forthvar({addr}) of a character buffer,
containing the
drive used for mass storage, the number of sectors in a
track, and the number of heads.
The drive
 is in MSDOS coding,
0 is floppy A: , 1 is floppy B:, 80H is drive C:,
81H is drive D: and so forth.
These parameters
may be switched but this should only be
attempted after forthcode({EMPTY-BUFFERS}) .
_VERBOSE_({These are manipulated in rare cases where an
other disk is to be accessed, such as installing a bootable
system on hard disk from floppy.})},
{{BLOCK},{FLUSH}}, {}, enddoc)
HEADER({DRIVE},{LDRIVE},{DOVAR}, )
LFDRIVE DB      DRIVE                   ; {To be used by Forth.}
LFSPT   DB      SPT
LFHEADS DB      HEADS
        _ALIGNED_({_ALIGN 4})
;
});_END_({ _RWSECTRK_})
_CLASSIC_({
; This the mass storage I/O that looks most like FIG.
; It may not be pretty but it surely is the smallest.
;
;
worddoc( {STORAGE},{DRIVE},{drive},{--- addr},{},
{Leave the address forthvar({addr}) of a variable containing the
drive used for mass storage. This is in MSDOS coding,
0 is floppy A: , 1 is floppy B:, 80H is drive C:,
81H is drive D: and so forth.
The drive may be switched but this should only be
attempted after forthcode({EMPTY-BUFFERS}) .},
{{BLOCK},{FLUSH}}, {}, enddoc)
HEADER({DRIVE},{LDRIVE},{DOVAR}, )
      DC  DRIVE
;
WERR    DB      'DISK WRITE ERROR  $'
RERR    DB      'DISK READ ERROR   $'
;
SBLK    PROC    NEAR
;{      ( ADDR  BLK# -- )}
;{      THIS ROUTINE WILL PREPARE PARAMETERS FOR DISK I/O}
;{       DRIVE, ADDRESS, LENGTH, SEC#}
        POP     DI      ;{SAVE RETURN}
        POP     AX      ;{BLK #}
        MOV     CX,SPB
        MUL     CX   ;{SEC #}
        MOV     DX,AX
        MOV     AL,[_VAR_FIELD(LDRIVE)]    ;{SELECT DR A}
        POP     BX      ;{TRANSFER ADDR}
        PUSH    DI      ;{GET THAT RETURN BACK}
        RET
_ENDP SBLK    ENDP
;
worddoc( {STORAGE},{RBLK},{read_block},{addr blk --},{},
{forthsamp({1 R/W}) is an abbreviation for forthsamp({RBLK}).
},{{R/W}}, {}, enddoc)
CODE_HEADER({RBLK},{RBLK})
        CALL    SBLK
        PUSH    HIP      ;{PRESERVE INTERPRETER POINTER}
        PUSH    RPO      ;{RETURN POINTER}
        INT     25H
        JNC     DOK     ;{NO ERRORS}
        LEA     DX,[RERR]
        JMP     RWERR
;
worddoc( {STORAGE},{WBLK},{write_block},{addr blk --},{},
{forthsamp({0 R/W}) is an abbreviation for forthsamp({WBLK}).
},{{R/W}}, {}, enddoc)
CODE_HEADER({WBLK},{WBLK})
        CALL    SBLK
        PUSH    HIP
        PUSH    RPO
        INT     26H
        JNC     DOK
        LEA     DX,[WERR]
;
;{ Error exit for both RBLK and WBLK }
RWERR:   PUSH    AX      ; DX contains message.
        MOV     AH,9    ;{String write fncn, obsolete for ages}
        INT     21H
        POP     AX      ;{ERROR CODE IN AX}
;
;{ Okay exit for both RBLK and WBLK }
DOK:    POPF            ;{POP FLAGS}
        POP     RPO      ;{RETURN STACK}
        POP     HIP      ;{INTERPRETER PNTR}
        _NEXT
;
worddoc( {STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The basic mass storage read-write linkage. (Already present in
figforth.) forthvar({addr}) specifies the source or destination
block buffer, forthsamp({blk}) is the sequential number of the
referenced physical block; and forthvar({f}) is a flag for
forthvar({f})=0 write and forthvar({f})=l read.
forthcode({R/W}) determines the location on mass storage,
performs the read-write. This version of ciforth features the
most classic mass storage. Blocks are counted sequentially from
0 on the drive with MSDOS code in forthcode({DRIVE}), so
forthcode({R/W}) can be used to write boot code. Errors are
handled by writing directly to the console after they are
detected. },
{{BLOCK},{DRIVE}}, {}, enddoc)
;{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
HEADER({R/W},{RSLW},{DOCOL})
         _SWITCH_({DC   ROT, LIT, M4_SWITCHOFFSET, PLUS, ROT, ROT})
        _0BRANCH(RSLW1)
        DC      RBLK
        _BRANCH(RSLW2)
RSLW1:  DC      WBLK
RSLW2:  DC      SEMIS
});_END_({_CLASSIC_})
_USEBIOS_({
;
worddoc( {STORAGE},{SEC/BLK},{sectors_per_block},{--- c},{},
{This constant leaves the number of sectors per block. _VERBOSE_(
The original idea was that a sector forthemph({is}) a block. In
fact SEC/BLK is set such that B/SRC is one, as is required for ISO.)
},{{BLOCK},{B/BUF}}, {}, enddoc)
HEADER({SEC/BLK},{SPBLK},{DOCON}, SPB)
;
});_END_({_USEBIOS_})
;
_RWSECTRK_({
worddoc( {STORAGE},{SEC-RW},{sector_read_write},{com addr sec --},{},
{Performs the forthcode({BIOS}) function forthsamp({com}) , for
a single sector
forthsamp({sec}) either a read to forthvar({addr}) or write from
forthvar({addr}) .
Disk errors are stored in
forthcode({DISK-ERROR}).},
{{BLOCK},{R/W}}, {}, enddoc)
HEADER({SEC-RW},{SECRW},{DOCOL})
        DC      LIT, LFSPT, CFET, SLMOD
        DC      LIT, LFHEADS, CFET, SLMOD   ;{ Now #sec, #head, #cyl}
        DC      TOR
        DC      RR, LIT, 8, RSHIFT, LIT, 6, LSHIFT ; {Bit 8, 9 of cyl}
        DC      ROT, ONEP, LOR         ; {Compose and in place.}
        DC      FROMR, LIT, 8, LSHIFT     ;{Bits 0..7 of #cyl.}
        DC      LOR   ;{ High, low -- reg CX. }
        DC      SWAP
        DC      LIT, 8, LSHIFT
        DC      LIT, LFDRIVE, CFET
        DC      LOR   ;{ High, low -- reg DX. }
        DC      LIT, 13H, BIOS
        DC      ONE, LAND, DERR, PSTORE
        DC      DROP, DROP, DROP, DROP
        DC      SEMIS
;
worddoc( {STORAGE},{R/W},{read_slash_write},{addr blk f --},{FIG},
{The ciforth primitive for read-write of blocks. forthvar({addr})
specifies the source or destination block buffer, forthsamp({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read-write and aborts with an error message for failures.
forthcode({DISK-ERROR}) contains an error count for the latest operation.
},
{{BLOCK},{DISK-ERROR},{SECRW}}, {}, enddoc)
;{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
HEADER({R/W},{RSLW},{DOCOL})
         _SWITCH_({DC   ROT, LIT, M4_SWITCHOFFSET, PLUS, ROT, ROT})
        DC      ZERO, DERR, STORE
        _0BRANCH(RSLW1)
        DC      LIT, 0201H      ;{ Read (AH) one (AL) sector }
        _BRANCH(RSLW2)
RSLW1:  DC      LIT, 0301H      ;{ Write (AH) one (AL) sector }
RSLW2:  DC      SWAP
        DC      SPBLK,  STAR
        DC      SPBLK,  OVER, PLUS
        DC      SWAP
        _DO(RSLW9)
RSLW0:
        DC      SWAP, TDUP
        DC      IDO
        DC      SECRW
        DC      LIT, BPS, PLUS, SWAP
        _LOOP(RSLW0)
RSLW9:
        DC      DROP, DROP
        DC      DERR, FETCH,     QDUP
        _0BRANCH(RSLW5)              ;{OK}
        DC      ZLESS
        _0BRANCH(RSLW3)
        DC      LIT,    9   ;{Write error}
        _BRANCH(RSLW4)
RSLW3:  DC      LIT,    8   ;{Read error}
RSLW4:  DC      ZERO,   PREV,   FETCH,     STORE   ;{This  buffer}
                                                   ;{ is no good!}
        DC      QERR    ; { 8 or 9. }
RSLW5:  DC      SEMIS
;
});_END_({ _RWSECTRK_})
_RWLBA_({

;{ Warning : if this LBA is used apart from by R/W}
;{ the fields marked default must be restored.}
worddoc( {STORAGE},{LBAPAR},{l_b_a_params},{--},{},
{ A data structure used by R/W , that also must be filled in for disk
operations forthcode({RBLK}) and forthcode({WBLK}) . Do not touch the
first 16-bits word. The second word is the number of sectors to be
transferred. The third and fourth word contain a long real mode
pointer where the data comes from or goes to. The fourth word
and fifth word is as 32 bit counter for the sector on the disc.
If a 2 Terabyte disk is not enough this can be extended into
the sixth and seventh word.
Word 1,2,4 6 and 7 must be restored to their previous value after
calling forthcode({RBLK}) and forthcode({WLBK}) so as not to interfere
with forthcode({R/W}). },
{{R/W},{BLOCK},{OFFSET}}, {}, enddoc)
HEADER({LBAPAR},{LBA},{DOVAR}, )
        DB      10H, 0      ;{ default    }
        DW      SPB         ;{ default    }
        DW      0           ;{ to be filled with offset}
        DW      _SWITCH_({SWITCHSEGMENT}) ;{ default segment}
        ;{ At a hard disk we just read sector from sector 1        }
        DD      0       ;{ sector number}
        DD      0       ;{ M.S. 32 BITS default}

worddoc( {STORAGE},{RBLK},{read_block},{--},{},
{Perform a disk read operation using a properly filled in LBA structure
in forthcode({LBAPAR}). },
{{R/W},{WBLK}}, {}, enddoc)
CODE_HEADER({RBLK},{RBLK})
        MOV     BX,4200H
        JMP    RWBLK
;
worddoc( {STORAGE},{WBLK},{write_block},{--},{},
{Perform a disk write operation using a properly filled in LBA
structure in forthcode({LBAPAR}). },
{{R/W},{RBLK}}, {}, enddoc)
CODE_HEADER({WBLK},{WBLK})
        MOV     BX,4300H
RWBLK:
        POP     AX
        PUSH    HIP      ;{PRESERVE INTERPRETER POINTER}
        _SWITCH_({ADD     AX, M4_SWITCHOFFSET })
        MOV     SI,AX
        PUSH    RPO      ;{RETURN POINTER}
        MOV     DX,0080H  ;{   Disk C                                 }
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    BX,AX
        INT     13H
        PUSHF           ;{ REMEMBER STATUS}
        POP     BX
        _SWITCH_({JMPHERE_FROM_OS})
        POP     RPO      ;{RETURN STACK}
        POP     HIP      ;{INTERPRETER PNTR}
        PUSH    BX
        _NEXT

worddoc( {STORAGE},{R/W},{read_slash_write},{addr blk f --},{},
{The ciforth primitive for read-write of blocks. forthvar({addr})
specifies the source or destination block buffer, It must reside
in the lowest 1 Mbyte of physical memory.
forthsamp({blk}) is
the sequential number of the referenced physical block; and
forthvar({f}) is a flag for forthvar({f})=0 write and forthvar({f})=l
read. forthcode({R/W}) determines the location on mass storage,
performs the read-write and aborts with an error message for failures.
This function uses ``LBA'' : Logical Block Addressing and may
not work on elderly hard disks.
_BITS16_({{Where blk is at most 64K the largest addressable disk is
64M , you can get around this by filling in forthcode({LBAPAR}) and then calling
 forthcode({RBLK}) or forthcode({WBLK}) }})
forthcode({DISK-ERROR}) contains the status of the latest operation,
bit 1 (carry flag) indicates an error.
},
{{BLOCK},{DISK-ERROR},{LBAPAR},{RBLK},{WBLK}}, {}, enddoc)
;{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
HEADER({R/W},{RSLW},{DOCOL})
        DC      TOR
        DC      SWAP
;       On a big endian machine the following code is 16/32 bit clean.
;       The 2 m.s. bytes are overwritten by the next store.
         _SWITCH_({DC   LIT, A_FORTH0, PLUS })
        DC      LDUP, LIT, 0FH, LAND
        DC      LBA, LIT, 4, PLUS, STORE   ; { Address }
        DC      LIT, 4, RSHIFT
        DC      LBA, LIT, 6, PLUS, STORE
        DC      LIT, SPB, STAR  ;{ Sector number}
        DC      LBA, LIT, 8, PLUS, STORE ; { Sector number. }
        DC      LBA
        DC      RR
        _0BRANCH(RSLW1)
        DC      RBLK
        _BRANCH(RSLW2)
RSLW1:  DC      WBLK
RSLW2:  DC      LDUP, DERR, STORE

        DC      ONE, LAND, LDUP
        _0BRANCH(RSLW4)
;{        DC      ZERO,   PREV,   FETCH,     STORE   ;This  buffer}
                                                   ;{ is no good!}
RSLW4:
        ;{ Handle error}
        DC      LIT,    9   ;{Write error}
        DC      FROMR, LSUB ;{ 1 less: read error}
        DC      QERR    ;{8 or 9 }
        DC      SEMIS
;
});_END_({ _RWLBA_})
;
_LOAD_({
worddocsafe( {DICTIONARY},{[']},{bracket_tick_bracket},{--- addr},{ISO,I},
{Used in the form: .
forthcode({[']}) forthsamp({nnnn})
Leaves the dictionary entry address of dictionary word forthsamp({nnnn}).
This also serves as an execution token.
As a compiler directive, executes in a colon-definition to
compile the address as a literal. If the word is not found
after a search of forthcode({SEARCH-ORDER}) and
forthcode({CURRENT}), an appropriate error message is given.
This word is intended for compilation mode, using it in interpret
mode in ciforth is harmless, but useless.
It is recommended this word is not used at all, and certainly
not postponed (Use forthcode({FOUND}) .).},
{{FOUND},{'},{EXECUTE}} ,
{{ : APE 1 2 ; : GS1 ['] APE ; GS1 EXECUTE  GS1 ID. . .},{APE 2 1}},
enddoc)
dnl An alias header. CFA DFA are the same.
HEADER({[']},{BTICK},{DOCOL}, _VAR_FIELD({TICK}), B_IMMED)
;
});_END_({_LOAD_})
worddoc( {DICTIONARY~},{FORGET-VOC},{forget_voc},{deaw deav --
deaw },{}, {Forget the words forthvar({deaw}) and all later
words from the forthcode({VOCABULARY}) whose DEA is given by
forthvar({deav}) . Leave forthvar({deaw}) (as
forthcode({FORGET-VOC}) is intended to be used with
forthcode({FOR-VOCS})) . If any whole vocabulary is forgotten,
the search order is reset to forthsamp({ONLY FORTH}). },
{{FORGET}},
{
{!CSP VOCABULARY APE dnl
APE DEFINITIONS : GO ; : CH ; : GI ; dnl
FORTH DEFINITIONS : NEW ; ?CSP},{},
{APE ' CH ' APE FORGET-VOC ID.},{CH},
{APE DEFINITIONS LATEST ID.},{GO},
{FORTH DEFINITIONS LATEST ID.},{NEW},
},
enddoc)
HEADER({FORGET-VOC},{FORGV},{DOCOL})
        DC      TDUP
        DC      SWAP
        DC      ULESS
        _0BRANCH(FORGV1)
; { Forget part of contents.}
        DC      SWAP
        DC      TOR
        DC      TWID
        DC      LDUP
FORGV3:
        DC      TLFA,FETCH    ; {Next voc}
        DC      LDUP
        DC      RR
        DC      ULESS
        _0BRANCH(FORGV3)
        DC      SWAP
        DC      TLFA
        DC      STORE
        DC      FROMR
        _BRANCH(FORGV2)
FORGV1:
;       { Vocabulary itself is also forgotten.}
        DC      TVFA
        DC      FETCH     ;{ Unlink by linking next vocabulary.}
        DC      VOCL
        DC      STORE
        DC      ONLY, FORTH
        DC      DEFIN
FORGV2: DC      SEMIS
;
worddoc( {DICTIONARY},{FORGET},{forget},{},{ISO,FIG,E,L0},
{Executed in the form:
               forthcode({FORGET}) forthvar({cccc})
Deletes definition named forthvar({cccc}) from the dictionary
with all entries physically following it.
},
{{FENCE},{FORGET-VOC}},
{
{: GO ; HERE : CH ; : GI ; FORGET CH LATEST ID. },{GO},
{HERE - .},{0},
},
enddoc)
HEADER({FORGET},{FORG},{DOCOL})
        DC      TICK
        DC      LDUP
        DC      FENCE
        DC      FETCH
        DC      LESS
        DC      LIT, 21, QERR
        DC      LIT,FORGV
        DC      FORV
        DC      TNFA, FETCH, LDP, STORE
        DC      SEMIS
;
worddocsafe( {CONTROL~},{(BACK},{paren_back},{--- addr},{},
{Start a backward branch by leaving the target address
forthcode({HERE}) into forthvar({addr}). _VERBOSE_({Usage is
forthsamp({ (BACK .. POSTPONE BRANCH BACK) }) })},
{{LOOP},{UNTIL}},
{
{: GS1 -1 [ (BACK ] 1+ DUP .
DUP 0BRANCH [ BACK) ] ; GS1 .},
{0 1 1}
},
enddoc)
HEADER({(BACK},{PBACK},{DOCOL})
        DC      HERE
        DC      SEMIS
;
worddocsafe( {CONTROL~},{BACK)},{back_paren},{addr ---},{},
{Complete a backward branch by compiling an offset from
forthcode({HERE}) to forthvar({addr}), left there by
forthcode({paren_BACK}) . _VERBOSE_({Usage is
forthsamp({ (BACK .. POSTPONE BRANCH BACK) }) })},
{{LOOP},{UNTIL}},
{{( See (BACK )},{}},
enddoc)
HEADER({BACK)},{BACKP},{DOCOL})
        DC      HERE
        DC      CELLP
        DC      LSUB
        DC      COMMA
        DC      SEMIS
;
worddocsafe( {CONTROL~},{(FORWARD},{paren_forward},{--- addr},{},
{Start a forward branch by leaving the address that must be
backpatched with an offset into forthvar({addr}).
_VERBOSE_({Usage is
forthsamp({ POSTPONE BRANCH (FORWARD .. FORWARD) }) })},
{{LOOP},{UNTIL}},
{
{: GS1 2 BRANCH [ (FORWARD ] 4 [ FORWARD) ] 6 ; GS1 . .},
{6 2}
},
enddoc)
HEADER({(FORWARD},{PFORWARD},{DOCOL})
        DC      HERE
        DC      ZERO
        DC      COMMA
        DC      SEMIS
;
worddocsafe( {CONTROL~},{FORWARD)},{forward_paren},{addr ---},{},
{Complete a forward branch by backpatching an offset from
forthcode({HERE}) into forthvar({addr}), left there by
forthcode({(FORWARD)}) . _VERBOSE_({Usage is forthsamp({
POSTPONE BRANCH (FORWARD .. FORWARD) }) })},
{{LOOP},{UNTIL}},
{{( See (FORWARD)},{}},
enddoc)
HEADER({FORWARD)},{FORWARDP},{DOCOL})
        DC      HERE
        DC      OVER
        DC      CELLP
        DC      LSUB
        DC      SWAP
        DC      STORE
        DC      SEMIS
;
worddoc( {CONTROL},{BEGIN},{begin},{--- addr n  (compiling)},{ISO,FIG,I,L0},
{Occurs in a colon-definition in one of the forms:
  forthexample({BEGIN ... UNTIL})
  forthexample({BEGIN ... AGAIN})
  forthexample({BEGIN ... WHILE ... REPEAT})
At run-time, forthcode({BEGIN}) marks the start of a sequence that may be
repetitively executed. It serves as a return point from the
corresponding forthcode({UNTIL}) , forthcode({AGAIN}) or forthcode({REPEAT})
When executing forthcode({UNTIL}) a return
to forthcode({BEGIN}) will occur if the top of the stack is false;
for forthcode({AGAIN}) and forthcode({REPEAT}) a return to forthcode({BEGIN}) always occurs.

At compile time forthcode({BEGIN}) leaves its return address and forthvar({n}) for compiler
error checking.},{{(BACK}},
{{( See AGAIN WHILE)},{}},
enddoc)
HEADER({BEGIN},{BEGIN},{DOCOL}, , B_IMMED)
        DC      PBACK
        _SECURITY_({DC      QCOMP, ONE})
        DC      SEMIS
;
worddoc( {CONTROL},{THEN},{endif},{addr n --- (compile)},{ISO,FIG,I,CO,L0},
{Occurs in a colon-definition in form:
 forthexample({IF ... THEN})
 forthexample({IF ... ELSE ... THEN})
At run-time, forthcode({THEN}) serves only as the destination
of a forward branch from forthcode({IF}) or forthcode({ELSE}) .
It marks the conclusion of the conditional structure. At
compile-time, forthcode({THEN}) computes the forward branch
offset from forthvar({addr}) to forthcode({HERE}) and stores it
at forthvar({addr}) . forthvar({n}) is used for error tests.},
{{IF},{ELSE}},
{{( See IF ELSE)},{}},
enddoc)
HEADER({THEN},{THEN},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, TWO, QPAIR})
        DC      FORWARDP
        DC      SEMIS
;
worddoc( {CONTROL},{DO},{do},
{n1 n2 --- (execute) addr n --- (compile)},{ISO,FIG,I,C2,L0},
{Occurs in a colon-definition in form: forthsamp({DO ... LOOP})
At run time, forthcode({DO}) begins a sequence with repetitive
execution controlled by a loop limit forthvar({n1}) and an
index with initial value forthvar({n2}) .
forthcode({DO}) removes
these from the stack. Upon reaching forthcode({LOOP}) the
index is incremented by one. Until the new index equals or
exceeds the limit, execution loops back to just after
forthcode({DO}) ; otherwise the loop parameters are discarded
and execution continues ahead. Both forthvar({n1}) and
forthvar({n2}) are determined at run-time and may be the result
of other operations. Within a loop forthcode({I}) will copy the
current value of the index to the stack.

When compiling within the colon definition, forthcode({DO}) compiles forthcode({(DO)}) , leaves
the following address forthvar({addr}) and forthvar({n}) for later error checking.},
{{I},{LOOP},{+LOOP},{LEAVE}},
{ { : GS1 DO 41 EMIT LOOP ; 3 0 GS1},{AAA},
  {: GS3 0 1 1 DO 1+ I 4 = IF LEAVE THEN LOOP . ; GS3 },{1} },
enddoc)
dnl ISO VIOLATION :
dnl {: GS3 0 1 1 DO 1+ I 4 = IF LEAVE THEN LOOP . ; GS3 },{4},
HEADER({DO},{DO},{DOCOL}, , B_IMMED)
         DC      LIT, XDO, COMMA, PFORWARD, PBACK
        _SECURITY_({DC      LIT,3    ;{ Magic number}})
        DC      SEMIS
;
worddoc( {CONTROL},{?DO},{question_do},{n1 n2 --- (execute)
addr n --- (compile)},{ISO,I,C2,L0},
{Occurs in a colon-definition in form:
    forthexample({?DO ... LOOP})
It behaves like DO , with the exception that if n1 and n2 are equal
the loop body is not executed.},
{{DO},{I},{LOOP},{+LOOP},{LEAVE}},
{ { : GS1 ?DO 41 EMIT LOOP 0 . ; 3 0 GS1},{AAA0 },
  {: GS3 0 1 1 ?DO I . LOOP . ; GS3 },{0} },
enddoc)
HEADER({?DO},{QDO},{DOCOL}, , B_IMMED)
         DC      LIT, XQDO, COMMA, PFORWARD, PBACK
        _SECURITY_({DC      LIT,3    ;{ Magic number}})
        DC      SEMIS
;
worddoc( {CONTROL},{LOOP},{loop},
{ --- (run) addr n --- (compiling)},{ISO,I,C2,L0},
{Occurs in a colon-definition in form:
    forthexample({DO ... LOOP})
At run-time, forthcode({LOOP}) selectively controls branching
back to the corresponding forthcode({DO}) based on the loop
index and limit. The loop index is incremented by one and
compared to the limit. The branch back to
forthcode({DO}) occurs until the index equals or exceeds the
limit; at that time, the parameters are discarded and execution
continues ahead.

At compile-time, forthcode({LOOP}) compiles
forthcode({(LOOP)}) and uses forthvar({addr}) to calculate an
offset to forthsamp({DO}) . forthvar({n2}) is used for compile
time error checking.},
{{+LOOP}},
{ { : GS1 DO I . LOOP ; 2 -2 GS1},{-2 -1 0 1},
  { : GS2 DO I . LOOP ; 4 0 GS2},{0 1 2 3} },
enddoc)
HEADER({LOOP},{LLOOP},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      LIT, 3, QPAIR})
        DC      LIT, XLOOP, COMMA, BACKP
        DC      FORWARDP ;{ For DO to push the leave address.}
        DC      SEMIS
;
worddoc( {CONTROL},{+LOOP},{plus_loop},
{n1 --- (run)  addr n2 --- (compile)},{ISO,I,C2,L0},
{Used in a colon-definition in the form:
    forthexample({DO ... n1 +LOOP})
At run-time, forthcode({+LOOP}) selectively controls branching
back to the corresponding forthcode({DO}) based on
forthvar({n1}) , the loop index and the loop limit. The signed
increment forthvar({n1}) is added to the index and the total
compared to the limit. The branch back to forthcode({DO})
occurs until the new index is equal to or greater than the
limit (forthsamp({n1>0})), or until the new index is equal to or
less than the limit (forthsamp({n1<0})). Upon exiting the loop,
the parameters are discarded and execution continues ahead.

At compile time, forthcode({+LOOP}) compiles the run-time word
forthcode({(+LOOP)}) and the branch offset computed from
forthcode({HERE}) to the address left on the stack by
forthcode({DO}) .
 forthvar({n2}) is used for compile time error
checking.},{},
{ { : GS1 DO I . -1 +LOOP ; -1 2 GS1},{2 1 0 -1},
  { : GS2 DO I . 2 +LOOP ; 4 0 GS2},{0 2 } },
enddoc)
HEADER({+LOOP},{PLOOP},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      LIT, 3, QPAIR})
        DC      LIT, XPLOO, COMMA, BACKP
        DC      FORWARDP ;{ For DO to push the leave address.}
        DC      SEMIS
;
worddoc( {CONTROL},{UNTIL},{until},
{f --- (run-time) addr n --- (compile)},{ISO,FIG,I,C2,L0},
{Occurs within a colon-definition in the form:
              forthexample({BEGIN ... UNTIL})
At run-time, forthcode({UNTIL}) controls the conditional branch
back to the corresponding forthcode({BEGIN}) If f is false,
execution returns to just after forthcode({BEGIN}) . if true,
execution continues ahead.

At compile-time, forthcode({UNTIL}) compiles
forthcode({0BRANCH}) and an offset from forthcode({HERE}) to
addr. forthvar({n}) is used for error tests.},
{{BEGIN}},
{
{: GI4 BEGIN DUP . 1+ DUP 5 > UNTIL ; 3 GI4 .},{3 4 5 6},
{8 GI4 .},{8 9}
},
enddoc)
HEADER({UNTIL},{UNTIL},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      ONE, QPAIR})
        DC      LIT, ZBRAN, COMMA, BACKP
        DC      SEMIS
;
worddoc( {CONTROL},{AGAIN},{again},{addr n --- (compiling)},{FIG,I,C2,L0},
{Used in a colon-definition in the form:
    forthexample({BEGIN ... AGAIN})
At run-time,
forthcode({AGAIN}) forces execution to return to corresponding
forthcode({BEGIN}) . There is no effect on the stack. Execution
cannot leave this loop except for forthcode({EXIT}). At compile
time, forthcode({AGAIN}) compiles forthcode({BRANCH}) with an
offset from forthcode({HERE}) to addr. forthvar({n}) is used
for compile-time error checking.},
{{BEGIN}},
{
{ : GCE2 BEGIN DUP . 1 - DUP 0= IF EXIT THEN AGAIN ; 3 GCE2},
{3 2 1}
},
enddoc)
HEADER({AGAIN},{AGAIN},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      ONE, QPAIR})
        DC      LIT, BRAN, COMMA, BACKP
        DC      SEMIS
;
worddoc( {CONTROL},{REPEAT},{repeat},{addr1 n1 addr2 n2--- (compiling)},{ISO,FIG,I,C2},
{Used within a colon-definition in the form:
    forthexample({BEGIN ... WHILE ... REPEAT})
At run-time, forthcode({REPEAT}) forces an unconditional branch
back to just after the corresponding forthcode({BEGIN}) .

At compile-time, forthcode({REPEAT}) compiles
forthcode({BRANCH}) and the offset from forthcode({HERE}) to
forthvar({addr2}) . Then it fills in another branch offset at
forthvar({addr1}) left there by forthcode({WHILE}) .
forthsamp({n1 n2}) is used for error testing.},
{{WHILE}},{
{ : GI3 BEGIN DUP 4 < WHILE DUP . 1+ REPEAT ; 0 GI3 .},
{0 1 2 3 4}
},
enddoc)
HEADER({REPEAT},{REPEA},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      ONE, QPAIR   ; {Matches BEGIN ?}})
        DC      LIT, BRAN, COMMA, BACKP
        _SECURITY_({DC      QCOMP, LIT, 4, QPAIR ; {Matches WHILE ?}})
        DC      FORWARDP ;{ WHILE target. }
        DC      SEMIS
;
worddoc( {CONTROL},{IF},{if},
{f --- (run-time) / --- addr n (compile)},
{ISO,FIG,I,C2,L0},
{Occurs is a colon-definition in form:
      forthexample({IF (tp) ...  THEN})
    or
      forthexample({IF (tp) ... ELSE (fp) ... THEN})
At run-time, forthcode({IF}) selects execution based on a
boolean flag. If forthvar({f}) is true (non-zero), execution
continues ahead thru the true part. If forthvar({f}) is false
(zero), execution skips till just after forthcode({ELSE}) to
execute the false part. After either part, execution resumes
after forthcode({THEN}).
forthcode({ELSE}) and its false part are optional.; if missing,
false execution skips to just after forthcode({THEN}) .

At compile-time forthcode({IF}) compiles
forthcode({0BRANCH}) and reserves space for an offset at
forthvar({addr}) . forthvar({addr}) and forthvar({n}) are
used later for resolution of the offset and error testing.},
{},
{
{ : GI1 IF 123 THEN ; 234 1 GI1 . .},{123 234},
{  234 -1 GI1 . .},{123 234},
{  234 0 GI1 .},{234},
},
enddoc)
HEADER({IF},{LIF},{DOCOL}, , B_IMMED)
        DC      LIT, ZBRAN, COMMA, PFORWARD
        _SECURITY_({DC      TWO     ;{ Magic number}})
        DC      SEMIS
;
worddoc( {CONTROL},{ELSE},{else},{addr1 n1 --- addr2 n2 (compiling)},
{ISO,FIG,I,C2,L0},
{Occurs within a colon-definition in the form:
               forthexample({IF ... ELSE ... THEN})
At run-time, forthcode({ELSE}) executes after the true part
following forthcode({IF}) . forthcode({ELSE}) forces execution
to skip over the following false part and resumes execution
after the forthcode({THEN}) . It has no stack effect.

At compile-time forthcode({ELSE}) emplaces
forthcode({BRANCH}) reserving a branch offset, leaves the
address forthvar({addr2}) and forthvar({n2}) for error
testing. forthcode({ELSE}) also resolves the pending forward
branch from forthcode({IF}) by calculating the offset from
forthvar({addr1}) to forthcode({HERE}) and storing at
forthvar({addr1}) .},
{},
{
{: GI2 IF 123 ELSE 234 THEN ; 0 GI2 .},{234},
{1 GI2 .},{123}
},
enddoc)
HEADER({ELSE},{LELSE},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, TWO, QPAIR})
        DC      LIT, BRAN, COMMA, PFORWARD
        DC      SWAP
        DC      FORWARDP
        _SECURITY_({DC      TWO     ;{ Magic number}})
        DC      SEMIS
;
worddoc( {CONTROL},{WHILE},{while},
{f --- (run-time) ad1 nl --- ad2 n1 ad1 n2(compile-time)},
{ISO,FIG,I,C2},
{Occurs in a colon-definition in the form:
         forthsamp({BEGIN ... WHILE (tp) ... REPEAT})
At run-time, forthcode({WHILE}) selects conditional execution
based on boolean flag forthvar({f}) . If forthvar({f}) is true
(non-zero), forthcode({WHILE}) continues execution of the true
part thru to forthcode({REPEAT}) , which then branches back to
forthcode({BEGIN}) . If forthvar({f}) is false (zero),
execution skips to just after forthcode({REPEAT}) , exiting the
structure.

At compile time, forthcode({WHILE}) emplaces
forthcode({0BRANCH}) and tuck leaves forthsamp({ad2}) of the
reserved offset under the forthsamp({ad1}) left there by
forthcode({BEGIN}) . The stack values will be resolved by
Forthcode({REPEAT}) . forthvar({n1}) and forthvar({n2})
provide checks for compiler security.},
{{BEGIN}},
{
{ : GI3 BEGIN DUP 4 < WHILE DUP . DUP 1+ REPEAT ; 0 GI3 .},
{0 1 2 3 4},
{6 GI3 .},{6}
},
enddoc)
HEADER({WHILE},{LWHILE},{DOCOL}, , B_IMMED)
        DC      TOR    ; { Save backward target. }
        _SECURITY_({DC      TOR})
        DC      LIT, ZBRAN, COMMA, PFORWARD
        _SECURITY_({DC      LIT, 4 ;{ Magic number}})
        _SECURITY_({DC      FROMR})
        DC      FROMR
        DC      SEMIS
;
worddoc( {OUTPUT},{SPACES},{spaces},{n ---},{ISO,FIG,L0},
{If forthvar({n}) is greater or equal to zero, display as much
spaces. },{{SPACE},{OUT}},
{
{41 EMIT 0 SPACES 41 EMIT},{AA},
{41 EMIT 3 SPACES 41 EMIT},{A   A}
},
enddoc)
HEADER({SPACES},{SPACES},{DOCOL})
        DC      ZERO
        DC      MAX
        DC      QDUP
        _0BRANCH(SPAX1)
        DC      ZERO
        _DO(SPAX1)
SPAX2:  DC      SPACE
        _LOOP(SPAX2)    ;{LOOP}
SPAX1:
        DC      SEMIS
;
worddoc( {FORMATTING},{<#},{less_number_sign},{},{ISO,FIG,L0},
{Setup for pictured numeric output formatting using the words:
forthcode({<#}) forthcode({#}) forthcode({#S})
forthcode({SIGN}) forthcode({#>}) The conversion is done on a
double number producing text growing down from forthcode({PAD})
.},
{{DPL},{HLD},{HOLD},{FLD}},
{
 {!CSP 123.456 <# #> TYPE ?CSP}, {},
 {!CSP 1234.56 <# # # &. HOLD #S #> TYPE ?CSP}, {1234.56 }
},
enddoc)
HEADER({<#},{BDIGS},{DOCOL})
        DC      PAD
        DC      HLD
        DC      STORE
        DC      SEMIS
;
worddoc( {FORMATTING},{#>},{number_sign_greater},{d --- sc },{ISO,FIG,L0},
{Terminates numeric output conversion by dropping forthvar({d}), leaving
the formatted string forthvar({sc}) .},
{{<#}},
{{( Via <#)},{}},
enddoc)
HEADER({#>},{EDIGS},{DOCOL})
        DC      DROP
        DC      DROP
        DC      HLD
        DC      FETCH
        DC      PAD
        DC      OVER
        DC      LSUB
        DC      SEMIS
;
worddoc( {FORMATTING},{SIGN},{sign},{n --- },{ISO,FIG},
{Stores an ascii "-" sign just before a converted numeric output
string in the text output buffer when forthvar({n}) is negative.
Must be used between forthcode({<#}) and
forthcode({#>}) .},
{{HOLD}},
{ {!CSP <# 1 0 -1 SIGN # -1 SIGN # # #> TYPE ?CSP}, {00-1-} },
{},
enddoc)
HEADER({SIGN},{SIGN},{DOCOL})
        DC      ZLESS
        _0BRANCH(SIGN1) ;{IF}
        DC      LIT,2DH
        DC      HOLD    ;{THEN}
SIGN1:  DC      SEMIS
;
worddoc( {FORMATTING},{#},{number_sign},{d1 --- d2},{ISO,FIG,L0},
{Generate from a double number forthvar({d1}), the next ascii
character which is placed in an output string. Result
forthvar({d2}) is the quotient after division by
forthcode({BASE}), and is maintained for further processing.
Used between forthcode({<#}) and forthcode({#>}).},
{{#S}},
{
{!CSP 65.123 <# # # #> TYPE ?CSP},{23}
},
enddoc)
HEADER({#},{DIG},{DOCOL})
        DC      BASE
        DC      FETCH
        DC      MSMOD
        DC      ROT
        DC      LIT,9
        DC      OVER
        DC      LESS
        _0BRANCH(DIG1)  ;{IF}
        DC      LIT,7
        DC      PLUS    ;{THEN}
DIG1:   DC      LIT,30H
        DC      PLUS
        DC      HOLD
        DC      SEMIS
;
worddoc( {FORMATTING},{#S},{number_sign_s},{d1 --- d2},{ISO,FIG,L0},
{Generates ascii text in the text output buffer,
by the use of (sharp) dnl forthcode({#}),
until a zero double number forthvar({d2}) results.
Used between forthcode({<#}) and forthcode({#>}).},{},
{
{!CSP 1.23 <# #S #> TYPE ?CSP},{123},
{!CSP 1.23456 <# #S #> TYPE ?CSP},{123456}
},
enddoc)
HEADER({#S},{DIGS},{DOCOL})
DIGS1:  DC      DIG     ;{BEGIN}
        DC      OVER
        DC      OVER
        DC      LOR
        DC      ZEQU
        _0BRANCH(DIGS1) ;{UNTIL}
        DC      SEMIS
;
worddoc( {OUTPUT},{D.R},{d_dot_r},{d n ---},{ISO,FIG},
{Print a signed double number forthvar({d}) right aligned in a
field forthvar({n}) characters wide. Enlarge the field, if
needed. _VERBOSE_({{By giving a field length of 0, it is ignored.}}).

},
{{OUT},{D.}},
{{-12. 41 EMIT 5 D.R 41 EMIT},{A  -12A}},
enddoc)
HEADER({D.R},{DDOTR},{DOCOL})
        DC      TOR
        DC      SWAP
        DC      OVER
        DC      DABS
        DC      BDIGS
        DC      DIGS
        DC      ROT
        DC      SIGN
        DC      EDIGS
        DC      FROMR
        DC      OVER
        DC      LSUB
        DC      SPACES
        DC      LTYPE
        DC      SEMIS
;
worddocsafe( {OUTPUT},{.R},{dot_r},{n1 n2 ---},{},
{Print the number n1 right aligned in a field whose width is forthvar({n2}) . No
following blank is printed.},{{OUT},{.}},
{{-12 41 EMIT 5 .R 41 EMIT},{A  -12A}},
enddoc)
HEADER({.R},{DOTR},{DOCOL})
        DC      TOR
        DC      STOD
        DC      FROMR
        DC      DDOTR
        DC      SEMIS
;
worddoc( {OUTPUT},{D.},{d_dot},{d ---},{ISO,FIG,L1},
{Print a signed double number forthvar({d}),
according to the current forthcode({BASE}) . A blank follows.
},{{OUT},{.},{D.R}},
{{-12. D. 41 EMIT},{-12 A}},
enddoc)
HEADER({D.},{DDOT},{DOCOL})
        DC      ZERO
        DC      DDOTR
        DC      SPACE
        DC      SEMIS
;
worddocsafe( {OUTPUT},{.},{dot},{n ---},{ISO,FIG,L0},
{Print a number from a signed _BITS_ bit two's complement value,
converted according to the numeric forthcode({BASE}) .
A blanks follows.},
{{OUT},{U.},{.R},{D.R},{D.}},
{{-12 41 EMIT . 41 EMIT},{A-12 A}},
enddoc)
HEADER({.},{DOT},{DOCOL})
        DC      STOD
        DC      DDOT
        DC      SEMIS
;
worddoc( {OUTPUT},{?},{question},{addr --},{ISO,FIG,L0},
{Print the value contained at the address in free format according to
the current base.},
{{OUT},{.}},
{{-12 PAD ! 41 EMIT PAD ? DROP 41 EMIT},{A-12 A}},
enddoc)
HEADER({?},{QUES},{DOCOL})
        DC      FETCH
        DC      DOT
        DC      SEMIS
;
worddocsafe( {OUTPUT},{U.},{u_dot},{u ---},{ISO},
{Print a number from a unsigned _BITS_ bit value,
converted according to the numeric forthcode({BASE}) .
A trailing blanks
follows.},
{{OUT},{.},{.R},{D.R},{D.}},
_BITS32_({ {{12 41 EMIT U. 41 EMIT},{A12 A},
{-1 41 EMIT U. 41 EMIT},{AFFFFFFFF A}},})
_BITS16_({ {{12 41 EMIT U. 41 EMIT},{A12 A},
{-1 41 EMIT U. 41 EMIT},{AFFFF A}},})
enddoc)
HEADER({U.},{UDOT},{DOCOL})
        DC      ZERO
        DC      DDOT
        DC      SEMIS
;
worddoc( {DICTIONARY~},{FOR-WORDS},{for_words},{x1...xn xt wid --x1...xn},{},
{For all words from a word list identified by
forthvar({wid})
execute forthsamp({xt})
 with as data forthsamp({x1..xn}) plus
the forthdefi({DEA}) of those words.         forthsamp({xt})
must have the stack diagram forthsamp({x1..xn dea --- x1..xn}).
_VERBOSE_({{Note that you can use the DEA of any word as a WID
and the remainder of the word list will be searched.}})
},
{{FOR-VOCS},{EXECUTE}},
{{( See MATCHING-WORDS)},{}},
enddoc)
HEADER({FOR-WORDS},{FORW},{DOCOL})
        DC      SWAP
        DC      TOR
        DC      TOR
FORW1:  DC      FROMR
        DC      RR
        DC      OVER
        DC      TLFA
        DC      FETCH
        DC      TOR
        DC      EXEC
        DC      RR
        DC      ZEQU
        _0BRANCH(FORW1)
        DC      RDROP
        DC      RDROP
        DC      SEMIS
;
worddoc( {DICTIONARY~},{FOR-VOCS},{for_vocs},{x1..xn xt --- x1...xn},{},
{For all vocabularies execute forthsamp({xt})
 with as data the forthdefi({DEA}) of those words. forthsamp({xt})
must have the stack diagram forthsamp({x1..xn dea --- x1..xn})
},
{{FOR-WORDS},{EXECUTE}},
{
{ VOCABULARY JOHN JOHN DEFINITIONS : ORAN ; ' ID. FOR-VOCS},
{JOHN ENVIRONMENT DENOTATION FORTH},
{FORTH DEFINITIONS},{}
},
enddoc)
HEADER({FOR-VOCS},{FORV},{DOCOL})
        DC      TOR
        DC      VOCL
        DC      FETCH
        DC      TOR
FORV1:  DC      FROMR
        DC      RR
        DC      OVER
        DC      TVFA
        DC      FETCH
        DC      TOR
        DC      EXEC
        DC      RR
        DC      ZEQU
        _0BRANCH(FORV1)
        DC      RDROP
        DC      RDROP
        DC      SEMIS
;
worddoc( {DICTIONARY},{WORDS},{words},{},{ISO},
{List the names of the definitions in the topmost word list of the
search order.
dnl A break as per forthcode({KEY?}) will terminate the listing.
}, {},
{
{VOCABULARY JOHN JOHN DEFINITIONS : GO ; : CH ; : GI ; },{},
{: Q ' GO >LFA ;},{},
{: GS1 Q @ 0 Q ! WORDS Q ! ; GS1},{GS1 Q GI CH GO},
{FORTH DEFINITIONS},{}
},
enddoc)
HEADER({WORDS},{WORDS},{DOCOL})
        DC      CSLL
        DC      LOUT
        DC      STORE
        DC      LIT, IDDOT
        DC      SEARCH
        DC      FETCH
        DC      FORW
        DC      SEMIS
;
_NORMAL_BYE_({
worddoc( {OPERATINGSYSTEM},{BYE},{bye},{---},{ISO FIG},
{Return to the host environment MSDOS , OS/2, Windows.
},{{COLD}},
{{." interactive"},{interactive}},
enddoc)
;{Works for DPMI too. If it was high level and called BIOS, it would not.}
CODE_HEADER({BYE},{BYE})
        MOV     AX,4C00H
        INT     21H
;{ EXIT TO PC-DOS}
});_END_({ _NORMAL_BYE_})
_ABSOLUTELOAD_({
worddoc( {OPERATINGSYSTEM},{BYE},{bye},{---},{ISO FIG},
{_PROTECTED_({Switch back to real mode.})
Return to the host environment MSDOS.
},{{COLD}},
{{." interactive"},{interactive}},
enddoc)
CODE_HEADER({BYE},{BYE})
;{ EXIT TO PC-DOS, if run from PC-DOS, otherwise hang or whatever.}
        _SWITCH_({JMPHERE_FROM_FORTH})
RETDOSV: JMP 0:0        ; {Filled in during boot}
        _BITS32_({SET_32_BIT_MODE})

});_END_({ _ABSOLUTELOAD_})
_HOSTED_LINUX_({
worddoc( {OPERATINGSYSTEM},{BYE},{bye},{---},{ISO},
{Return to the host environment Linux.
},{{COLD}},
{{." interactive"},{interactive}},
enddoc)
HEADER({BYE},{BYE},{DOCOL})
;{ Exit to linux, with okay status. }
        DC      ZERO, ZERO, ZERO, ONE, LINOS
        DC      SEMIS   ;{Unnecessary, but helpful for decompilation.}
});_END_({ _HOSTED_LINUX_})
;
worddoc( {SCREEN},{LIST},{list},{n ---},{ISO,FIG,L0},
{Display the ascii text of forthdefi({screen}) forthvar({n}).
The number of the screen is always printed in decimal.
forthcode({SCR}) contains the screen number during and after this process.},
{{BLOCK}},
{{." interactive"},{interactive}},
enddoc)
HEADER({LIST},{LLIST},{DOCOL})
        DC      SCR,STORE
        _STRINGINLINE({SCR # })
        DC      LTYPE
        DC      BASE, FETCH
        DC      DECA
        DC      SCR, FETCH, DOT
        DC      BASE, STORE
        DC      SCR, FETCH, BLOCK
        DC      LIT,1024
LLIST1: DC      LIT, ALF, SSPLIT
        DC      CR, LTYPE
        DC      OVER,ZEQU ;{DUP would not show a last empty line!}
        _0BRANCH(LLIST1)
        DC      TDROP
        DC      SEMIS
;
worddoc( {SCREEN},{INDEX},{index},{from to --},{},
{Print the first line of each screen over the inclusive
range
forthsamp({from}) , forthsamp({to}) . This is used to view the
comment lines of an area of text on disc screens.},
{{LIST}},
{{." interactive"},{interactive}},
enddoc)
HEADER({INDEX},{INDEX},{DOCOL})
        DC      LIT,AFF
        DC      EMIT,CR
        DC      ONEP,SWAP
        _DO(INDE9)
INDE1:  DC      CR,IDO
        DC      LIT,3
        DC      DOTR,SPACE
        DC      ZERO,IDO
        DC      DLINE,KEYQ
        _0BRANCH(INDE2)
        DC      LLEAV
INDE2:  _LOOP(INDE1)
INDE9:
        DC      SEMIS
;
worddocsafe( {STACKS},{.S},{dot_s},{from to --},{},
{Print the stack, in the current base.},
{{LIST}},
{{S0 @ DSP! 1 2 3 .S},{S[ 1 2 3 ]}},
enddoc)
HEADER({.S},{DOTS},{DOCOL})
        DC      CR
        DC      LIT, 'S', EMIT
        DC      LIT, ASO, EMIT
        DC      SPACE
        DC      SPFET, SZERO, FETCH
DOC2:   DC      OVER, OVER,  EQUAL, ZEQU
        _0BRANCH(DOC1)
        DC      ZERO, CELLP, LSUB, LDUP, FETCH, DOT
        _BRANCH(DOC2)
DOC1:    DC DROP, DROP
        DC      LIT, ASC, EMIT
        DC SEMIS
;
worddoc( {ENVIRONMENTS},{ENVIRONMENT?},{environment_query},( addr n -- i*x t/f ),{ISO},
{If the string forthsamp({addr n})
is a known environment
attribute, leave into forthsamp({i*x}) the information about that attribute and
a true flag, else leave a false flag.
In fact the flag indicates whether the words is present in the
forthcode({ENVIRONMENT}) vocabulary and forthsamp({i*x}) is what is left
by the word if executed.
},
{{VOCABULARY}},
{{"CORE" ENVIRONMENT? . .},{_T_ 0}},
{{"APE" ENVIRONMENT? .},{0}},
enddoc)
HEADER({ENVIRONMENT?},{ENVQ},{DOCOL})
        DC      ZERO, RESULT, STORE
        DC      LIT, MATCHING
        DC      LIT, ENV
        DC      TWID, FORW, TDROP
        DC      RESULT, FETCH
        DC      LDUP
        _0BRANCH(ENVQ1)
        DC      EXEC
        DC      LIT, -1
        _BRANCH(ENVQ2)
ENVQ1:  DC      DROP, ZERO
ENVQ2:
        DC      SEMIS
;
_LOAD_({
worddoc( {SCREEN},{TRIAD},{triad},{scr --},{},
{Display on the selected output device the three screens which
include that numbered forthsamp({scr}) , beginning with a screen evenly divisible
by three. Output is suitable for source text records, and includes a
reference line at the bottom taken from line 0 of the first error screen.},
{{MESSAGE},{ERRSCR} },
{{." interactive"},{interactive}},
enddoc)
HEADER({TRIAD},{TRIAD},{DOCOL})
        DC      LIT,AFF
        DC      EMIT
        DC      LIT,3
        DC      SLASH
        DC      LIT,3
        DC      STAR
        DC      LIT,3
        DC      OVER,PLUS
        DC      SWAP
        _DO(TRIA9)
TRIA1:  DC      CR,IDO
        DC      LLIST
        DC      KEYQ
        _0BRANCH(TRIA2)
        DC      LLEAV   ;{LEAVE}
TRIA2:  _LOOP(TRIA1)    ;{THEN}
TRIA9:
        DC      CR
        DC      SEMIS
});_END_({_LOAD_})
;
; This word is not even fig!
worddocsafe( {MISC},{.SIGNON},{dot_cpu},{---},{},
{Print a message identifying the version of this Forth.
_VERBOSE_({{ The name of the CPU processor present in the boot
up parameters is printed using the bizar convention of a
base-36 number. This is a tribute to those FIG-pioneers.}}) },
{{ABORT},{COLD}},
{{." Interactive"},{Interactive}},
{{COLD}},
enddoc)
HEADER({.SIGNON},{SIGNON},{DOCOL})
;{ PRINT CPU TYPE (8088)}
        DC      CR
        DC      BASE,FETCH
        DC      LIT,36, BASE,STORE
        DC      CPU, DDOT
        DC      BASE,STORE
;
        DC      NAME, LTYPE, SPACE
        DC      VERSION, LTYPE, SPACE
        DC      CR
        DC      SEMIS
;
_DIRECTMAPPED_({
;
worddoc( {MEMORY},{LOW-DP},{low_dictionary_pointer},{---- addr},{},
{A user variable leaving the lowest address that is free in the lowest
1 Mbyte of physical memory. This variable can be swapped with DP to
compile into this area. Great care must be taken to skip those areas
below 1M that are used, for GDT, real time stack and such.
},{{LOW-EM}}, {}, enddoc)
HEADER({LOW-DP},{LOWDP},{DOUSE}, _CELLS(16))
;
worddoc( {MEMORY},{LOW-EM},{low_end_memory},{---- addr},{},
{A user variable leaving the address just above the highest memory
usable in the lowest 1 Mbyte of physical memory. This area can be used
to compile buffers into that must be accessed from real mode.
},{{DP},{EM}}, {}, enddoc)
HEADER({LOW-EM},{LOWEM},{DOUSE}, _CELLS(17))
;
});_END_({ _DIRECTMAPPED_})
;
;{**** LAST DICTIONARY WORD ****}
worddoc( {MISC},{TASK},{task},{},{},
{A no-operation word which marks the boundary between
the forth system and applications. },{{COLD}},
{{!CSP TASK ?CSP},{}},
enddoc)
HEADER({TASK},{TASK},{DOCOL})
        DC      SEMIS
;
_EQULAYOUT_({
TEXTEND  EQU     _AP_       ; {Show end of dictionary.}
INITDP   EQU     M4_INITDP ;{Where we want new words.}
ACTUAL_EM EQU    EM  ;{ Different for relocatable code only.}
});_END_({ _EQULAYOUT_})

_COMMENT

The remaining memory ( up to 'EM' ) is
used for:

        1. EXTENSION DICTIONARY
        2. PARAMETER STACK
        3. TERMINAL INPUT BUFFER
        4. RETURN STACK
        5. USER VARIABLE AREA
        6. DISK BUFFERS (UNLESS REQURIED <1 MBYTE)


_ENDCOMMENT

_HOSTED_LINUX_({
;       This is the proper way to do it.
;       No memory addresses should be arrived at through equates.
;       However now we must teach the linker to keep the
;       two sections together.

FORTHSIZE       EQU     _AP_ - ORG0
         section dictionary nobits write exec alloc

INITDP:                 ;  It may be that it is not consecutive with TASK.
                        ;  Because of bad linking, resulting in a unusable Forth.
        BUFFERSIZE      EQU  (KBBUF+2*CW)*NBUF

       _RESB( EM - FORTHSIZE - RTS - US - BUFFERSIZE )
INITS0:                         ;{ Growns down}
STRTIB: _RESB( RTS )            ;{ Start return stack area}
INITR0:                         ;{ Grows down}
STRUSA: _RESB( US )             ;{ User area}
BUF1:   _RESB( BUFFERSIZE )     ;{ FIRST DISK BUFFER}
ACTUAL_EM:  ;{ Differs from EM if code is relocated.}
});_END_({ _HOSTED_LINUX_})
;

 CSEG    ENDS
        PAGE
_COMMENT

  MISC. NOTES AND SCATTERED THOUGHTS

- Remember that all the FORTH words in this version are
  upper case letters.  Use <CAPS LOCK> when in FORTH.

_HOSTED_MSDOS_({
- This source will assemble on all platforms where NASM is
  available.

  On MSDOS the command line is:
  nasm -fbin ci86.asm -o ci86.com
  (There may be exceptions for special configurations.)
  The result will run on MSDOS systems only, or stand alone
  an an IBM-compatible computer

- In a MODERN version <ctrl> P  will echo all output to the
  printer. This is not programmed here, but a feature of the MSDOS.
  The operating system may make available a command history too.

- Changing variable EM will allow you to create a larger
  dictionary space.  However I suggest you develop and
  DEBUG with EM set to 4000H.  Setting it to a larger value
  will result in a larger FORTH.EXE file, and you may
  need to run EXE2BIN ( Chap 10, DOS 2.0 ) to get enough
  disk space.  Once you are satisfied with what you have,
  then by all means take that extra memory.
});_END_({ _HOSTED_MSDOS_})

- Subscribe to FORTH Dimensions.  It is a valuable source
  of system and application ideas.  Talking with fellow
  FORTH programmers is sure to stir up some exciting ideas.
  Consider joining a FIG chapter.  See the back of FORTH
  Dimensions for more info.

- <Ctrl-Break> will vector to WARM start ( Label WRM: )

_ENDCOMMENT

;{ Define the entry point, not valid for auto booting.}
        END     ORIG
worddocchapter({COMPILING},{ },
{The wordset forthsamp({COMPILING}) contains words that compile
forthxref({IMMEDIATE}) words and numbers.
You need special precautions because these words would execute during
compilation. Numbers are compiled forthdefi({in line}) , behind a word that fetches
them.},
{},{},{},{}, {}, enddoc)
worddocchapter({CONTROL},{ },
{The wordset forthsamp({CONTROL}) contains words that influence the control flow
of a program, i.e. the sequence in which commands are executed in compiled words.
With control words you can have actions performed repeatedly, or
depending on conditions.
},{},{},{},{}, {}, enddoc)
worddocchapter({DEFINING},{ },
{The wordset forthsamp({DEFINING}) contains words that add new entries
to the dictionary. A number of such forthdefi({defining word})'s
are predefined, but there is
also the possibility to make new defining words, using
forthcode({CREATE}) and forthcode({DOES>}) .
},
{},{},{},{}, {}, enddoc)
worddocchapter({DICTIONARY},{ },
{The wordset forthsamp({DICTIONARY}) contains words that at a lower level than
the wordset forthsamp({DEFINING}) concern the memory area that
is allocated to the dictionary. They may add data to the dictionary at the expense
of the free space, one cell or one byte at a time, or allocate a buffer at once.
The dictionary space may also be shrunk, and the words that were there are lost.
The forthdefi({dictionary entry address}) or forthdefi({DEA})
represents a word. It is the lowest address of a record with
fields. Words to access those fields also belong to this
wordset.},
{},{},{},{}, {}, enddoc)
worddocchapter({DOUBLE},{ },
{The wordset forthsamp({DOUBLE}) contains words that manipulate forthdefi({double})'s.
_BITS32_({In this 32 Forth you would never need double's if it weren't
for the NUMBER formatting wordset that uses them exclusively.})},
{},{},{},{}, {}, enddoc)
worddocchapter({ERRORS},{ },
{The wordset forthsamp({ERRORS}) contains words to handle errors.},
{},{},{},{}, {}, enddoc)
worddocchapter({FORMATTING},{ },
{The wordset forthsamp({FORMATTING}) generates formatted output for
numbers, i.e. printing the digits in a field with a certain width,
possibly with sign etc.
This is possible in any forthdefi({number base}). (Normally base 10 is used,
which means that digits are found as a remainder by dividing by 10).
Formatting in Forth is always based on forthdefi({double}) numbers.
Single numbers are handled by converting them to forthdefi({double}) first.
This requires some double precision operators to be present in the Forth core.
forthxref({DOUBLE}) wordset. forthxref({MULTIPLYING}) wordset.
},
{},{},{},{}, {}, enddoc)
worddocchapter({INIT},{ },
{The wordset forthsamp({INIT}) contains words to initialise,
reinitialise or configure Forth.},
{},{},{},{}, {}, enddoc)
worddocchapter({DENOTATIONS},{ },
{The wordset forthsamp({DENOTATIONS}) contains prefixes (mostly one letter
words) that introduce a forthdefi({denotation}), i.e. a generalisation of
forthcode({NUMBER}) . Any word starting with the prefix is considered found in the
dictionary and the prefix word executed.
These words parse input and leave a constant
(number, char or string) on the stack, or compile such constant.
They reside in a special vocabulary, called forthcode({DENOTATIONS}).
To make a distinction with the same words in other wordlists,
the names of denotations are prepended with ``DEN'' in the
documentation. Actual names in the dictionary do not contain
the prefix. Apart from forthcode({DEN0}) , the vocabulary
contains entries for all hex digits forthsamp({{{{1-9,A-F}}}}).
Like forthcode({NUMBER}) always did, all denotations behave
identical in interpret and compile mode and they cannot be
postponed. },
{},{},{},{}, {}, enddoc)
worddocchapter({ENVIRONMENTS},{ },
{The wordset forthsamp({ENVIRONMENT}) contain words for all Forth
environment queries that are recognized.
By executing they leave the information
such as is required for each of these queries.
Except for the true flag at the end.
_VERBOSE_({{Note that these are not environment
variables that are passed from an operating system to a program.}})
},
{},{},{},{}, {}, enddoc)
worddocchapter({INPUT},{ },
{The wordset forthsamp({INPUT}) contains words to get input from the terminal
and such. For disk I/O: forthxref({STORAGE}) },
{},{},{},{}, {}, enddoc)
worddocchapter({JUGGLING},{ },
{The wordset forthsamp({JUGGLING}) contains words that change the lifo-buffer.
The necessity for this arise, because the data you want to feed to a program
is not directly accessible, i.e. on top of the stack.
It also possible that  you need the same data twice, because you have to feed
it to two different program's.
Design your program such that you need them as little as possible,
because they are confusing.},
{},{},{},{}, {}, enddoc)
worddocchapter({LOGIC},{ },
{The wordset forthsamp({LOGIC}) contains logic operators and
comparison operators.
A comparison operators (such as forthcode({=}) ) delivers a
forthdefi({logical flag}), 1 for true, 0 for false, representing a
condition (such as that two numbers are equal).
The logical operators ( forthcode({AND}) etc.)
work on all _BITS_ bits, one by one.
In this way they are useful for mask operations, as well
as for combining conditions
represented as flag's.
But beware that forthcode({IF}) only cares whether
the top of the stack is non-zero, such that
forthcode({-}) can mean non-equal to forthcode({IF}).
Such conditions (often named just forthdefi({flag})'s)
cannot be directly combined using logical operators,
but forthsamp({0= 0=}) can help.},
{},{},{},{}, {}, enddoc)
worddocchapter({MEMORY},{ },
{The wordset forthsamp({MEMORY}) contains words to fetch and
store numbers from forthdefi({double})s, forthdefi({cell})s or bytes in memory.
There are also words to copy blocks of memory or fill them, and words that
fetch a forthdefi({cell}), operate on it and store it back.},
{},{},{},{}, {}, enddoc)
worddocchapter({MISC},{ },
{The wordset forthsamp({MISC}) contains words that defy categorisation.},
{},{},{},{}, {}, enddoc)
worddocchapter({MULTIPLYING},{ },
{The _BITS32_(original) 16 bits Forth's have problems with scaling (forthpxref({OPERATOR})).
Operators with intermediate results of double precision solve this and are
present in the forthsamp({MULTIPLYING}) wordset. _BITS32_({In this 32-bit Forth
you will have less need, but scaling remain tricky.}).
Formatting is done with forthdefi({double})'s exclusively, and relies
on this wordset. Operators with mixed precision and unsigned operators
allow to build arbitray precision from them in forthdefi({high level}) code.},
{},{},{},{}, {}, enddoc)
worddocchapter({OPERATOR},{ },
{The wordset forthsamp({OPERATOR}) contains the familiar operators for addition, multiplication etc.
The result of the operation is always
an integer number, so division can't be precise.

Divisions involving negative numbers have an interpretation problem.
In any case we want the combination of forthcode({/}) and
forthcode({MOD}) (remainder) to be such that you can get the
original forthsamp({n}) back from the two values left by
forthsamp({n m MOD m n /}) by performing forthsamp({m * +}) .
This is true for all Forth's.
On ciforth the forthcode({/}) is a forthdefi({symmetric division}), i.e.
forthsamp({-n m /}) give the same result as forthsamp({n m /}), but negated.
The forgeoing rule now has the consequence that forthsamp({MOD n m})
has forthsamp({2m-1}) possible outcomes instead of forthsamp({m}) .
This is very worrysome for mathematicians, who stick to the rule that
forthsamp({MOD n m}) gives a result in the range forthsamp({0 ... m-1})
(forthdefi({floored division})).
_BITS16_({Having a mere 30000 for the number range can easily lead to
overflow in intermediate results during forthdefi({scaling}): a multiplication
followed by a division. _VERBOSE_({ For example forthsamp({: ADD10% 110
* 100 / ;})}). There are special operators to get around that.
forthxref({MULTIPLYING}).})},
{},{},{},{}, {}, enddoc)
worddocchapter({OUTPUT},{ },
{The wordset forthsamp({OUTPUT}) contains words to output
to the terminal and such. For disk I/O: forthxref({STORAGE}) },
{},{},{},{}, {}, enddoc)
worddocchapter({PARSING},{ },
{The forthdefi({outer interpreter}) is responsible for parsing,
i.e. it gets a word from the forthdefi({current input source})
and interprets or compiles it, advancing the
_CIF_IN_({forthcode({IN})}) _ISO_IN_({forthcode({>IN})})
pointer. The wordset forthsamp({PARSING}) contains the words
used by this interpreter and other words that consume
characters from the input source. In this way the outer
interpreter need not be very smart, because its capabilities
can be extended by new words based on those building blocks.},
{},{},{},{})
worddocchapter({SCREEN},{ },
{Most of the mass storage is used for forthdefi({screen})'s that
have 16 lines of 64 characters. They are used for source code
and documentation.
Each screen is a whole number of forthcode({BLOCK})'s,
in our case it is one block.
The forthsamp({SCREEN}) wordset contains facilities to view screens,
and forthdefi({load}) them, that is compiling them and thus extending
the base system.
A system is customized by loading source screens, possibly one of
these extension is a text editor for screens.},
{},{},{},{}, {}, enddoc)
worddocchapter({SECURITY},{ },
{The wordset forthsamp({SECURITY}) contains words that are used by control
words to abort with an error message if the control structure is not
correct. _VERBOSE_({{Some say that this is not Forth-like.}})
You only need to know them if you want to extend the
forthsamp({CONTROL}) wordset.
_NO_SECURITY_({{This version of ciforth contains no security, so the remainder
of the chapter is empty.
_VERBOSE_({{You may want to ask your implementor to supply a secure version.
forthxref({Rationale & legalese}).}})
}})
},
{},{},{},{}, {}, enddoc)
worddocchapter({STACKS},{ },
{The wordset forthsamp({STACKS}) contains words related to the
forthdefi({data stack}) and forthdefi({return stack}).
Words can be moved between both stacks.
Stacks can be reinitialised and the value used to initialise the
forthdefi({stack pointer})'s can be altered.},
{},{},{},{}, {}, enddoc)
worddocchapter({STORAGE},{ },
{The wordset forthsamp({STORAGE}) contains words to input and output
to the mass storage, in this ciforth _BOOTSECTRK_({ to the disk, by sector and track, })
_BOOTLBA_({to the hard disk}) _HOSTED_({to the file
forthfile({forth.lab}) , and to other files}).
They are underlying the forthsamp({SCREEN}) facilities.},
{},{},{},{}, {}, enddoc)
worddocchapter({STRING},{ },
{The wordset forthsamp({STRING}) contains words that manipulate
strings of characters.
In ciforth strings have been given their civil rights.
So they are entitled to a forthdefi({denotation}) and have a proper
fetch and store. An (address length) pair is considered a forthdefi({string constant}).
It may be trimmed, but the data referring to via address must not be changed.
It can be stored in a buffer, a forthdefi({string variable}), that contains
in its first cell the count. Formerly this was in the first byte, and these
are called forthdefi({old fashioned}) _VERBOSE_({{ (or less
flatteringly: brain-damaged)}}) strings.
},
{},{},{},{}, {}, enddoc)
worddocchapter({SUPERFLUOUS},{ },
{The wordset forthsamp({ SUPERFLUOUS}) contains words that are superfluous,
because they are equivalent to small sequences of code.
_VERBOSE_({Traditionally one hoped to speed Forth up by coding these words
directly.})},
{},{},{},{}, {}, enddoc)
worddocchapter({OPERATINGSYSTEM},{ },
{The wordset forthsamp({OPERATINGSYSTEM}) contains words that call the underlying operating
system or functions available in the BIOS-rom.},
{},{},{},{}, {}, enddoc)
worddocchapter({WORDLISTS},{ },
{The dictionary is subdivided in non-overlapping subsets: the
forthdefi({word list})'s. forthxref({DICTIONARY}).
_VERBOSE_({With one exception: FORTH is part of all word list
's}) They are created by the defining word
forthcode({VOCABULARY}) and filled by defining words while that
vocabulary is forthcode({CURRENT}) . They regulate how words
are found, different vocabularies can have words with the same
names. Word list's in the ISO sense have no name, which is
inconvenient. So we will loosely use the word vocabulary for
the word list that is associated with a word that is created by
the defining word forthcode({VOCABULARY}) . The wordset
forthsamp({WORDLISTS}) contains words that manipulate those
vocabularies. Vocabularies are associated with the wordlist 's
of the ISO standard, the primary difference is that they have a
name. },
{},{},{},{})
